<!DOCTYPE html>
<!-- vim: set fdm=indent tw=78: --> 
<html>
  <head>
    <title>Methods</title>
    <meta charset=utf-8>
    <!-- <script src="http://html5-now.appspot.com/base2-legacy.js"></script> 
    <script src="http://html5-now.appspot.com/html5-now.js"></script>
    -->
  </head>
  <body>

<h2>Methods</h2>

  <!-- Mention __method__ -->

  <q>A <dfn id=method>method</dfn> is a named block of parameterized code
    associated with one or more objects.</q> (<a class=ref
    href=#refFLAN08>Flanagan &amp; Matsumoto (p 176)</a>. It is the <q>code
    found in a class <i>for responding to a message</i></q> (<a class=ref
    href=#refMITCHELL04>Mitchell (p 523)</a>,
  emphasis mine. 

  <p>Having received a message, an object <dfn
    id=invoking-method>invokes</dfn> a method in response. <i>Invoke</i>
  describes the calling of a specific method, in contrast to <i>send</i>,
  which is used at a higher level to describe a request for an object to
  perform a certain operation.

  <p>A method is invoked for its side-effects, the value it returns, or a
  combination of the two.  Note that this definition encompasses
  <i>accessor</i> and <i>mutator</i> methods; Ruby makes no such distinction.

    <!-- TODO: Move instructions for _creating_ these methods out of these
    sections -->

  <h3>Instance Methods</h3>

    <p>An <dfn id=instance-method>instance method</dfn> is a method defined,
    without an explicit receiver, in the context of a class. Instances of this
    class invoke the method when sent a message with its name as the selector.
    Therefore, an object’s instance methods determine its behaviour.
     
    <aside> 
      It is conventional to employ the <code>Class#method</code> notation when
      referring to instance methods in documentation and prose. For example:
      <code>Integer#even?</code>.  
    </aside>

    <figure id=def-instance-method>
    <dt>Defining an instance method named <code>bark</code> for the <code>Dog</code> class
      with the <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def bark
              :woof
            end
          end
          Dog.new.bark #=&gt; :woof
        </code></pre>  
      </dd>
    </figure>

  <h3>Singleton Methods</h3>

    <p>A <dfn id=singleton-method>singleton method</dfn> is a method defined
    in the context of an object’s eigenclass. It is commonly described as a
    method defined on a specific object, rather than all instances of a
    certain class.

    <section>
      <h4>Class Methods</h4>

        <p>Singleton methods defined on <code>Class</code> objects are known
        as <dfn id=class-method>class methods</dfn>. For example,
        <code>File.absolute_path</code> is a class method defined on the
        <code>File</code> class. <a href=#refBLACK09>Black</a> (pp. 384–385)
        remarks that class methods are further distinguished from singleton
        methods in that <q>a method defined as a singleton method of a class
          object can also be called on subclasses of that class.</q>: class
        methods are considered by the method lookup algorithm so, unlike other
        singleton methods, they are inherited. 
        
        <p>Class methods are typically <dfn id=factory-method>factory
          methods</dfn> in that they are constructors (<i>manufacturers</i>)
        of the class’ instances.
    </section>

    <p><q>In [the] prototype-based [programming] paradigm…there are no
      classes. Rather, new kinds of objects are formed more directly by
      composing concrete, full-fledged objects, which are often referred to as
      prototypes.</q> (<a href=#refTAIVALSAARI96>Taivalsaari</a>, p. 1).
    Taivalsaari contrasts these paradigms by remarking that <q>…unlike in
      class-based languages in which the structure of an instance is dictated
      by its class, in prototype-based languages it is usually possible to add
      or remove methods and variables at the level of individual objects.</q>
    (<i>ibid.</i>, pp. 8–10) Singleton methods (along with
    <code>Object#instance_variable_set</code>) afford the same abilities to
    the ostensibly class-based Ruby. Whereas inheritance allows a class to be
    created that specializes a more general class, singleton methods allow
    creation of an object that specializes on a more general object. (Ruby can
    also support Taivalsaari’s observation that <q>…in prototype-based
      languages object creation usually takes place by copying…</q>
    (<i>ibid.</i>) through <code>Object#clone</code>). 
   
    <p>The ability to specify per-object behaviour is an improvement Ruby made
    on her predecessors. For example, in the context of Smalltalk <a
      href=refBUDD87>Budd</a> remarked that <q>It is not
      possible to provide a method for an individual object; rather every
      object must be associated with some class, and the behaviour of the
      object in response to messages will be dictated by the methods
      associated with that class.</q> (pp. 5–9).
    
    <aside>
      It is conventional to employ the
      <code><var>Class</var>.<var>method</var></code> notation when referring
      to singleton methods in documentation and prose. For example:
      <code>File.exists?</code>.  
    </aside>

    <!-- Link to Defining where singleton methods are explained -->

  <h3>Return Values</h3>

    <p>A method is a expression so always returns a value: the last statement
    executed, or <code>nil</code> if the method body is empty. If this value
    is an <code>Array</code> the method effectively returns multiple values. 

    <figure id=def-implicit-return>
      <dt>A method which returns the Symbol <code>:to_sender</code>
      <dd>
        <pre><code>
          def elvis
            :to_sender
          end
        </code></pre>
      </dd>
    </figure>

    <figure id=def-implicit-return-multiple>
    <dt>A method which returns multiple values as an <code>Array</code>.
      <dd>
        <pre><code>
          def elvis
            [:to_sender, :hound_dog]
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>A <code>return</code> statement causes the method to terminate
    prematurely, immediately passing control back to the caller. The value
    returned is that of <code>return</code>’s arguments, or <code>nil</code>
    if it has none. If multiple arguments are given they will be returned as
    an <code>Array</code>. 

    <figure id=def-explicit-return-multiple>
    <dt>A method which explicitly returns multiple values.
      <dd>
        <pre><code>
          def elvis
            return :to_sender, :hound_dog
            # Not reached
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>This gives rise to two conventions:
      <ul>
        <li>A method uses a <code>return</code> statement iff it may return
        before its last statement.
        <li>A method intended to return a value has that value as its last
        statement
      </ul>
    </p>

    <!-- TODO: Mention Object#tap -->

  <h3><code>super</code></h3>
  
    <p>The <code>super</code> keyword is used in method definitions to invoke
    a method defined in the superclass, or an ancestor thereof (collectively
    hereafter: the <i>superclass</i> <!-- Clumsy phrasing? -->), with the same
    name. If called without arguments it invokes the superclass method with
    the arguments received by the current method (this is known as the <dfn
      title="implicit argument form of <code>super</code>">implicit argument
      form of <code>super</code></dfn>).  Otherwise, it passes the arguments
    it has been given to the superclass method. In either case, the arguments
    are sent as they currently exist: if they have been modified by the
    method, their modified forms are sent. To explicitly invoke the superclass
    method without any arguments use <code>super()</code>. A
    <code>NoMethodError</code> is raised if a corresponding method is not
    defined in the superclass. 
    
    <!-- Suggest if
    self.class.superclass.instance_methods.include?(__method__) for testing
    whether such a method is defined -->

  <h3>Names</h3>

      <!-- TODO: Talk about "significant" names here? e.g. to_*,
      inspect, etc.? -->

    <!-- Markup characters with code or i or something else? -->
    
    <p>Method names conventionally begin with a lowercase letter or low line
    (U+005F: <code>_</code>) (unless they name an operator method). They must
    not begin with an ASCII integer. If they consist of multiple words, low
    lines are used to separate. They must not contain any of the following
    ASCII “punctuation” characters: <i>[</i>, <i>]</i>, <i>.</i>, <i>=</i>,
    <i>*</i>, <i>!</i>, <i>~</i>, <i>@</i>, <i>-</i>, <i>+</i>, <i>/</i>,
    <i>\</i>, <i>%</i>, <i>&lt;</i>, <i>&gt;</i>, <i>&amp;</i>, <i>^</i>,
    <i>|</i>, <i>:</i>, <i>{</i>, <i>}</i>, however:
    <!-- Unicode names -->

    <ul>
      <li>An otherwise legal method name may end with <i>=</i> or <i>!</i>,
      <i>?</i>.
      <li>The method names enumerated in the Operator Methods table are all
      exceptions to this rule, representing the only permissible permutations
      of these characters.
      <!-- TODO: Mention += and friends -->
    </ul>

    <aside>
      It is legal for a method name to begin with an uppercase letter, but
      then they may be confused with constants or class names. In fact,
      several core classes have methods named this way for precisely this
      reason: they provide a syntactical shortcut for constructing instances.
      For example, <code>Array()</code> is a method of <code>Kernel</code>
      which coerces its argument into an <code>Array</code> object. <!-- Quote
      from Pickaxe p. 137?--> 
    </aside>

    <p>By implication, any other character legal in the source encoding is
    valid in a method name. 

    <pre><code>
    # coding: utf-8
    def Π
      Math::PI
    end
    Π #=&gt; 3.141592653589793
    </code></pre>

      <!-- TODO: Unite this with section on attribute setters -->
    <h4>The <code>=</code> Suffix</h4>

      <p>Methods named with a <code>=</code> suffix can be used in assignment
      statements as <i>lvalues</i>. That is, a method defined as
      <code><var>name</var>=(<var>value</var>)</code> on object <var>obj</var>
      can be invoked as <code><var>obj</var>.<var>name</var> =
        <var>value</var></code> or
      <code><var>obj</var>.<var>name</var>=(<var>value</var>)</code>.     

      <aside class=warning>
        <p>The syntax <code>name = value</code> is therefore ambiguous. Is the
        intent to assign the value <code>value</code> to the local variable
        <code>name</code> or to invoke the method named <code>name=</code>
        with <code>value</code> as the argument?

        <p>The resolution is to always invoke a <code>=</code>-suffixed method
        with an explicit receiver, such as <code>self</code>. Alternatively,
        make it explicit that you are invoking a method with the
        <code>name=(value)</code> syntax.  
      </aside>

  <h3>Operator Methods</h3>

    <p>Many <i>operators</i> of conventional programming languages are
    implemented as <dfn id=operator-methods>operator methods</dfn> in Ruby,
    allowing them to be <i>overloaded</i> by defining a corresponding method.
    Logical operators such as <code>not</code>/<code>!</code>,
    <code>or</code>/<code>||</code>, and
    <code>and</code>/<code>&amp;&amp;</code>, are an exception to this rule,
    so cannot be overridden.

    <p>For example, an expression such as <code>3 + 2 * 10</code> is evaluated as
    <code>3.+(2.*(10))</code>, i.e. <code>2</code> is sent the message
    <code>:*</code> with <code>10</code> as the argument, which returns
    <code>20</code>, then <code>3</code>
    is sent the message <code>:+</code> with <code>20</code> as its argument.
    An implication is that even the fundamental arithmetical operations are
    implemented as operator methods defined on <code>Numeric</code> objects.
    <!-- Note derision of this concept; that it runs counter to normal
    precedence rules (does it?) -->    
    
    <p>Classes can implement their own operator methods by defining a method
    with the corresponding name, which is listed in the <i>Method</i> column
    below. This name is generally the same as the operator symbol, e.g.
    <code>+</code> implies a method named <code>:+</code>, but in the case of
    unary methods, e.g. the <code>-</code> in <code>-2</code>, the method name
    consists of the operator with an <code>@</code> suffix.

    <table id=operator-methods>
      <tr> <th>Method</th> <th>Operator</th> <th>Description</th> </tr>

      <tr>
        <td><code>[]</code></td>
        <td><code>[</code>…<code>]</code></td>
        <td>Element reference, e.g. <code>[1,2,3][1]</code> subscripting</td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>[]=</code></td>
        <td><code>[</code>…<code>]=</code></td>
        <td>Element set, e.g. <code>{foo: :bar}[:glark] = :quark</code></td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>**</code></td>
        <td><code>**</code></td>
        <td>Exponentiation, e.g. <code>3 ** 2</code></td>
      </tr>

      <tr>
        <td><code>!</code></td>
        <td><code>!</code></td>
        <td>Not, e.g. <code>!pregnant</code></td>
      </tr>

      <tr>
        <td><code>~</code></td>
        <td><code>~</code></td>
        <td>Complement, e.g. <code>~23</code></td>
      </tr>

      <tr>
        <td><code>-@</code></td>
        <td><code>-</code></td>
        <td>Unary minus (negate), e.g. <code>-42</code></td>
      </tr>

      <tr>
        <td><code>+@</code></td>
        <td><code>+</code></td>
        <td>Unary plus, e.g. <code>+(10-20)</code></td>
      </tr>

      <tr>
        <td><code>*</code></td>
        <td><code>*</code></td>
        <td>Multiplication, e.g. <code>10 * 2</code></td>
      </tr>

      <tr>
        <td><code>/</code></td>
        <td><code>/</code></td>
        <td>Division, e.g. <code>20 / 10</code></td>
      </tr>

      <tr>
        <td><code>%</code></td>
        <td><code>%</code></td>
        <td>Modulo, e.g. <code>20.5 % 16</code></td>
      </tr>

      <tr>
        <td><code>+</code></td>
        <td><code>+</code></td>
        <td>Addition, e.g. <code>20.5 + 5.2</code></td>
      </tr>

      <tr>
        <td><code>-</code></td>
        <td><code>-</code></td>
        <td>Subtraction, e.g. <code>20.5 - 5.2</code></td>
      </tr>

      <tr>
        <td><code>&gt;&gt;</code></td>
        <td><code>&gt;&gt;</code></td>
        <td>Right shift, e.g. <code>16 &gt;&gt; 1</code></td>
      </tr>

      <tr>
        <td><code>&lt;&lt;</code></td>
        <td><code>&lt;&lt;</code></td>
        <td>Left shift, e.g. <code>16 &lt;&lt; 1</code></td>
      </tr>

      <tr>
        <td><code>&amp;</code></td>
        <td><code>&amp;</code></td>
        <td>Bitwise AND, e.g. <code>2 &amp; 1</code></td>
      </tr>

      <tr>
        <td><code>^</code></td>
        <td><code>^</code></td>
        <td>Bitwise XOR, e.g. <code>2 ^ 1</code></td>
      </tr>

      <tr>
        <td><code>|</code></td>
        <td><code>|</code></td>
        <td>Bitwise OR, e.g. <code>2 | 1</code></td>
      </tr>

      <!-- TODO: Link the following with Comparable explanation -->
      <tr>
        <td><code>&lt;=</code></td>
        <td><code>&lt;=</code></td>
        <td>Less than or equal to (≤), e.g. <code>10 &lt;= 12</code></td>
      </tr>

      <tr>
        <td><code>&lt;</code></td>
        <td><code>&lt;</code></td>
        <td>Less than, e.g. <code>10 &lt; 12</code></td>
      </tr>

      <tr>
        <td><code>=&gt;</code></td>
        <td><code>=&gt;</code></td>
        <td>Greater than or equal to (≥), e.g. <code>12 =&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&gt;</code></td>
        <td><code>&gt;</code></td>
        <td>Greater than, e.g. <code>12 &gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&lt;=&gt;</code></td>
        <td><code>&lt;=&gt;</code></td>
        <td><i>Spaceship</i> operator, e.g. <code>12 &lt;=&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>==</code></td>
        <td><code>==</code></td>
        <td>Equality, e.g. <code>"wool" == "wool"</code></td>
      </tr>

      <tr>
        <td><code>===</code></td>
        <td><code>===</code></td>
        <td>Case equality, e.g. <code>Array === [1]</code></td>
      </tr>

      <!-- TODO: Mention this inverts == unless defined explicitly -->
      <tr>
        <td><code>!=</code></td>
        <td><code>!=</code></td>
        <td>Not equal, e.g. <code>"bark! != "bite"</code></td>
      </tr>

      <tr>
        <td><code>=~</code></td>
        <td><code>=~</code></td>
        <td>Pattern match, e.g. <code>/\d/ =~ "99"</code></td>
      </tr>

      <!-- TODO: Mention this inverts =~ unless defined explicitly -->
      <tr>
        <td><code>!~</code></td>
        <td><code>!~</code></td>
        <td>Inverted pattern match, e.g. <code>/\d/ !~ "d"</code></td>
      </tr>
    </table>

  <h3>Defining</h3>
    
    <p>A method consists of a name, an optional parameter list, and a body.
    Names have already been discussed, the parameter list is explained in
    <i>Arguments</i> below. The <dfn id=method-body>body</dfn> is a sequence
    of statements terminated with the <code>end</code> keyword. <!-- TODO:
    Clarify here that due to method_missing method’s need not be defined
    before they are called? -->
    
    <figure id=def-syntax>
    <dt>The syntax of a method definition.
      <dd>
        <pre><code>
          def <var>name</var> (<var>parameters</var>)
            <var>body</var>
          end
        </code></pre>
      </dd>
    </figure>
    
    <!-- TODO: Returns value which is not a method object -->
    
    <!-- Describe instance methods before singletons -->
    <p>A singleton method is defined by specifying a method name of the form
    <code><var>object</var>.<var>name</var></code>, where <var>object</var> is
    a reference to the object on which the method is being defined.

    <p>Therefore, <code>def self.<var>name</var></code> defines a class method
    for the current class. <code>def <var>Class</var>.<var>name</var></code>
    defines a method named <var>name</var> on the class named
    <var>Class</var>.

    <aside class=warn>
    Singleton methods cannot be defined on immediate values such as
    <code>Numeric</code>s and <code>Symbol</code>s. Attempting to do so raises
    a <code>TypeError</code>.
    </aside>
    
    <figure id=def-singleton-method>
    <dt>Defining a singleton method named <code>breed</code> for the <code>Dog</code> class with the
    <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def self.breed
              [new, new]
            end
          end
          Dog.breed #=&gt; [#<Dog:0x95cb530>, #<Dog:0x95cb508>]
        </code></pre>  
      </dd>
    </figure>

    <!-- Link with define_singleton_method -->

    <h4>Arguments</h4> 
    
      <p>A method may accept one or more arguments, variables passed in from the caller.

      <p>When a method is defined with the <code>def</code> keyword its name
      may be followed by a set of parentheses (<code>(</code>,
      <code>)</code>). The contents thereof (hereafter: <dfn
        id=parameter-list>the parameter list</dfn>) dictate the arguments the
      method will accept. (The parentheses are actually optional, but their
      omission doesn't enhance readability so they are recommended).

      <p>The parameter list specifies:
      <ul>
        <li>The local variable names (hereafter: <dfn id=parameters>parameters</dfn>) to which the
        corresponding argument will be aliased to inside the method.
        <li>Whether the arguments are required or optional.
        <li>Whether a fixed or variable number of arguments are allowed.
        <li>The default value, if any, of each parameter.
        <li>Whether an argument is expected to be a block.
      </ul>

      <p>Each parameter name must be unique in the parameter list.
      
      <h5>Pass By Reference</h5>

        <p>Arguments are passed to methods by reference instead of value.  If the method modifies an object
        it receives the caller’s copy is modified, too.

        <figure id=pass-by-reference>
          <dt>The effect of a method’s modification of an argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                llama #=&gt; 'arry'
              </code>
            </pre>
          </dd>
        </figure>

        <p>Methods may <i>dup</i> (<code>Object#dup</code>) their arguments to avoid this situation.    

        <figure id=pass-by-reference-dup>
        <dt>The effect of a method’s modification of a <code>dup</code>’d argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.dup.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                <mark>llama #=&gt; 'Larry'</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Required Arguments</h5>

        <p>A <dfn id=required-argument>required argument</dfn> <em>must</em>
        be supplied by the caller. A method which requires exactly 4 arguments
        must receive them all, otherwise it raises an
        <code>ArgumentError</code>.

        <aside class=note>
          <code>nil</code> and <code>false</code> are as valid an argument any
          other. If a method requires an argument and <code>nil</code> is
          supplied in its place, Ruby will not complain. Methods wishing to
          prohibit such values must do so themselves.
        </aside>

        <p>Required arguments are specified with a comma-separated list of
        parameter names. Each parameter represents a mandatory argument.

        <figure id=required-arguments>
        <dt>Defining a method which requires exactly two arguments.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def laugh(how, volume)
                    puts volume == :loudly ? how.upcase : how
                  end
                end
                Llama.new.laugh #=&gt; ArgumentError: wrong number of arguments (0 for 2)
                Llama.new.laugh(:snicker) #=&gt; ArgumentError: wrong number of arguments (1 for 2)
                Llama.new.laugh(:chortle,:softly) #=&gt; chortle
                Llama.new.laugh(:guffaw,:loudly) #=&gt; GUFFAW
                Llama.new.laugh(:ho, :ho, :ho) #=&gt; ArgumentError: wrong number of arguments (3 for 2)
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Optional Arguments and Default Values</h5>

        <p>An <dfn id=optional-argument>optional argument</dfn> <em>may</em>
        be supplied by the caller. If it is not, the corresponding parameter
        will be assigned the value given as its default.

        <p>Optional arguments are specified with a comma-separated list of
        <code><var>name</var>=<var>value</var></code> pairs, where
        <var>name</var> is a parameter name and <var>value</var> is its
        default value. The <var>value</var> may be any Ruby expression, and is
        permitted to refer to previous parameters. The default value is
        evaluated each time the method is invoked, so may, for example,
        instantiate an object on every invocation. 

        <figure id=optional-arguments>
        <dt>Defining a method which takes an optional argument.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def name(name='Larry')
                    name + ' the llama (beast of burden)'
                  end
                end
                Llama.new.name #=&gt; "Larry the llama (beast of burden)"
                Llama.new.name('Lyle Jr.') #=&gt; "Lyle Jr. the llama (beast of burden)"
                Llama.new.name('Lama', 'glama') #=&gt; ArgumentError: wrong number of arguments (2 for 1)
              </code>
            </pre>
          </dd>
        </figure>

        <p>Optional and required arguments can be specified alongside each
        other in a reasonably natural fashion. However, all optional arguments
        must be adjacent. For instance, it is a <code>SyntaxError</code> to
        both precede and follow a required argument with optional arguments.

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Variable-Length Argument Lists</h5>

        <!-- TODO: Standardise on terms: 'rest' or 'splat' -->

        <p>A <dfn id=rest-parameter>rest parameter</dfn> (or <dfn
          id=splat-parameter>splat parameter</dfn>) consumes every argument
        that follows it while still allowing subsequent required parameters to
        receive their corresponding arguments. Put simply: it takes an
        arbitrary number of arguments from its position onward. It is passed
        to the method as an <code>Array</code> containing one argument per
        element.

        <aside class=note>
          Rest parameters do not <em>require</em> any arguments, so a method
          whose parameter list consists solely of a rest parameter, for example,
          may be invoked with zero or more arguments.
        </aside>

        <p>A rest parameter is specified by preceding a parameter name with an
        asterisk (U+002A: <code>*</code>). Only one rest parameter may appear
        in a parameter list, and any optional parameters must precede it.

        <figure id=rest-arguments>
        <dt>Defining a method which takes a variable number of arguments.</dt>
          <dd>
            <pre>
              <code>
              def zero_or_more(*rest)
                rest.join(', ')
              end
              zero_or_more #=&gt; ""
              zero_or_more(1) #=&gt; "1"
              zero_or_more(1,2,3) #=&gt; "1, 2, 3"
              </code>
            </pre>
          </dd>
        </figure>

        <!-- TODO: Cut this section? We now state above that any optional
        arguments must precede the _rest_ -->

        <aside class=note>
          The following syntax rules are complex, but do not be deterred.  They are unlikely to ever be
          relevant in practice.
        </aside>

        <!-- FIXME: Clarify this explanation; derive a general principle
        which better expresses the rule -->

        <p>A rest parameter must not be followed by an optional parameter because of the resulting
        ambiguity: if two or more arguments were supplied for the former, should the latter be assigned its
        default value or take one of the aforementioned? However, there is no ambiguity when optional
        parameters precede the rest parameter, so this arrangement is legal.

        <p>Conversely, a rest parameter may be either followed or preceded by one or more required
        parameters

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

        <p>A rest parameter may be supplied as a sole asterisk, omitting the corresponding parameter name.
        The effect is to consume the corresponding arguments as an ordinary rest parameter, without
        assigning them to a local variable. The arguments are ignored.  This allows methods to accept an
        arbitrary number of arguments, but discard, say, all but the last. 

        <p>Thomas et al. (<a href=#refTHOM09>[THOM09]</a>) suggest that this technique can used in
        conjunction with <code>super</code> to define a method which accepts an arbitrary number of
        arguments then passes them all to its superclass.

        <figure id=rest-parameter-with-super>
        <dt>A method which accepts a variable number of arguments then passes them to its superclass
        (<code>Parent</code>) with the implicit-argument form of <code>super</code>. (<a
          href=#refTHOM09>[THOM09]</a>).
          <dd>
            <pre>
              <code>
                class Child &lt; Parent
                  def do_something(*)
                    # our processing
                    super
                  end
                end
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Named Arguments</h5>

        <p>The parameter forms described above are positional in nature.  They depend on the argument’s
        location in the parameter list to marry it with the correct parameter. An alternative approach, that
        can aid the readability of otherwise ungainly parameter lists, is <dfn id=named-arguments>named
          arguments</dfn>. Named arguments allow the method to be invoked with a series of key-value pairs,
        arranged in an arbitrary order.

        <p>Ruby does not offer explicit support for this style of argument passing, but it can be ably
        approximated by defining methods that expect a <code>Hash</code> argument: the keys of which become
        the parameter names; and the values, the arguments.

        <!-- TODO: Mention that File/IO, String#encode use this technique -->

        <figure id=named-arguments>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments.
          <dd>
            <pre>
              <code>
                class Chair
                  def initialize(args)
                    @legs = args[:legs] or raise ArgumentError
                    @style = args[:style] || :victorian
                    @height = args[:height] || :average
                    @colour = args[:colour] || args[:color] || :brown
                  end
                end
              Chair.new legs: 4, height: :tall #=&gt; 
                #&lt;Chair:0x8249908 @legs=4, @style=:victorian,
                @height=:tall, @colour=:brown&gt;
              Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                #&lt;Chair:0x86958f4 @legs=7, @style=:victorian,
                @height=:average, @colour=:fuschia&gt;
              Chair.new(height: :childs, color: :fuschia) #=&gt;
              ArgumentError 
              </code>
            </pre>
          </dd>
        </figure>

        <p>If the <code>Hash</code> is the final argument, other than a block,
        that a method expects, the curly braces which delimit the
        <code>Hash</code> can be omitted. For example, <code>m({ key: :value
          })</code> can be written as <code>m key: :value</code>.

        <p>The advantages of this approach include:
          <ul>
            <li>Arguments can be specified in any order.
            <li>Arguments with default values can be omitted.
            <li>If <code>Symbol</code>s are used for the <code>Hash</code> keys the invocation is
            particularly readable.
            <li>Variable-length argument lists are supported.
          </ul>

        <figure id=named-arguments-with-defaults>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments with default
        values.
          <dd>
            <pre>
              <code>
                class Chair
                  DEFAULT_ARGS = {legs: 2, style: :victorian, height: :average, colour: :brown}
                  def initialize(args)
                    @attributes = DEFAULT_ARGS.merge args
                  end
                end
                Chair.new legs: 4, height: :tall #=&gt;
                  #&lt;Chair:0x9039af4 @attributes={
                  :legs=&gt;4,       :style=&gt;:victorian, 
                  :height=&gt;:tall, :colour=&gt;:brown
                  }&gt;
                Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                  #&gt;Chair:0x998a9dc @attributes={
                  :legs=&gt;7, :style=&gt;:victorian, 
                  :height=&gt;:average, :colour=&gt;:fuschia
                  }&gt;
              </code>
            </pre>
          </dd>
        </figure>

        <p>The primary shortcoming is that Ruby can not determine
        automatically whether an invalid number of arguments have been
        supplied; the programmer must validate the arguments instead. This is
        unlikely to be particularly significant, however, because a method
        expecting a variable number of arguments would otherwise use rest
        arguments, which would also render it unable to perform this
        validation.

      <h5>Block Arguments</h5>
        
        <p>Any method may be invoked with a block literal as an argument by
        specifying the block after the method invocation. <!-- message
        expression instead of method invocation? -->

        <aside class=note>
        <a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
          130-131)</a> insist on <q>[using] the term iterator…to mean any
          method that uses the <code>yield</code> statement</q>, despite
        admitting that this doesn't make sense if the method doesn’t actually
        <i>iterate</i> over the block it has been given. We will not
        perpetuate this confusion: an <i>iterator method</i> iterates over the
        block it has been given; a method which expects a block but does not
        iterate over it is simply <i>a method that expects a block</i>.
        </aside>

        <figure id=method-invocation-with-block-literal>
        <dt>A method which receives, and ignores, a block specified with either of the block literal
        constructs.
          <dd>
            <pre>
              <code>
              def m
                :m
              end
              m { 1 + 2 }
              m do
                1 + 2
              end
              </code>
            </pre>
          </dd>
        </figure>
         
        <p>A method may determine whether it has received a block with the
        <code>block_given?</code> predicate.

        <figure id=method-using-block_given>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block.
          <dd>
            <pre>
              <code>
              def m
                puts "Thanks" if block_given?
              end
              m { 1 + 2 } #=&gt; "Thanks"
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A block passed to a method in this way is not automatically called;
        the method must use the <code>yield</code> keyword to do so. An
        implication of this is that methods not expecting blocks will ignore
        them. The return value of <code>yield</code> is that of the block.

        <!-- TODO: Mention that yield takes arguments -->

        <figure id=method-using-block_given-yield>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block, and if so calls it.
          <dd>
            <pre>
              <code>
              def m
                puts "This block returns: #{yield}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A method needing a reference to the block it was given, perhaps to
        pass to another method, is defined with a final parameter whose name
        is prefixed with an ampersand (U+0026: <code>&amp;</code>).  For
        example: <code> def m(a,b,&amp;block)</code>. The method can access
        the block as a <code>Proc</code> object named after the parameter
        (sans ampersand). It may invoke the block via its
        <code>Proc#call</code> method, or <code>yield</code> to it. In either
        case, the method is invoked in precisely the same way as before.

        <!-- Example with instance_eval ? -->

        <figure id=method-using-block-argument>
        <dt>A method which uses a <code>&amp;block</code> parameter to refer to the block it is given.
          <dd>
            <pre>
              <code>
              def m(&amp;block)
                puts "This block returns: #{block.call}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <aside class=note>
          <p>The discussion above applies only to block <i>literals</i>; a method
          expecting a <em>reference</em> to a block, i.e. a <code>proc</code>
          or <code>lambda</code>, need not pay heed. Such a method employs
          precisely the same parameter list as in the previous sections.

          <figure id=method-receiving-block-ref>
          <dt>A method which expects a reference to a block uses the same
          parameter list as it would if expecting any other type of variable.
            <dd>
              <pre>
                <code>
                def m(b)
                  b.call
                end
                m -&gt;{ "I am a \u{3bb}!" } #=&gt; "I am a λ!"
                </code>
              </pre>
            </dd>
          </figure>
        </aside>

    <h4>Dynamic Method Definition</h4>

      <p>An instance method can be defined dynamically with
      <code>Module#define_method(<var>name</var>, <var>body</var>)</code>, where <var>name</var> is the
        method’s name given as a <code>Symbol</code>, and <var>body</var> is its body given as a
        <code>Proc</code>, <code>Method</code>, <code>UnboundMethod</code>, or literal block. This
        allows methods to be defined at runtime, in contrast to <code>def</code> which requires the
        method name and body to appear literally in the source code.

      <figure id=define-method>
      <dt>Using <code>define_method</code> to dynamically create a method with a user-supplied
      name and body.
        <dd>
          <pre>
            <code>
            class Conjure
              def self.conjure(name, lamb)
                define_method(name, lamb)
              end
            end
            # Define a new instance method with a lambda as its body
            Conjure.conjure(:glark, -&gt;{ (3..5).to_a * 2 })
            Conjure.new.glark #=&gt; [3, 4, 5, 3, 4, 5]         
            </code>
          </pre>
        </dd>
      </figure>

      <p><code>Module#define_method</code> is a private method so must be called from within the class
      the method is being defined on. Alternatively, it can be invoked inside
      <code>class_eval</code> like so:
  
      <figure id=define-method-class-eval>
      <dt>Using <code>define_method</code> inside <code>class_eval</code> to dynamically create
      a method with a user-supplied name and body.
        <dd>
          <pre>
            <code>
            Array.class_eval do
              define_method(:second, -&gt;{ self.[](1) })
            end
            [3, 4, 5].second #=&gt; 4
            </code>
          </pre>
        </dd>
      </figure>
        
      <p><code>Object#define_singleton_method</code> is called with a class name as the receiver and
      the same arguments as <code>Module#define_method</code> for the obvious purpose. 

      <figure id=define-singleton-method>
      <dt>Using <code>define_singleton_method</code> to dynamically create a method.
        <dd>
          <pre>
            <code>
            File.define_singleton_method(:match) do |file, pattern|
              File.read(file).match(pattern)
            end
            File.match('/etc/passwd',/root/) #=&gt; #&lt;MatchData "root"&gt;
            </code>
          </pre>
        </dd>
      </figure>

  <h3>Arity</h3>
    
    <p>The arity of a method is the number of arguments it takes. If the
    method expects a fixed number of arguments, this number is its arity.  If
    the method expects a variable number of arguments, its arity is the
    additive inverse of its parameter count. Methods implemented in C, i.e.
    most core methods, have an arity of <code>-1</code> if they accept a
    variable number of parameters. It follows, then, that an arity ≥ 0
    indicates a fixed number of parameters; a negative value, a variable
    number. <code>Method</code> and <code>Proc</code> objects have
    <code>#arity</code> methods which return the arity for the method/proc it
    objectifies.

    <h4>Classification by Arity</h4>

      <p>Methods with fixed arities can be classified as follows: A <dfn
        id=unary-method>unary method</dfn> expects exactly one operand (its
      receiver), a <dfn id=binary-method>binary method</dfn> requires two (its
      receiver and one argument), <dfn id=ternary-method>ternary-method</dfn>
      requires exactly three (its receiver and two arguments), an <dfn
        id=n-ary-method><var>n</var>-ary method</dfn> requires <var>n</var>
      operands (its receiver, and <var>n</var>-1 arguments).

  <h3>Undefining</h3>

    <p>The <code>undef</code> statement takes one or more
    <code>Symbol</code>s/identifiers as arguments, then undefines the
    corresponding instance methods. Undefining singleton methods requires
    <code>undef</code> to be used in the context of the corresponding
    eigenclass.

    <p><dfn id=undef-method>Undefining</dfn> a method prevents the current
    class from responding to it. If the method was defined in a superclass,
    that copy is unaffected. For example, consider a <code>Rectangle</code>
    class which defines <code>:height</code> and <code>:width</code> methods.
    A <code>Square</code> class inherits from it, but it doesn’t make sense
    for <code>Square</code> to have both <code>:height</code> <i>and</i>
    <code>:width</code> methods. <code>Square</code> can <code>undef</code>
    <code>:height</code>, preventing <code>Square#height</code> from being
    called without affecting <code>Rectangle#height</code>.

    <figure id=undef-method>
    <dt>Undefining a method with <code>undef</code>.
      <dd>
        <pre><code>
        def boo!
          "(goose)"
        end
        boo! #=&gt; "(goose)"              
        undef :boo!
        boo! #=&gt; NoMethodError: undefined method `boo!' for main:Object 
        </code></pre>
      </dd>
    </figure>

    <!-- Mention Module#undef_method? Does it offer any advantages? Better
    symetry with remove_method? -->

  <h3>Removing</h3>
  
    <p><code>Module#remove_method <var>name</var></code> removes the method
    named <var>name</var> from the current class only. A <dfn
      id=remove-method>removed method</dfn> differs from an undefined method
    in that the former delegates the request to its superclass, whereas the
    latter doesn’t.
    
    <!-- Use same example for undef_method so they can be contrasted -->
    <pre><code>
    class Parent
      def says
        "Tidy your room!"
      end
    end

    class Child &lt; Parent
      def says
        "In a minute..."
      end
    end
    
    Child.new.says #=&gt; "In a minute..."
    
    class Child
      remove_method :says
    end
    
    Child.new.says #=&gt; "Tidy your room!"
    </code></pre>

  <h3>Visibility</h3>

    <!-- Clarify that its the binding of a method to a class that has a
    visibility? c.f. matz -->

    <p>An instance method is either <i>public</i>, <i>private</i>, or
    <i>protected</i>. It is declared as such with <code>Module#public</code>,
    <code>Module#private</code>, and <code>Module#protected</code> (hereafter:
    <i>visibility specifiers</i>), respectively. 
    
    <p>A visibility specifier invoked without arguments affects every method
    subsequently defined in the same class definition until another visibility
    specifier is encountered.

    <figure id=visibility-specifiers>
      <dt>Declaring the visibility of methods with visibility specifiers
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          private
          # This method is private because it appears after the
          #'private' visibility specifier
          def pri
          end

          # This method is also private because the previous visibility
          # specifier has not been overridden
          def pri2
          end

          protected
          # This method is protected because it appears after the
          #'protected' visibility specifier
          def pro
          end
          
          public
          # This method is public because the protected visibility
          # specifier has been explicitly overridden. Typically this would
          # have been defined after 'pub', removing the need for a
          # visibility specifier
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <p>A visibility specifier with one or more method names (given as
    <code>Symbol</code>s or <code>String</code>s) affects only the named
    methods, which must have already been defined.

    <figure id=visibility-specifiers-args>
      <dt>Declaring the visibility of methods with visibility specifiers that
      take arguments
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          def pri
          end

          def pri2
          end

          # Both :pri and :pri2 are made private because their names are
          # given as arguments to the 'private' visibility specifier
          private :pri, :pri2

          def pro
          end
          # This method is made protected because its name is given to
          # the 'protected' visibility specifier
          protected 'pro'
          
          # This method is public because it hasn't been declared
          # otherwise; the previous 'protected' specifier only affects the
          # method it was called for
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <h4>Advisory Privacy</h4>

      <p>Method visibility is merely an advisory construct. Ruby does not
      <i>prohibit</i> the invocation of private methods; she ensures that they
      will not be called accidentally as follows:

      <ul>
        <li>Standard method invocation syntax (<code>obj.method</code>) raises
        a <code>NoMethodError</code>, signaling that the programmer's intent
        is ill-advised. The caviller programmer must use a technique such as
        <code>Object#send</code> to explicitly ignore the privacy advice.
        <li>The method introspection API (e.g.
        <code>Object#private_methods</code>,
        <code>Object#protected_methods</code>, and
        <code>Object#public_methods</code>) delineates methods by their
        visibility, allowing private and protected methods to be determined
        automatically.
        <li>RDoc/<code>ri</code> only displays public methods by default.
      </ul>

    <h4>Public Methods</h4>

      <p>A method is public unless explicitly declared otherwise, or declared
      outside of a class definition. The <code>initialize</code> method is
      private by default.

    <h4>Private Methods</h4>

      <p>A <dfn id=private-method>private method</dfn> cannot be invoked with
      an explicit receiver: it can only be called by other instance methods of
      the class in which defined, or a subclass thereof. 

      <p><code>self</code> is also regarded as an explicit receiver so a
      method invocation of the form <code>self.<var>private</var></code>,
      where <var>private</var> is a private instance method in the same class,
      is disallowed.

      <aside class=note>
        Methods created outside of a class or module definition, i.e. at the
        top level, are private by default The <code>:initialize</code> method
        is, too, because it is only intended to be invoked from the object’s
        <code>:new</code> method.
      </aside>

    <h4>Protected Methods</h4>

      <p>Protected methods can invoked only from the class in which they were
      defined or a subclass thereof, that is they behave the same as private
      methods. However, unlike private methods they can be explicitly invoked
      on any instance of their class.

      <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, p.
        232)</a> suggest that <q>A protected method can be used, for example,
        to define an accessor that allows instances of a class to share
        internal state with each other, but does not allow users of the class
        to access that state.</q>

    <h4>Class Methods</h4>

    <p>A class <!-- "Singleton"? --> method named <var>name</var> can be
    privatised with <code>Module#private_class_method <var>name</var></code>.
    Private class methods can be made public with
    <code>Module#public_class_method <var>name</var></code>. It is nonsensical
    to deign a class method protected, so there is not a corresponding
    visibility specifier.

  <h3>Aliases</h3>

    <p>An <dfn id=method-alias>alias</dfn> of a method is an alternate name by
    which it can be referred. For a method, <var>m</var>, and its alias,
    <var>a</var>, invoking <var>m</var> is equivalent to invoking
    <var>a</var>.

    <p>The alias refers to a copy of the existing method’s body. If the
    existing method is redefined after being aliased, the alias will continue
    to refer to the method’s original definition.

    <p>Aliases are often used to provide synonyms for method names. For
    instance, <code>:size</code> may be aliased to <code>:length</code>.  This
    allows the programmer to use method names which “read” more naturally in a
    given context. <!-- TODO: example from FLAN09 about Range#include? ? -->

    <p>An alias is created with the <code>alias</code> keyword from inside the
    class of the existing method. The syntax is <code>alias
      <var>new_name</var> <var>current_name</var></code>, where both
    <var>new_name</var> and <var>current_name</var> are <code>Symbol</code>s
    or identifiers. A method named <var>current_name</var> must already be
    defined.  If a method named <var>new_name</var> already exists it is
    overwritten.

    <p><code>Module#alias_method <var>new_name</var>,
      <var>current_name</var></code> can be used to the same effect, the
    difference being that it uses standard method semantics to interpret
    identifier arguments: treating them as expressions; not literal method
    names. This allows methods to be aliased dynamically. For example,
    <code>alias new old</code> interprets its arguments as literal
    identifiers, whereas <code>alias_method <var>new</var>,
      <var>old</var></code> sees them as variables, whose values are the
    method names. By implication, if the arguments to
    <code>Module#alias_method</code> <i>should</i> be interpreted as literal
    identifiers they must be supplied as <code>String</code> or
    <code>Symbol</code> literals, e.g. <code>alias_method :new, :old</code>.

    <!-- TODO: Mention alias_method_chain ?
    http://yehudakatz.com/2009/03/06/alias_method_chain-in-models/ -->

    <p>Aliasing is also used to create a method which wraps the method of the
    same name by performing its own computations then calling the original
    method. For example, in the example below we wrap <code>String#to_i</code>
    such that it raises an exception if the string doesn't contain digits.
    (Normally, <code>String#to_i</code> returns <code>0</code> for such
    strings). <!-- Note that super is preferred when the method is defined in
    a superclass -->

    <figure id=alias-for-wraping>
    <dt>Using <code>alias</code> in order to wrap a method
      <dd>
        <pre><code>
        class String
          alias :old_to_i :to_i
          def to_i
            raise "No digits found" unless match(/\d/)
            old_to_i
          end
        end
        </code></pre>
      </dd>
    </figure>

    <!-- TODO: Link with example of using method objects to wrap methods
    (c.f.
    http://blog.jayfields.com/2006/12/ruby-alias-method-alternative.html);
    explain pros/cons -->

  <!-- TODO: Discuss method overloading? -->

  <!-- TODO: Algo. for determining a method's aliases -->

  <h3>Lookup Algorithm</h3>
  
    <p>Evaluating a message expression requires the corresponding method
    definition be located in the receiver. The steps below illustrate the
    lookup algorithm for a message with a selector of <var>selector</var>, where
    <var>class</var> is set to that of the receiver. When a method is found
    whose name is equal to <var>selector</var> the process terminates. It will
    always ultimately succeed because <code>BasicObject</code> defines a
    <code>:method_missing</code> method.

    <ol>
      <li>Search the singleton methods of <var>class</var>’s eigenclass.
      <li>Search the singleton methods of the superclass, and ancestors, of
      <var>class</var>’s eigenclass.
      <li>Search the instance methods of <var>class</var>.
      <li>Search the instance methods of modules included by <var>class</var>.
      (Modules are searched in reverse order of inclusion).
      <li>If <var>class</var> has a superclass, assign it to <var>class</var>
      then go to step three. (<code>BasicObject</code> doesn't have a superclass,
      so at that point this step will terminate).
      <li>Set <var>selector</var> to <code>:method_missing</code>, prepend the
      original selector to the argument list, set <var>class</var> back to the
      receiver’s class, and go to step one.
    </ol>

    <p><a href=#refTHOM09 class=ref>Thomas et al.</a> describe this
    algorithm as <q>Ruby looks first in the immediate class of an object, then
      in the mixins included into that class, and then in superclasses and
      their mixins. If a class has multiple modules mixed in, the last one
      included is searched first.</q>

  <h3>Missing Methods</h3>

    <p>The exposition above shows that sending an object a message for which a
    corresponding method is not defined causes each object on the search path
    to be sent <code>:method_missing</code> with the original selector as the
    first argument, and the original arguments as the remainder.
    <code>BasicObject</code> defines <code>:method_missing</code> to provide
    the default behaviour of raising <code>NoMethodError</code> for
    non-existent methods. However, if another object defines
    <code>:method_missing</code> they can intervene, averting the exception
    and responding to the message themselves. 


    <aside class=note>
      The <code>NoMethodError</code> exception has an <code>#args</code>
      method which returns the arguments sent to the original method as an
      <code>Array</code>, and <code>#name</code> which returns the original
      method name as a <code>Symbol</code>. This information can be used to
      perform introspection on the caught exception and enhance error
      messages.
    </aside>

    <figure id=basicobject-method_missing>
    <dt>A demonstration of <code>BasicObject#method_missing</code>
    <dd>
        <pre><code>
        class BasicObject
          public :method_missing
        end
        b = BasicObject.new
        b.method_missing :glark #=&gt; NoMethodError: undefined method `glark' for #<BasicObject:0x93ace0c>
        </code></pre>
      </dd>
    </figure>
    
    <p>If <code>method_missing</code> is invoked with a message it
    does not wish to respond to, it should use the implicit-argument form of
    <code>super</code> to delegate to its parent. This gives the parent the
    option of responding to the message, or otherwise triggers the default
    behaviour. 

    <aside class=warn>
      Logic errors inside <code>method_missing</code> can easily lead to
      infinite loops, which can be troublesome to debug. The typical mistake
      is for a statement in the body of <code>method_missing</code> to send a
      non-existent message to the same object. The object does not respond to
      that message, so the <code>method_missing</code> method is invoked a
      second time, and so the loop continues.
    </aside>

    <p><a class=ref href=#FOWLER08>Fowler</a> describes the use of
    <code>method_missing</code> to <q>respond differently to an unknown
      message.</q> as “Dynamic Reception”. One use he suggests is to
    <q>convert what might otherwise be method parameters into the name of the
      method.</q>, contrasting <code>find_by("firstname", "martin",
      "lastname", "fowler")</code> with the
    <code>method_missing</code>-supported
    <code>find_by_firstname_and_lastname("martin", "fowler")</code>. (The
    example was derived from a feature of Ruby on Rails (<a href=#refBUCK06
      class=ref>Buck</a>, 2006). He identifies a variation on this idea where
    a <q>a sequence of Dynamic Receptions</q> are chained together, such that
    each method returns an “Expression Builder”, e.g.
    <code>find_by.firstname("martin").and.lastname("fowler)<code>.

  <h3><code>Kernel#respond_to_missing?</code></h3>

    <p>A consequence of defining methods dynamically with
    <code>Kernel#method_missing</code> is that an object may respond to a given
    message, yet return <code>false</code> for
    <code>Kernel#respond_to?(<var>selector</var>)</code>.
    
    <p>Before <code>Kernel#respond_to?</code> returns <code>false</code> it
    tries to send itself a message named <code>:respond_to_missing?</code> with
    a first argument of the selector in question, and the second the value of
    <var>include_private</var>. (If <code>#respond_to?</code> is called with a
    second argument of <code>true</code>, <var>include_private</var> is
    <code>true</code> and private methods should be considered; otherwise its
    <code>false</code> and they shouldn’t). If
    <code>#respond_to_missing?</code> is defined and returns a true value,
    <code>#respond_to?</code> returns <code>true</code>; otherwise
    <code>#respond_to?</code> returns <code>false</code>. 
    
    <p>Therefore, <code>#respond_to?</code> can be made to work with methods
    defined with <code>method_missing</code> by defining a
    <code>#respond_to_missing?</code> method which returns <code>true</code>
    when passed the name of such a method.

  <h3><code>Method</code> Objects</h3>

    <p>An instance of the <code>Method</code> class represents a method bound
    to an object. This <dfn id=method-object>method object</dfn> enables you
    to store a reference to a method in a variable, as you would any other
    object, query the method’s metadata, and manipulate it. This is quite
    distinct from capturing the return value of a method. <!-- TODO: Note that
    unlike procs, method objects aren't closures -->

    <p>Method objects can be created with <code>Kernel#method</code>:
    <code><var>receiver</var>.method(<var>name</var>)</code>, where
    <var>name</var> is the method name as a <code>Symbol</code> or
    <code>String</code>. For example, <code>method(:eval)</code> returns a
    <code>Method</code> object for <code>Kernel#eval</code>. If the object
    does not <code>respond_to?</code> the given method a
    <code>NameError</code> will be raised. (Therefore, if the object’s
    <code>respond_to_missing?</code> method returns <code>true</code> for the
    method in question the method object will be created successfully).

    <p><code>Kernel#public_method</code> works in the same way, but raises a
    <code>NameError</code> if the given method is private or protected.

    <h4>Arity</h4>

      <p><code>Method#arity</code> returns an <code>Integer</code>
      corresponding to the method’s arity.

    <h4>Calling</h4>

      <p>The method represented by a <code>Method</code> object can be invoked with
      <code>Method#call</code> or its alias <code>Method#[]</code>. The semantics are the same as
      for standard method invocation. <a href=#refFLAN08>Flanagan &amp; Matsumoto</a> caution,
      however: <q>…invoking a method through a <code>Method</code> object is less efficient than
        invoking it directly.</q>

    <h4>Converting to a <code>Proc</code></h4>
      
      <p>A method object can be converted to a <code>Proc</code> by prefixing it with an ampersand
      (<code>&amp;</code>). Therefore it can be passed to a method expecting a block. <!-- TODO: Note
      availability of Symbol:to_proc; use with define_method -->
    
    <h4>Equality</h4>

      <!-- Bug: #1898 -->
      <p><code>Method#==</code> returns true if both methods are bound to the same object and have
      the same body. The first requirement means that the objects must be identical in the sense of
      <code>Object.equal?</code>. The second encompasses methods defined with
      <code>Object#define_method</code> using the same <code>Proc</code>/block, aliases created
      with <code>alias</code>, and core method aliases. <!-- TODO: clarify situation with
      #respond_to_missing? -->
      
      <!-- Example which uses equality to determine if a method is an alias,
      or find all aliases for a given class -->

    <h4>Source Location</h4>

      <p>The filename and line number where a method was defined is returned as an <code>Array</code>
      by <code>Method#source_location</code>. If the method is core, i.e. implemented in C, it returns
      <code>nil</code>. This is primarily useful for extracting a method’s signature and any preceding
      documentation.

      <!-- Example using the fact that no source location indicates a non-Ruby
      implementation. #ruby? #c? #core? The latter would need addition heuristics, in
      theory. -->
    <h4>Parameters</h4>

      <!-- [ruby-core:19759] Proposal: Method#get_args -->   
        
      <p><code>Method#parameters</code> returns an <code>Array</code>, each element of which is a
      sub-<code>Array</code> of <code>Symbol</code>s that describe the corresponding parameter
      expected by the method. The first <code>Symbol</code> is <code>:req</code> for a required
      parameter, <code>:opt</code> if it is optional, <code>:rest</code> if its of variable length,
      or <code>:block</code> if it corresponds to a block. The last <code>Symbol</code> is the name
      of the parameter. An empty <code>Array</code> is returned for method’s expecting no arguments.

  <h3><code>UnboundMethod</code> Objects</h3>

    <p>An <code>UnboundMethod</code> object is a <code>Method</code> object disassociated from the
    object on which it was defined.     
     
    <p>A <code>Method</code> object may converted to an
    <code>UnboundMethod</code> object with <code>Method#unbind</code>.
    Alternatively, they can be created with
    <code>Module#instance_method</code>. For example,
    <code>String.instance_method(:downcase)</code> creates an
    <code>UnboundMethod</code> object for <code>String#downcase</code>.
    <code>Module#public_instance_method</code> works in the same way, but
    raises a <code>NameError</code> if the given method is private or
    protected. 
      
    <p>Before an <code>UnboundMethod</code> is invoked it must be re-associated with, or <dfn
      id=method-bind>bound</a> to, to an object which is a <code>Object#kind_of?</code> its original
    class. This is achieved by passing an object reference to <code>UnboundMethod#bind</code>.

    <p>With the exception of <code>#call</code>, for the reason described above,
    <code>UnboundMethod</code> objects support the same method’s as <code>Method</code> objects.

    <p><a href=#refBLACK09>Black</a> (pp. 418-420) provides the following example (with minor
    adjustments for formating) of using <code>UnboundMethod</code> objects:
      
    <blockquote>
        
      <p>The following question comes up periodically in Ruby forums:
        
      <blockquote>
        <p>Suppose I’ve got a class hierarchy where a method gets redefined:
          
        <pre><code>
         class A
          def a_method
            puts "Definition in class A"
          end
         end
         class B &lt; A
          def a_method
            puts "Definition in class B (subclass of A)"
          end
         end
         class C &lt; B
         end
         </code></pre>
          
        <p>And I’ve got an instance of the subclass (<code>c = C.new</code>). Is there any way to
        get that instance of the lowest class to respond to the message (<code>a_method</code>) by
        executing the version of the method in the class two classes up the chain?
        
      </blockquote>
        
      <p>By default, of course, the instance doesn’t do that; it executes the first matching method
      it finds as it traverses the method search path: <code>c.a_method</code>. The output is
      <samp>Definition in class B (subclass of A)</samp>. But you can force the issue through an
      unbind and bind operation: <code>A.instance_method(:a_method).bind(c).call</code>. Here the
      output is <samp>Definition in class A</samp>.
      
    </blockquote>
  </body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<chapter version="5.0" xml:id="con.concurrency" xml:lang="en" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Concurrency</title>

  <sect1 xml:id="con.threads">
    <title>Threads</title>

    <para>A program typically runs along a single thread of execution: each statement is executed sequentially and predictably. Programs that use only this thread—termed the <firstterm>main thread</firstterm>—are <firstterm>single-threaded</firstterm>; by contrast, a <firstterm>multithreaded</firstterm> program has multiple threads of execution, each of which is associated with a block of code. The operating system rapidly switches between these threads—letting each run for a fraction of a second—creating the appearance<footnote><para>Sadly, Ruby does not actually execute threads concurrently even on multi-core CPUs because some extension libraries are not thread-safe: only one thread runs at any given time.</para></footnote> of parallel execution.</para>

    <para>Threads are represented as instances of the <literal>Thread</literal> class. <function>Thread.current</function> and <function>Thread.main</function> return <literal>Thread</literal> objects corresponding to the current and main threads, respectively.</para>

    <sect2 xml:id="con.thread-init">
      <title>Initialisation</title>

      <para>Threads are created by passing a block to <function>Thread.new</function> which creates a new thread to run the block then returns immediately. Any arguments given are passed to the block as block paramaters. <function>Thread.start</function>, and its alias <function>Thread.fork</function>, behave identically except if their receiver is a subclass of <literal>Thread</literal> its <literal>initialize</literal> method is not called.</para>
    </sect2>

    <sect2 xml:id="con.thread-status">
      <title>Status</title>
      
      <para>A thread is always in one of five possible states—<emphasis>runnable</emphasis>, <emphasis>sleeping</emphasis>, <emphasis>aborting</emphasis>, <emphasis>terminated normally</emphasis>, or <emphasis>terminated exceptionally</emphasis>—which may be queried as shown below.</para>

      <informaltable>
	<thead>
	  <tr>
	    <th>State</th>
	    <th><function>Thread#status</function></th>
	    <th><function>Thread#alive?</function></th>
	    <th><function>Thread#stop?</function></th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td>Runnable</td>
	    <td><literal>"run"</literal></td>
	    <td><literal>true</literal></td>
	    <td><literal>false</literal></td>
	  </tr>
	  <tr>
	    <td>Sleeping</td>
	    <td><literal>"sleep"</literal></td>
	    <td><literal>true</literal></td>
	    <td><literal>true</literal></td>
	  </tr>
	  <tr>
	    <td>Aborting</td>
	    <td><literal>"aborting"</literal></td>
	    <td><literal>false</literal></td>
	    <td><literal>true</literal></td>
	  </tr>
	  <tr>
	    <td>Terminated normally</td>
	    <td><literal>false</literal></td>
	    <td><literal>false</literal></td>
	    <td><literal>true</literal></td>
	  </tr>
	  <tr>
	    <td>Terminated exceptionally</td>
	    <td><literal>nil</literal></td>
	    <td><literal>false</literal></td>
	    <td><literal>true</literal></td>
	  </tr>
	</tbody>
      </informaltable>

      <para>When a thread is created it is <emphasis>runnable</emphasis>. It enters the <emphasis>sleeping</emphasis> state while <function>Kernel.sleep</function><footnote><para>If <function>Kernel.sleep</function> is called without an argument, it blocks until the thread is awoken or terminated.</para></footnote> or an <literal>IO</literal> method is blocking, after which it returns to <emphasis>runnable</emphasis>. A thread that calls <function>Thread.stop</function> also switches to <emphasis>sleeping</emphasis>, where it remains until awoken, then schedules execution of another thread. A <emphasis>sleeping</emphasis> thread may be made <emphasis>runnable</emphasis> with <function>Thread#wakeup</function> or <function>Thread#run</function>, unless it is sleeping due to blocking I/O. <function>Thread#run</function> then invokes the thread scheduler, possibly causing the thread to begin running; <function>Thread#wakeup</function> does not.</para> 

      <para>A thread that raises an exception, which it does not subsequently rescue, enters the <emphasis>terminated exceptionally</emphasis> state. <remark>Link to Thread#raise</remark> Otherwise, after a thread has executed its final statement its status is <replaceable>terminated normally</replaceable>. This is also the case when the thread is terminated with <function>Thread#kill</function>—which is aliased to <function>Thread#exit</function> and <function>Thread#terminate</function>—however while the thread is exiting its status will be <emphasis>aborting</emphasis>. <function>Thread#kill!</function>, which is aliased to <function>Thread#terminate!</function> and <function>Thread#exit!</function>, behaves like <function>Thread#kill</function> except it bypasses any <literal>ensure</literal> clauses in the receiver.</para>
    </sect2>

    <sect2 xml:id="con.thread-variables">
      <title>Variables</title>

      <para>Threads are created with blocks, so standard scoping rules apply: they may access any variable in the scope of this block, and local variables that they define are not shared with other threads. An implication is that if a thread accesses a variable defined in its parent scope, it will share this variable with all other threads created in the same scope. We have already seen how this behaviour can be avoided by providing arguments to <function>Thread.new</function> to create block-local variables.</para>

      <para>Some of the predefined global variables are <firstterm>thread-local</firstterm>: each thread has its own, private copy. <remark>Table of thread-local globals?</remark> Only Ruby can create thread-local global variables, but any thread may create <firstterm>thread keys</firstterm> <biblioref units="pages" begin="432" end="435" linkend="bib.black09"/>: thread-local variables, accessible to other threads via a <literal>Hash</literal>-like interface. <function>Thread#[<replaceable>key</replaceable>]=<replaceable>value</replaceable></function> creates a thread key named <replaceable>key</replaceable>—which must be a <literal>String</literal> or <literal>Symbol</literal>—to <replaceable>value</replaceable>. <function>Thread#[<replaceable>key</replaceable>]</function> returns the value associated with <replaceable>key</replaceable>, or <literal>nil</literal> if there is none. The <function>Thread#key?(<replaceable>key</replaceable>)</function> predicate returns <literal>true</literal> if the receiver has defined a thread key named <replaceable>key</replaceable>; <literal>false</literal>, otherwise. The names of all keys defined by a given thread are returned by <function>Thread#keys</function> as an <literal>Array</literal> of <literal>Symbol</literal>s.</para>     
    </sect2>

    <sect2 xml:id="con.thread-join">
      <title>Joining</title>

      <para>Ruby runs until the main thread terminates, even if additional threads were created and are still running. To wait for a specific thread to terminate, blocking until it does so, <function>Thread#value</function> may be used. It returns the value of the last statement executed by the thread. <function>Thread#join(<replaceable>seconds</replaceable>)</function> also blocks until its receiver terminates, but if more than <replaceable>seconds</replaceable> seconds elapse it gives up and returns <literal>nil</literal>; on success it returns the receiver. If <replaceable>seconds</replaceable> is omitted, there is no time limit.</para>
    </sect2>

    <sect2 xml:id="con.thread-exceptions">
      <title>Exceptions</title>

      <para>When an unhandled exception occurs in the main thread, Ruby prints the backtrace then exits. When another thread raises, but does not handle, an exception, its behaviour depends on an <emphasis>abort on exception</emphasis> flag.</para>

      <para>If <emphasis>abort on exception</emphasis> is <literal>false</literal>, as it is by default, an unhandled exception causes a thread to terminate silently; when waited on—with either <function>Thread#join</function> or <function>Thread#value</function>—the exception is raised in the calling thread. If <emphasis>abort on exception</emphasis> is <literal>true</literal>, all threads behave like the main thread when encountering unhandled exceptions: they print its backtrace then cause the interpreter to exit.</para>

      <para>The flag may be set globally with <function>Thread.abort_on_exception=</function> or per-thread with <function>Thread#abort_on_exception=</function>. These values may be retrieved with <function>Thread.abort_on_exception</function> and <function>Thread#abort_on_exception</function>, respectively. If <literal>$DEBUG</literal> is <literal>true</literal>—as it is when the interpreter is given the <option>-d</option> flag—threads behave as if <function>Thread.abort_on_exception</function> is also <literal>true</literal>.</para>
    </sect2>

    <sect2 xml:id="con.thread-scheduling">
      <title>Scheduling</title>

      <para>Threads initially have a priority of zero, with a higher priority implying more favourable scheduling. <function>Thread#priority</function> returns the receiver’s priority as an <literal>Integer</literal>; <function>Thread#priority=(<replaceable>priority</replaceable>)</function> sets the receiver’s priority to <replaceable>priority</replaceable>. However, priorities are merely hints to the thread scheduler: they may be entirely disregarded, as they are under Linux for non-privileged users.</para>

      <para>There are, broadly, two approaches for allocating CPU cycles to threads: cooperative multitasking and preemptive multitasking. In the former, a context switch occurs when a thread explicitly yields control back to the CPU, or performs a blocking operation such as I/O. In the latter, each thread is run only for a certain amount of time before being interrupted so that another thread may run instead. Under a cooperative approach, a thread which neither yields nor performs blocking operations may <firstterm>starve</firstterm> the process’s other threads from executing, monopolising the CPU. As a workaround, compute-bound threads may use <function>Thread.pass</function> to explicitly yield to the thread scheduler.</para>
    </sect2>  
  </sect1>
</chapter>
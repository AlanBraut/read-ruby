<?xml version="1.0" encoding="utf-8"?>
<chapter version="5.0" xml:id="prc.processes" xml:lang="en" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Processes</title>

  <para>A <firstterm>process</firstterm> is an instance of a computer program. We use the term <firstterm>current process</firstterm> to refer to an instance of Ruby running your program. The semantics of processes are partly platform-specific. Ruby abstracts these differences where possible, but for the best experience use a UNIX-based system such as <emphasis>GNU/Linux</emphasis> or <emphasis>Mac OS</emphasis>.</para>

  <sect1 xml:id="prc.executing">
    <title>Executing &amp; Forking</title>

    <para>A process is often created by <firstterm>executing</firstterm> a program: loading a specific binary program into memory. The program is identified by a filename which is either absolute or relative to a directory in the user’s path<footnote><para>That is, his <emphasis>search path</emphasis>: a list of directories which contain program files. On UNIX-based systems, this is the value of the environment variable <envar>$PATH</envar>.</para></footnote> . Broadly, Ruby provides four approaches for executing programs, which are summarised in the table below. Alternatively, <function>Kernel.fork</function> creates a new process by duplicating the current process. The remainder of this section explains these methods in detail.</para>

    <informaltable>
      <thead>
	<tr>
	  <th>Method</th>
	  <th>Returns</th>
	  <th>Blocks Until Process Exits?</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><function>Kernel.`</function></td>
	  <td>The process’s output</td>
	  <td>Yes</td>
	</tr>
	<tr>
	  <td><function>Kernel.exec</function></td>
	  <td>Nothing on success (replaces the current process with the new process)</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td><function>Kernel.system</function></td>
	  <td>Whether the process executed successfully</td>
	  <td>Yes</td>
	</tr>
	<tr>
	  <td><function>Kernel.spawn</function></td>
	  <td>The process’s PID</td>
	  <td>No</td>
	</tr>
      </tbody>
    </informaltable>

    <sect2 xml:id="prc.backticks">
      <title>Backticks</title>

      <para>A double-quoted string delimited with grave accents (<literal>U＋0060</literal>) characters, or “backticks”, executes its contents as an operating system command and returns the output. This is achieved by the <function>Kernel.`</function> method, which can be redefined to alter these semantics. Alternative delimiters can be used with the corresponding <literal>%x<replaceable>delimiter</replaceable>…<replaceable>delimiter</replaceable></literal> construct, which follows the same rules as <link linkend="str.double-quoted-q">%Q</link>.</para>
      
      <example xml:id="ex.backticks">
	<title>Using backticks to execute commands and retrieve the output</title>

	<programlisting><xi:include href="examples/backticks.rb" parse="text"/></programlisting>
      </example>
    </sect2>

    <sect2 xml:id="prc.exec">
      <title><function>Kernel.exec</function></title>

      <para><function>Kernel.exec</function> replaces the current process image with a new process image. Accordingly, it will not return if successful; if it fails, <literal>SystemCallError</literal> is raised. If a single argument is provided, it is a <literal>String</literal> containing a command line that should be executed by the shell—<literal>/bin/sh</literal> on Unix-like systems; the value of <literal>ENV['RUBYSHELL']</literal> or <literal>ENV['COMPSEC']</literal> otherwise—so is subject to shell expansion. </para>

      <example xml:id="ex.kernel-exec-1">
	<title>Executing commands with <function>Kernel.exec</function> and the shell</title>

	<programlisting><xi:include href="examples/kernel-exec-1.rb" parse="text"/></programlisting>
      </example>

      <para>If multiple <literal>String</literal> arguments are given, the first is the name of a command in the user’s path, and the remainder are the command’s arguments. The command may be either a binary, or an executable script with a shebang. It is executed by a system call from the <literal>exec(3)</literal> family<footnote><para>A consequence is that open file descriptors are passed to the new process. To avoid this, use <link linkend="io.close"><function>IO#close_on_exec=</function></link> or the <literal>:close_others</literal> key in the <link linkend="prc.options-hash">options <literal>Hash</literal></link></para></footnote>, so neither the command or arguments are subject to shell expansion. If the command name is given as an <literal>Array</literal> of the form <literal>[<replaceable>name</replaceable>, <replaceable>argv0</replaceable>]</literal>, <replaceable>name</replaceable> is the command’s name, and <replaceable>argv0</replaceable> is the filename associated with <replaceable>name</replaceable><footnote><para>Changing <replaceable>argv0</replaceable> is useful because some programs, such as <literal>ps(1)</literal> and <literal>top(1)</literal>, will use it in place of the command name, while others, such as <literal>csh(1)</literal>, treat it specially.</para></footnote>.</para>

      <example xml:id="ex.kernel-exec-2">
	<title>Executing commands with <function>Kernel.exec</function></title>

	<programlisting><xi:include href="examples/kernel-exec-2.rb" parse="text"/></programlisting>
      </example>

      <para>In either of these forms, the new process’s environment may be modified by providing a <literal>Hash</literal> of environment variables before the first argument. An environment variable is created for each <literal>String</literal> key, or unset if the corresponding value is <literal>nil</literal>. An <link linkend="prc.options-hash">options <literal>Hash</literal></link> may be supplied for the final argument.</para>

      <example xml:id="ex.kernel-exec-3">
	<title>Executing commands in a given environment with <function>Kernel.exec</function></title>

	<programlisting><xi:include href="examples/kernel-exec-3.rb" parse="text"/></programlisting>
      </example>
    </sect2>

    <sect2 xml:id="prc.system">
      <title><function>Kernel.system</function></title>

      <para><function>Kernel.system</function> interprets its arguments in the same way as <function>exec</function>, but executes the command in a subshell then returns. Its return value is <literal>true</literal> if the command executed successfully, <literal>false</literal> if the command’s exit status was non-zero, or <literal>nil</literal> if the command failed to execute.</para>

      <example xml:id="ex.kernel-system">
	<title>Executing commands with <function>Kernel.system</function></title>

	<programlisting><xi:include href="examples/kernel-system.rb" parse="text"/></programlisting>
      </example>
    </sect2>

    <sect2 xml:id="prc.spawn">
      <title><function>Kernel.spawn</function></title>

      <para><function>Kernel.spawn</function>, and its alias <function>Process.spawn</function>, also interpret their arguments in the same way as <function>exec</function>, but execute the command in a subshell then return without waiting for the command to complete. Their return value is an <literal>Integer</literal> holding the <acronym>PID</acronym> of the new process.</para>

      <example xml:id="ex.kernel-spawn">
	<title>Executing commands with <function>Kernel.spawn</function></title>

	<programlisting><xi:include href="examples/kernel-spawn.rb" parse="text"/></programlisting>
      </example>
    </sect2>

    <sect2 xml:id="prc.fork">
      <title><function>Kernel.fork</function></title>

    <para>On UNIX-based systems<footnote><para>Typically, forking is how UNIX executes all programs: first it forks, then in the new process it uses the <function>execve(2)</function> system call—provided by Ruby as <function>Kernel.exec</function>—to replace this process with the result of executing the program.</para></footnote>, a new process may also be created by duplicating<footnote><para>The new process is not <emphasis>identical</emphasis> to the current process—an obvious difference is that the new process has a different PID—but the differences are minor; for details, consult your system manuals for <function>fork(2)</function>.</para></footnote>—or <emphasis>forking</emphasis>—the current process. If this is successful, both processes continue to run as normal.</para>

      <para>Ruby implements forking with <function>Kernel.fork</function>, and its alias <function>Process.fork</function>. These methods raise a <literal>NotImplementedError</literal> on platforms such as Microsoft Windows that don’t implement the <function>fork(2)</function> system call. If given a block, that block is run in the subprocess, then the subprocess terminates with an exit status of <literal>0</literal>.</para>

      <example xml:id="ex.kernel-fork">
	<title>Executing commands with <function>Kernel.fork</function> given a block</title>

	<programlisting><xi:include href="examples/kernel-fork.rb" parse="text"/></programlisting>
      </example>
 
      <para>If the block is omitted, <function>fork</function> returns the PID of the child to the current process, and <literal>nil</literal> in the child process.</para>

      <example xml:id="ex.kernel-fork-2">
	<title>Executing commands with <function>Kernel.fork</function></title>

	<programlisting><xi:include href="examples/kernel-fork-2.rb" parse="text"/></programlisting>
      </example>

      <para>In both examples above, the child process may become a <emphasis>zombie</emphasis>; see <xref linkend="prc.status"/> for how to avoid this.</para>
    </sect2>

    <sect2 xml:id="prc.popen">
      <title><function>IO.popen</function></title>

      <para><function>IO.popen(<replaceable>cmd</replaceable>, <replaceable>mode</replaceable>='r')</function> executes a command, <replaceable>cmd</replaceable>, as a subprocess, opening a pipe to this subprocess’s standard input and output streams, which it returns as an <literal>IO</literal> object. The default <link linkend="io.access-mode">access mode</link> of the pipe is <literal>"r"</literal>, but this may be overridden with the <replaceable>mode</replaceable> argument.</para>

      <para>If <replaceable>cmd</replaceable> is a <literal>String</literal> it names a command in the user’s path, and is subject to shell expansion. If it is a <literal>"-"</literal>, and the platform supports forking, the current process forks: an <literal>IO</literal> pipe connected to the child’s standard input and output streams is returned to the parent; <literal>nil</literal> is returned to the child.</para>

      <para>Otherwise, <replaceable>cmd</replaceable> is an <literal>Array</literal> of <literal>String</literal>s, the first of which specifies the command name; the remainder, its arguments. The shell is bypassed, so none of these <literal>String</literal>s are subject to shell expansion. If the first element of this <literal>Array</literal> is a <literal>Hash</literal>, it specifies the names and corresponding values of environment variables that should be set in the subprocess. An <link linkend="prc.options-hash">options <literal>Hash</literal></link> may be supplied as the last element of this <literal>Array</literal>.</para>

      <para>If a block is supplied, Ruby’s end of the pipe is passed to it as a parameter, then closed when the block exits. <literal>$?</literal> is set to the exit status of the subprocess, and the value of the block is returned.</para>

      <para>When a block is supplied along with a <replaceable>cmd</replaceable> of <literal>"-"</literal>, Ruby forks, running the block in both processes. In the parent process the block is passed an <literal>IO</literal> pipe connected to the child’s standard input and output streams; in the child process the block is passed <literal>nil</literal>.</para>

      <para><literal>Kernel.open("|<replaceable>cmd</replaceable>", <replaceable>mode</replaceable>='r')</literal> behaves like <literal>IO.popen(<replaceable>cmd</replaceable>, <replaceable>mode</replaceable>='r')</literal>, when <replaceable>cmd</replaceable> is a <literal>String</literal>. Likewise, <literal>Kernel.open("|-", <replaceable>mode</replaceable>='r')</literal> behaves like <literal>IO.popen("-", <replaceable>mode</replaceable>='r')</literal></para>

      <para>In all of these cases, the process ID of the subprocess may be retrieved with <function>IO#pid</function>.</para>
    </sect2>

    <sect2 xml:id="prc.options-hash">
      <title>Options <literal>Hash</literal></title>

      <para><function>exec</function>, <function>system</function>, <function>spawn</function>, and <function>IO.popen</function> all accept an options <literal>Hash</literal> as their last argument. It may contain any of the following keys.</para>

      <informaltable>
	<thead>
	  <tr>
	    <th>Key</th>
	    <th>Default Value</th>
	    <th>Description</th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td><literal>:unsetenv_others</literal></td>
	    <td><literal>false</literal></td>
	    <td>If <literal>true</literal> clears the environment variables not named in the <replaceable>env</replaceable> <literal>Hash</literal></td>
	  </tr>
	  <tr>
	    <td><literal>:pgroup</literal></td>
	    <td><literal>nil</literal></td>
	    <td>If <literal>true</literal> or <literal>0</literal>, make a new process group; if an <literal>Integer</literal> join the process group with that ID; if <literal>nil</literal>, don’t change the process group.</td>
	  </tr>
	  <tr>
	    <td><literal>:rlimit_<replaceable>resource</replaceable></literal></td>
	    <td><literal>Process.getrlimit(<replaceable>resource</replaceable>)</literal></td>
	    <td>Where <replaceable>resource</replaceable> is a resource name recognised by <function>Process.setrlimit</function>/<function>Process.getrlimit</function>, sets that resource to the given value. If the value is an <literal>Array</literal>, its first element is the new soft limit, and its second is the new hard limit.</td>
	  </tr>  
	  <tr>
	    <td><literal>:chdir</literal></td>
	    <td><literal>Dir.pwd</literal></td>
	    <td>The value is a <literal>String</literal> naming the directory to change to before invoking the command.</td>
	  </tr>  
	  <tr>
	    <td><literal>:umask</literal></td>
	    <td><literal>File.umask</literal></td>
	    <td>The value is an <literal>Integer</literal> specifying the new value of the process’s file creation mask, or <firstterm>umask</firstterm>.</td>
	  </tr>  
	  <tr>
	    <td><literal>:in</literal></td>
	    <td><literal>STDIN</literal></td>
	    <td>Redirects the standard input stream to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>:out</literal></td>
	    <td><literal>STDOUT</literal></td>
	    <td>Redirects the standard output stream to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>:err</literal></td>
	    <td><literal>STDERR</literal></td>
	    <td>Redirects the standard error stream to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>Integer</literal></td>
	    <td>N/A</td>
	    <td>When the key is an <literal>Integer</literal>, it is interpreted as a file descriptor to redirect to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>IO</literal></td>
	    <td>N/A</td>
	    <td>When the key is an <literal>IO</literal> object, its file descriptor is redirected to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>Array</literal></td>
	    <td>N/A</td>
	    <td>Each element is a file descriptor specified in any of the formats listed above. They are all redirected to the given stream.</td>
	  </tr>  
	  <tr>
	    <td><literal>:close_others</literal></td>
	    <td><literal>true</literal> for <function>system</function> and <function>exec</function>; <literal>false</literal> otherwise.</td>
	    <td>If <literal>true</literal>, the process does not inherit its parent’s file descriptors; otherwise it does.</td>
	  </tr>  
	</tbody>
      </informaltable>
      
      <para>The options that redirect an I/O stream may be given a value in any of the following formats.</para>

      <variablelist spacing="compact">
	<varlistentry>
	  <term><literal>:in</literal></term>
	  <listitem>
	    <para>Standard input</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>:out</literal></term>
	  <listitem>
	    <para>Standard output</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>:err</literal></term>
	  <listitem>
	    <para>Standard error</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>String</literal></term>
	  <listitem>
	    <para>File descriptor of <literal>open(<replaceable>string</replaceable>, ?w)</literal></para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>[String]</literal></term>
	  <listitem>
	    <para>As above, but with a mode of <literal>File::RDONLY</literal></para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>[String, Integer]</literal></term>
	  <listitem>
	    <para>As above, but with the open mode given by the second argument</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>[String, Integer, Integer]</literal></term>
	  <listitem>
	    <para>As above, but with the open permissions given by the third argument</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>:close</literal></term>
	  <listitem>
	    <para>Close this file descriptor</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 xml:id="prc.terminate">
    <title>Terminating</title>

    <para>The current process may be terminated with <function>Kernel.exit(<replaceable>status</replaceable>=1)</function>. If <function>exit</function> is used within a <literal>begin</literal> block, it raises a <literal>SystemExit</literal> exception which may be caught by a corresponding <literal>rescue</literal> clause. Otherwise, it terminates the process with <literal>exit(2)</literal>, using <replaceable>status</replaceable> as the exit status. If  <replaceable>status</replaceable> is <literal>true</literal>, it has the value <literal>0</literal>; if <literal>false</literal> or omitted, it has the value <literal>1</literal>. Prior to termination, <function>exit</function> runs any <link linkend="flo.at_exit"><function>at_exit</function></link> functions or object finalisers. <function>Kernel.exit!</function> is identical to <function>exit</function> except it bypasses both <function>at_exit</function> functions and finalisers.</para>

    <para><function>Kernel.abort(<replaceable>msg</replaceable>=nil)</function> displays the optional message on the standard error stream then terminates the current process. It is equivalent to <literal>$stderr.puts <replaceable>msg</replaceable></literal>—if <replaceable>msg</replaceable> is given—then <literal>exit(false)</literal>.</para>

    <remark>Xref Process.kill when it is written</remark>
  </sect1>

  <sect1 xml:id="prc.environment">
    <title>Environment</title>

    <para><literal>ENV</literal> provides <literal>Hash</literal>-like access to the current process’s environment variables. <function>ENV[<replaceable>var</replaceable>]</function> retrieves the value of the environment variable named <replaceable>var</replaceable>; <function>ENV[<replaceable>var</replaceable>]=<replaceable>value</replaceable></function> sets its value to <replaceable>value</replaceable>. In both cases <replaceable>var</replaceable> is a <literal>String</literal>. If <replaceable>value</replaceable> is <literal>nil</literal>, the environment variable is deleted.</para>
  </sect1>

  <sect1 xml:id="prc.status">
    <title>Status</title>

    <para>POSIX systems record the status of stopped and terminated processes as a 16-bit integer. The lower 8 bits are the process’s <firstterm>exit status</firstterm>, i.e. the value returned to its parent; the higher bits are platform-dependent. The status is encapsulated by a <literal>Process::Status</literal> object.</para>

    <para><function>Kernel.`</function> and <function>Kernel.system</function> set the global variable <literal>$?</literal> to the <literal>Process::Status</literal> object corresponding to the command they executed. Methods such as <function>exec</function>, <function>fork</function>, and <function>spawn</function>, cannot set <function>$?</function> because they return before the command has terminated. To retrieve the <literal>Process::Status</literal> object associated with such processes, we must first <firstterm>wait</firstterm> for them to exit.</para>

    <sect2 xml:id="prc.wait">
      <title>Waiting</title>

      <para><function>Process.wait</function> waits for <emphasis>any</emphasis> child process to exit, then returns its PID. <literal>$?</literal> is set to the corresponding <literal>Process::Status</literal> object. <function>Process.wait2</function> also waits for any child process to exit, but returns an <literal>Array</literal> comprising its PID and <literal>Process::Status</literal> object. Both methods raise a <literal>SystemError</literal> if there aren’t any child processes.</para>

      <para><function>Process.waitall</function> waits for <emphasis>all</emphasis> child processes to exit, then returns an <literal>Array</literal> of <literal>[<replaceable>pid</replaceable>, <replaceable>status</replaceable>]</literal> pairs, where <replaceable>pid</replaceable> is the process’s PID, and <replaceable>status</replaceable> its <literal>Process:Status</literal> object. If there are no child processes, an empty <literal>Array</literal> is returned.</para>

      <para><function>Process.waitpid(<replaceable>pid</replaceable>, <replaceable>flags</replaceable>=0)</function> waits on the child process described by <replaceable>pid</replaceable> to exit, then returns its PID. <function>Process.waitpid2(<replaceable>pid</replaceable>, <replaceable>flags</replaceable>=0)</function> does likewise, but returns an <literal>Array</literal> comprising the PID and corresponding <literal>Process::Status</literal> object. Both methods interpret <replaceable>pid</replaceable> as follows:</para>

      <informaltable>
	<thead>
	  <tr>
	    <th><replaceable>pid</replaceable></th>
	    <th>Semantics</th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td>&lt; −1</td>
	    <td>Any child whose process group ID equals the absolute value of <replaceable>pid</replaceable></td>
	  </tr>
	  <tr>
	    <td>−1</td>
	    <td>Any child</td>
	  </tr>
	  <tr>
	    <td>0</td>
	    <td>Any child whose process group ID equals that of the current process.</td>
	  </tr>
	  <tr>
	    <td>&gt; 0</td>
	    <td>The child with the PID of <replaceable>pid</replaceable>.</td>
	  </tr>
	</tbody>
      </informaltable>

      <para><replaceable>flags</replaceable> is either 0, or a logical OR of the following constants. Some platforms may not support these flags.</para>

      <variablelist spacing="compact">
	<varlistentry>
	  <term><literal>Process::WNOHANG</literal></term>
	  <listitem>
	    <para>The method will not block if status is not immediately available for one of the specified child processes.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>Process::WUNTRACED</literal></term>
	  <listitem>
	    <para>The status of any specified child processes that are stopped, but whose status has not been reported since they stopped, will also be reported.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>A child process that is not waited on may become a <firstterm>zombie</firstterm>—remaining in the process table in case somebody wants to retrieve its status. <function>Process.detach(<replaceable>pid</replaceable>)</function> offers a solution by running a background thread to monitor the status of <replaceable>pid</replaceable>, then reap it—i.e. remove the process from the process table—when terminated. It returns the <literal>Thread</literal> object.</para>
    </sect2>

    <sect2 xml:id="prc.process-status">
      <title><literal>Process::Status</literal></title>

      <para>If a process has exited, <function>Process::Status#exitstatus</function> returns its exit status as an <literal>Integer</literal> byte. If it exited because of a signal, <function>Process::Status#termsig</function> returns the signal number; otherwise it returns <literal>nil</literal>. If the process was stopped by a signal, <function>Process::Status#stopsig</function> returns the signal number; otherwise it returns <literal>nil</literal>. <function>Process::Status#pid</function> returns the PID of the corresponding process. In addition, the following predicates are defined:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>Process::Status#coredump?</literal></term>
	  <listitem>
	    <para>Returns <literal>true</literal> if the process generated a coredump when it terminated; <literal>false</literal> otherwise.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>Process::Status#exited?</literal></term>
	  <listitem>
	    <para>Returns <literal>true</literal> if the process terminated normally; <literal>false</literal> otherwise.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>Process::Status#signaled?</literal></term>
	  <listitem>
	    <para>Returns <literal>true</literal> if the process terminated due to the receipt of a signal which was not caught; <literal>false</literal> otherwise.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>Process::Status#stopped?</literal></term>
	  <listitem>
	    <para>Returns <literal>true</literal> if the process is currently stopped; <literal>false</literal> otherwise. Only meaningful if the <literal>Process::WUNTRACED</literal> flag was given to <function>waitpid</function> or <function>waitpid2</function>.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>Process::Status#success?</literal></term>
	  <listitem>
	    <para>Returns <literal>true</literal> if the process exited normally, <literal>false</literal> if it exited abnormally, and <literal>nil</literal> if it hasn’t exited.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

	
      <para>A <literal>Process::Status</literal> object may also be treated as a collection of bits: <function>Process::Status#to_i</function> returns the status as an <literal>Integer</literal>; <function>Process::Status#&amp;(<replaceable>n</replaceable>)</function> performs a logical AND of the bits with <replaceable>n</replaceable>; and <function>Process::Status#&gt;&gt;(<replaceable>n</replaceable>)</function> shifts the bits right by <replaceable>n</replaceable> places.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="prc.daemons">
    <title>Daemons</title>

    <para>A <firstterm>daemon</firstterm> is a process that runs in the background—rather than under the direct control of a user—to provide a service for other programs. <function>Process.daemon(<replaceable>keep_dir</replaceable>=false, <replaceable>redirect</replaceable>=false)</function> detaches the current process from its controlling terminal, then runs it in the background. The process’s working directory is set to <filename>/</filename> unless <replaceable>keep_dir</replaceable> is <literal>true</literal>. If <replaceable>redirect</replaceable> is <literal>true</literal>, the process’s standard input, output, and error streams are all redirected to <filename>/dev/null</filename>. If the process is successfully daemonised, this method returns <literal>0</literal>; otherwise an <literal>Errno</literal> exception is raised.</para>

    <para>This method uses the <function>daemon(3)</function> syscall if its available, or forks then calls <function>Process.setssid</function>. On platforms with neither option available, a <literal>NotImplementedError</literal> is raised.</para>
  </sect1>

  <sect1 xml:id="prc.priority">
    <title>Scheduling Priorities</title>

    <para>On platforms that support the <function>getpriority(2)</function> and <function>setpriority(2)</function> system calls, the scheduling priority associated with a process, process group, or user, may be obtained and set. A priority is an <literal>Integer</literal> between −20 and 19, which defaults to 0. Lower priorities cause more favourable scheduling, but only the superuser may decrease a priority.</para>

    <para><function>Process.getpriority(<replaceable>which</replaceable>, <replaceable>who</replaceable>)</function> returns the most favourable priority associated with the specified processes. <function>Process.setpriority(<replaceable>which</replaceable>, <replaceable>who</replaceable>, <replaceable>prio</replaceable>)</function> sets the priorities of all the specified processes to <replaceable>prio</replaceable>, returning <literal>0</literal>. <replaceable>which</replaceable> is a constant describing the type of priority, <replaceable>who</replaceable> is an <literal>Integer</literal> identifying an instance of that type, and <replaceable>prio</replaceable> is an <literal>Integer</literal>. If <replaceable>who</replaceable> is <literal>0</literal> it refers to the current instance of that type, as shown below.</para>

    <informaltable>
      <thead>
	<tr>
	  <th><replaceable>which</replaceable></th>
	  <th><replaceable>who</replaceable></th>
	  <th><replaceable>who</replaceable> = 0</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><literal>Process::PRIO_PROCESS</literal> (process)</td>
	  <td>Process ID</td>
	  <td>Calling process</td>
	</tr>
	<tr>
	  <td><literal>Process::PRIO_PGRP</literal> (process group)</td>
	  <td>Process group ID</td>
	  <td>Process group of calling process</td>
	</tr>
	<tr>
	  <td><literal>Process::PRIO_USER</literal> (user)</td>
	  <td>User ID</td>
	  <td>Real user ID of calling process</td>
	</tr>
      </tbody>
    </informaltable>
  </sect1>

  <sect1 xml:id="prc.limit">
    <title>Resource Limits</title>

    <para>On platforms that support the <function>getrlimit(2)</function> and <function>setrlimit(2)</function> system calls, <function>Process.getrlimit(<replaceable>resource</replaceable>)</function> and <function>Process.setrlimit(<replaceable>resource</replaceable>, <replaceable>soft</replaceable>, <replaceable>hard</replaceable>)</function> may be used to obtain and set, respectively, resource limits.</para>

    <para>The resources supported by Ruby are listed below. Those supported by your platform have a corresponding constant defined named <literal>Process::RLIMIT_<replaceable>name</replaceable></literal>, where <replaceable>name</replaceable> is the resource’s name. Both <function>Process.setrlimit</function> and <function>Process.getrlimit</function> accept <replaceable>resource</replaceable> as a resource name—given as a <literal>String</literal> or <literal>Symbol</literal>—or the value of the corresponding constant.
</para>

    <informaltable>
      <thead>
	<tr>
	  <th>Name</th>
	  <th>Platform</th>
	  <th>Description</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><literal>AS</literal></td>
	  <td>SUSv3, NetBSD, FreeBSD, OpenBSD</td>
	  <td>Limits the maximum size of the process’s address space, in bytes. If the stack expands beyond this limit, the process is sent the <literal>SIGSEGV</literal> signal.</td>
	</tr>
	<tr>
	  <td><literal>CORE</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum size of core files, in bytes. If <literal>0</literal>, they are never created; otherwise, they’re truncated to this size.</td>
	</tr>
	<tr>
	  <td><literal>CPU</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum CPU time the process can consume, in seconds. If a process overruns it is sent the <literal>SIGXCPU</literal> signal.</td>
	</tr>
	<tr>
	  <td><literal>DATA</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum size of process’s data segment and heap, in bytes.</td>
	</tr>
	<tr>
	  <td><literal>FSIZE</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum file size a process may create, in bytes. If the process expands a file beyond this limit, it is sent the <literal>SIGXFSZ</literal> signal.</td>
	</tr>
	<tr>
	  <td><literal>MEMLOCK</literal></td>
	  <td>BSD, GNU/Linux</td>
	  <td>Limits the maximum number of bytes a process<footnote><para>Processes with the <literal>CAP_SYS_IPC</literal> capability, effectively root processes, are exempt.</para></footnote> can lock into memory.</td>
	</tr>
	<tr>
	  <td><literal>MSGQUEUE</literal></td>
	  <td>GNU/Linux</td>
	  <td>Limits the maximum number of bytes allocated for <acronym>POSIX</acronym> message queues.</td>
	</tr>
	<tr>
	  <td><literal>NICE</literal></td>
	  <td>GNU/Linux</td>
	  <td>Limits the maximum number<footnote><para>Since a <emphasis>nice</emphasis> value, <replaceable>n</replaceable>, may be negative, this value is interpreted as 20 − <replaceable>n</replaceable>.</para></footnote> to which a process can lower its <emphasis>nice</emphasis> value.</td>
	</tr>
	<tr>
	  <td><literal>NOFILE</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum number, less 1, of file descriptors the process may have open.</td>
	</tr>
	<tr>
	  <td><literal>NPROC</literal></td>
	  <td>BSD, GNU/Linux</td>
	  <td>Limits the maximum number of processes the user may have running at any given time.</td>
	</tr>
	<tr>
	  <td><literal>RSS</literal></td>
	  <td>BSD, GNU/Linux ~&lt;= 2.4</td>
	  <td>Limits the resident set size (maximum number of pages the process may have resident in memory).</td>
	</tr>
	<tr>
	  <td><literal>RTPRIO</literal></td>
	  <td>GNU/Linux</td>
	  <td>Limits the maximum real-time priority level a process<footnote><para>Processes with the <literal>CAP_SYS_NICE</literal> capability, effectively root processes, are exempt.</para></footnote> may request.</td>
	</tr>
	<tr>
	  <td><literal>RTTIME</literal></td>
	  <td>GNU/Linux</td>
	  <td>Limits the CPU time a process scheduled under a real-time policy may consume without making a blocking system call, in microseconds.</td>
	</tr>
	<tr>
	  <td><literal>SBSIZE</literal></td>
	  <td>NetBSD, FreeBSD</td>
	  <td>Limits the maximum size of socket buffer usage for this user, in bytes.</td> 
	</tr>
	<tr>
	  <td><literal>SIGPENDING</literal></td>
	  <td>GNU/Linux</td>
	  <td>Limits the maximum number of signals that may be queued for this user.</td>
	</tr>
	<tr>
	  <td><literal>STACK</literal></td>
	  <td>SUSv3</td>
	  <td>Limits the maximum size of a process’s stack, in bytes. If a process’s stack grows beyond this point, it is sent a <literal>SIGSEGV</literal> signal.</td>
	</tr>
      </tbody>
    </informaltable>

    <para>A resource has both a <firstterm>soft limit</firstterm> and a <firstterm>hard limit</firstterm>. The hard limit is a ceiling on the soft limit, so may only be set by privileged processes. Either limit may be set to <literal>0</literal> or <literal>:INFINITY</literal>/<literal>Process::RLIM_INFINITY</literal>, which disable the resource and remove all limits on the resource, respectively. A process inherits the limits of its parent.</para>

    <para><function>Process.getrlimit</function> returns an <literal>Array</literal> whose first element is the soft limit of <replaceable>resource</replaceable>, and its last, the hard limit of <replaceable>resource</replaceable>. <function>Process.setrlimit</function> sets the soft limit of <replaceable>resource</replaceable> to <replaceable>soft</replaceable>, and, if permitted, the hard limit of <replaceable>resource</replaceable> to <replaceable>hard</replaceable>; if <replaceable>hard</replaceable> is omitted, it has the value <replaceable>soft</replaceable>.</para>
  </sect1>

  <sect1 xml:id="prc.ids">
    <title>IDs</title>

    <para>On UNIX-like systems, users, processes, and groups are associated with various IDs. In order to explain how these can be manipulated via methods of the <literal>Process</literal> module, some background theory is necessary…</para>
 
  <para>When a process is invoked it is allocated a process ID (hereafter: <acronym>PID</acronym>) by which it can be uniquely identified. The PID of the current process is returned by <function>Process.pid</function>. Every process, other than <emphasis>init</emphasis>, has a <firstterm>parent</firstterm>: a process which spawned it. The parent’s PID is returned by <function>Process.ppid</function>. On Windows, this always returns <literal>0</literal>.</para>

    <para>A user, identified by a user ID (hereafter: <acronym>UID</acronym>), is a member of at least one group, each of which is identified by a group ID (hereafter: GID). When a user is a member of multiple groups, one is designated his <firstterm>primary group</firstterm><footnote><para>This is the group listed alongside a user’s username in <filename>/etc/passwd</filename>.</para></footnote>, and the remainder his <firstterm>supplementary groups</firstterm>. A user’s GID is the GID of his primary group. Every process is also associated with a UID and GID. When a user logs in, the UID and GID of his login shell are set to his UID and GID, respectively. Normally a process inherits the UID and GID of its parent, so the processes invoked by a user will also be associated with his UID and GID. The UID of the current process is returned by <function>Process.uid</function>, and may be set with <function>Process.uid=</function>. Likewise, the GID of the current process may be retrieved and set with <function>Process.gid</function> and <function>Process.gid=</function>, respectively.</para>

    <para>Processes are associated with a list of supplemental groups in much the same way. A user’s login shell is associated with his supplementary groups, which are then inherited by the processes he creates. <function>Process.groups</function> returns an <literal>Array</literal> of GIDs for the current process’s supplementary groups. <function>Process.groups=</function> is given an <literal>Array</literal> of GIDs or group names, with which it sets the process’s supplementary group IDs. The <literal>Array</literal>s of GIDs must not contain more than 32 elements. This limit can be increased, up to a maximum of 4096, with <function>Process.maxgroups=</function>. The current limit is returned by <function>Process.maxgroups</function>. <function>Process.initgroups(<replaceable>user</replaceable>, <replaceable>group</replaceable>)</function> initialises the list of supplementary groups from <replaceable>user</replaceable>’s, and adds to this set <replaceable>group</replaceable>. <replaceable>user</replaceable> is a username given as a <literal>String</literal>, and <replaceable>group</replaceable> is a GID given as an <literal>Integer</literal>.</para>

    <para>A process is also associated with an <firstterm>effective user ID</firstterm> (hereafter: <acronym>EUID</acronym>) and an <firstterm>effective group ID</firstterm> (hereafter: <acronym>EGID</acronym>). Initially, the EUID has the same value as the UID, and the EGID has the same value as the GID. However, if the mode of an executable file has its <firstterm>setuid</firstterm> (a contraction of <emphasis>set user ID</emphasis>) and/or <firstterm>setgid</firstterm> bit set, the EUID or EGID, respectively, of the process is that of the file’s owner/group. Before the EUID/EGID are set, the current value is saved in order to determine what EUIDs/EGIDs the user may switch to. For example, if a file was owned by user <emphasis>zach</emphasis> and had its setuid bit set, when user <emphasis>zoe</emphasis> executed it the process would have a UID and GID corresponding to her UID and GID, an EGID corresponding to her GID, but an EUID with the value of <emphasis>zach</emphasis>’s UID. The EUID and EGID of the current process are returned by <function>Process.euid</function> and <function>Process.egid</function>, respectively, and set with <function>Process.euid=</function> and <function>Process.egid=</function>, respectively.</para>

    <para>For the purposes of job control, a process is assigned a <firstterm>process group</firstterm>. This allows signals to be sent to a group of processes at once. A process group also has an ID (hereafter: <acronym>PGID</acronym>), which is initially that of its leader. The PGID is returned by <function>Process.getpgrp</function>, and the PGID of an arbitrary process may be retrieved with <function>Process.getpgid(<replaceable>PID</replaceable>)</function>. <function>Process.getpgid(0)</function> is equivalent to <function>Process.getpgrp</function>. The PGID of the current process may be set to its PID with <function>Process.setpgrp</function>, while <function>Process.setpgid(<replaceable>PID</replaceable>, <replaceable>PGID</replaceable>)</function> sets the PGID of the process with a PID of <replaceable>PID</replaceable> to <replaceable>PGID</replaceable>. If either value is <literal>0</literal>, it implies the value of this attribute for the current process, i.e. <literal>Process.setpgid(0,0)</literal> is equivalent to <function>Process.setpgrp</function>.</para>

    <para>A <firstterm>session</firstterm> is a collection of process groups. The session ID (hereafter: <acronym>SID</acronym>) is the PID of the session leader. <quote>Sessions arrange a logged-in user’s activities, and associate that user with a <firstterm>controlling terminal</firstterm>, which is a specific tty device that handles the user’s terminal I/O.</quote> <biblioref linkend="bib.love07" begin="154" end="155" units="pages"/>. <function>Process.setsid</function> <quote>creates a new process group inside of a new session, and makes the invoking process the leader of both</quote>, returning the new SID of the calling process. <biblioref linkend="bib.love07" begin="156" end="157" units="pages"/> However, this method will raise <literal>Errno::EPERM</literal> if the calling process is already a process group leader.</para>

    <sect2 xml:id="prc.process-gid">
      <title><literal>Process::GID</literal></title>

      <para>The <literal>Process::GID</literal> module provides a higher-level interface to GIDs. <function>Process::GID.change_privilege(<replaceable>gid</replaceable>)</function> changes the GID, EGID, and saved GID to <replaceable>gid</replaceable>, which it then returns. On error, an <literal>Errno</literal> exception is raised. This is incompatible with <function>Process.gid=</function>.</para>

      <para>The <function>setresgid(2)</function> and <function>setregid(2)</function> system calls allow the GID and EGID to be exchanged with each other. On such systems, <function>Process::GID.re_exchangeable?</function> returns <literal>true</literal>, and <function>Process::GID.re_exchange</function> may be used to set the GID to the current EGID, the EGID to the current GID, and the saved GID to the new EGID. <function>Process::GID.grant_privilege(<replaceable>egid</replaceable>)</function>, and its alias <function>Process::GID.eid=(<replaceable>egid</replaceable>)</function>, set the EGID to <replaceable>egid</replaceable>, or raise an <literal>Errno</literal> exception. If the GID and EGID may be exchanged, these methods also set the saved GID to <replaceable>egid</replaceable>.</para>

      <para><function>Process::GID.switch</function> sets the EGID to the GID, returning the former. If given a block whose body does not modify these values, it ensures that the EGID is reset to its original value.</para>

      <para>The <function>Process::GID.sid_available?</function> predicate returns <literal>true</literal> if the operating system supports saved GIDs; <literal>false</literal>, otherwise. In the latter case, Ruby saves the GID itself and tries to emulate this functionality.</para>
    </sect2>

    <sect2 xml:id="prc.process-uid">
      <title><literal>Process::UID</literal></title>

      <para>The <literal>Process::UID</literal> module is the equivalent of <literal>Process::GID</literal> for UIDs. The methods it provides are identical except they manipulate UIDs/EUIDs rather than GIDs/EGIDs. The <function>setresuid(2)</function> or <function>setreuid(2)</function> system call is required for exchanging the UID with the EUID.</para> 
    </sect2>

    <sect2 xml:id="prc.process-sys">
      <title><literal>Process::Sys</literal></title>

      <para>The <literal>Process::Sys</literal> module, however, provides lower-level access to the system calls used for manipulating user and group IDs. The <function>Process::Sys.getegid</function>, <function>Process::Sys.geteuid</function>, <function>Process::Sys.geteuid</function>, <function>Process::Sys.getgid</function>, and <function>Process::Sys.getuid</function> methods are aliases of <function>Process.egid</function>, <function>Process.euid</function>, <function>Process.gid</function>, and <function>Process.uid</function>, respectively. The following methods are defined in terms of the system call with the same name as the method. Each raises an <literal>Errno</literal> exception if the system call fails, or <literal>NotImplementedError</literal> if the system call does not exist.</para>

       <variablelist>
	 <varlistentry>
	   <term><literal>Process::Sys.issetugid</literal></term>
	   <listitem>
	     <para>Returns <literal>true</literal> if the process is either setuid or setgid; <literal>false</literal>, otherwise.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setegid(<replaceable>gid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the EGID to <replaceable>gid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.seteuid(<replaceable>uid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the EUID to <replaceable>uid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setgid(<replaceable>gid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the GID to <replaceable>gid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setregid(<replaceable>gid</replaceable>, <replaceable>egid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real GID to <replaceable>gid</replaceable>, and the EGID to <replaceable>egid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setresgid(<replaceable>gid</replaceable>, <replaceable>egid</replaceable>, <replaceable>sgid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real GID to <replaceable>gid</replaceable>, the EGID to <replaceable>egid</replaceable>, and the saved GID to <replaceable>sgid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setresuid(<replaceable>uid</replaceable>, <replaceable>euid</replaceable>, <replaceable>suid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real UID to <replaceable>uid</replaceable>, the EUID to <replaceable>euid</replaceable>, and the saved UID to <replaceable>suid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setreuid(<replaceable>uid</replaceable>, <replaceable>euid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real UID to <replaceable>uid</replaceable>, and the EUID to <replaceable>euid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setrgid(<replaceable>gid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real GID to <replaceable>gid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setruid(<replaceable>uid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the real UID to <replaceable>uid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
	 <varlistentry>
	   <term><literal>Process::Sys.setuid(<replaceable>uid</replaceable>)</literal></term>
	   <listitem>
	     <para>Sets the UID to <replaceable>uid</replaceable>.</para>
	   </listitem>
	 </varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 xml:id="prc.signal">
    <title>Signalling</title>

    <para>A <firstterm>signal</firstterm> is a software interrupt that provides a <quote>a mechanism for handling asynchronous events</quote>. <biblioref linkend="bib.love07" units="pages" begin="279" end="279"/> These events may be generated by the operating system or elsewhere in the program, and signals can be sent from one process to another. <quote>The key point is not just that the events occur asynchronously…but also that the program handles the signals asynchronously.</quote> [<emphasis>ibid.</emphasis>]</para>

    <para>A process may register <firstterm>signal handlers</firstterm> to trap specific signals. When the process receives a corresponding signal the handler is invoked; otherwise, the signal is ignored. The <literal>SIGKILL</literal> and <literal>SIGSTOP</literal> signals can neither be trapped nor ignored: they always kill and stop, respectively, the process to which they are sent.</para>

    <para>A signal is identified by both a name and a number. The name is a portable way to refer to a signal and always begins with <literal>SIG</literal>; the number is, in theory, platform-specific. <function>Signal.list</function> returns a <literal>Hash</literal> of signals supported by your platform. The keys are signal names without the <literal>SIG</literal> prefix, as <literal>String</literal>s; the values, signal numbers as <literal>Integer</literal>s. Methods that expect a signal as an argument accept this name as a <literal>String</literal> or <literal>Symbol</literal>—with or without the prefix—or the number.</para>

    <table>
      <caption>Signals Supported on Linux</caption>
      <thead>
	<tr>
	  <th>Name</th>
	  <th>Number</th>
	  <th>Description</th>
	  <th>Default Action</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><literal>SIGABRT</literal> / <literal>SIGIOT</literal></td>
	  <td>6</td>
	  <td>Sent by <function>abort(3)</function>.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGALRM</literal></td>
	  <td>14</td>
	  <td>Sent by <function>alarm(2)</function>.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGBUS</literal></td>
	  <td>7</td>
	  <td>Hardware or alignment error.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGCHLD</literal> / <literal>SIGCLD</literal></td>
	  <td>17</td>
	  <td>Child has terminated.</td>
	  <td>Ignore</td>
	</tr>
	<tr>
	  <td><literal>SIGCONT</literal></td>
	  <td>18</td>
	  <td>Process has continued after being stopped.</td>
	  <td>Ignore</td>
	</tr>
	<tr>
	  <td><literal>SIGEXIT</literal></td>
	  <td>0</td>
	  <td>Ruby is about to terminate; prior to <function>at_exit</function> functions.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGFPE</literal></td>
	  <td>8</td>
	  <td>Arithmetic exception.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGHUP</literal></td>
	  <td>1</td>
	  <td>Process’s controlling terminal was closed.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGILL</literal></td>
	  <td>4</td>
	  <td>Process tried to execute an illegal instruction.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGINT</literal></td>
	  <td>2</td>
	  <td>User generated the interrupt character (<keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>).</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGIO</literal></td>
	  <td>29</td>
	  <td>Asynchronous I/O event.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGIO</literal> / <literal>SIGPOLL</literal></td>
	  <td>29</td>
	  <td>Asynchronous I/O event.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGKILL</literal></td>
	  <td>9</td>
	  <td>Process termination (untrappable).</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGPIPE</literal></td>
	  <td>13</td>
	  <td>Process wrote to a pipe without readers.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGPROF</literal></td>
	  <td>27</td>
	  <td>Profiling timer expired.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGPWR</literal></td>
	  <td>30</td>
	  <td>Power failure.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGQUIT</literal></td>
	  <td>3</td>
	  <td>User generated the quit character (<keycombo><keycap>Ctrl</keycap><keycap>\</keycap></keycombo>).</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGSEGV</literal></td>
	  <td>11</td>
	  <td>Memory access violation.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGSTOP</literal></td>
	  <td>19</td>
	  <td>Suspends execution of the process.</td>
	  <td>Stop</td>
	</tr>
	<tr>
	  <td><literal>SIGSYS</literal></td>
	  <td>31</td>
	  <td>Process tried to execute an invalid system call.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGTERM</literal></td>
	  <td>15</td>
	  <td>Process termination (trappable).</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGTRAP</literal></td>
	  <td>5</td>
	  <td>Break point encountered.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGTSTP</literal></td>
	  <td>20</td>
	  <td>User generated the suspend character (<keycombo><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo>).</td>
	  <td>Stop</td>
	</tr>
	<tr>
	  <td><literal>SIGTTIN</literal></td>
	  <td>21</td>
	  <td>Background process read from controlling terminal.</td>
	  <td>Stop</td>
	</tr>
	<tr>
	  <td><literal>SIGTTOU</literal></td>
	  <td>22</td>
	  <td>Background process wrote to controlling terminal.</td>
	  <td>Stop</td>
	</tr>
	<tr>
	  <td><literal>SIGURG</literal></td>
	  <td>23</td>
	  <td>Urgent I/O pending.</td>
	  <td>Ignore</td>
	</tr>
	<tr>
	  <td><literal>SIGUSR1</literal></td>
	  <td>10</td>
	  <td>Process-defined signal.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGUSR2</literal></td>
	  <td>12</td>
	  <td>Process-defined signal.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGVTALRM</literal></td>
	  <td>26</td>
	  <td>Generated by <function>setitimer(2)</function> when called with <literal>ITIMER_VIRTUAL</literal> flag.</td>
	  <td>Terminate</td>
	</tr>
	<tr>
	  <td><literal>SIGWINCH</literal></td>
	  <td>28</td>
	  <td>Size of controlling terminal window changed.</td>
	  <td>Ignore</td>
	</tr>
	<tr>
	  <td><literal>SIGXCPU</literal></td>
	  <td>24</td>
	  <td>Processor resource limits were exceeded.</td>
	  <td>Dump core</td>
	</tr>
	<tr>
	  <td><literal>SIGXFSZ</literal></td>
	  <td>25</td>
	  <td>File resource limits were exceeded.</td>
	  <td>Dump core</td>
	</tr>
      </tbody>
    </table>

    <sect2 xml:id="prc.signal-send">
      <title>Sending</title>

      <para><function>Process.kill(<replaceable>sig</replaceable>, <replaceable>pid<subscript>0</subscript>…<replaceable>pid<subscript><replaceable>n</replaceable></subscript></replaceable>)</replaceable></function> sends the signal, <replaceable>sig</replaceable>, to the processes with the given PIDs. If <replaceable>sig</replaceable> is a negative <literal>Integer</literal> or its first character is <literal>-</literal>, it signals process groups instead of processes. If <replaceable>sig</replaceable> is an invalid signal number, <literal>Errno::EINVAL</literal> or <literal>RangeError</literal> is raised; if it is an invalid <literal>String</literal> or <literal>Symbol</literal>, an <literal>ArgumentError</literal> is raised instead.</para>

      <para>A PID of zero refers to the current process. If one or more PIDs are invalid, an <literal>Errno::ESRCH</literal> is raised; if you lack permission to signal them, an <literal>Errno::EPERM</literal> is raised. However, if the PID which caused an exception was preceded by legitimate PIDs, the latter may have already been sent <replaceable>sig</replaceable>.</para>
    </sect2>

    <sect2 xml:id="prc.signal-trap">
      <title>Trapping</title>
      
      <para><function>Kernel.trap(<replaceable>sig</replaceable>, <replaceable>command</replaceable>)</function>, and its alias <function>Process.trap</function>, register a handler for signal <replaceable>sig</replaceable>. If <replaceable>command</replaceable> is a <literal>Proc</literal>, or a block is supplied and <replaceable>command</replaceable> omitted, the <literal>Proc</literal>/block is invoked on receipt of <replaceable>sig</replaceable> with the signal number as its sole argument. Otherwise, <replaceable>command</replaceable> must be one of the following:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>"IGNORE"</literal></term>
	  <term><literal>"SIG_IGN"</literal></term>
	  <term><literal>""</literal></term>
	  <term><literal>nil</literal></term>
	  <listitem>
	    <para>Ignores the signal.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>"DEFAULT"</literal></term>
	  <term><literal>"SIG_DFL"</literal></term>
	  <listitem>
	    <para>Invokes Ruby’s default handler.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>"EXIT"</literal></term>
	  <listitem>
	    <para>Terminates the program.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><literal>"SYSTEM_DEFAULT"</literal></term>
	  <listitem>
	    <para>Invokes the operating system’s default handler.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>A program may have at most one signal handler per signal. If <replaceable>sig</replaceable> already has a handler registered, the old handler is replaced with the new, and the old handler is returned; otherwise, <function>trap</function> returns <literal>nil</literal>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="prc.times">
    <title>Times</title>

    <para>The current process times are returned by <function>Process.times</function> as a <literal>Struct::Tms</literal> object with the following methods:</para>

    <variablelist>
      <varlistentry>
	<term><function>#utime</function></term>
	<listitem>
	  <para>User time: CPU time, in seconds, spent executing instructions of the calling process.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><function>#stime</function></term>
	<listitem>
	  <para>System time: CPU time, in seconds, spent in the system while executing tasks for the calling process.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><function>#cutime</function></term>
	<listitem>
	  <para>User time of children: sum of <function>#utime</function> and <function>#cutime</function> values for all waited-for terminated child processes.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><function>#utime</function></term>
	<listitem>
	  <para>System time of children: sum of <function>#stime</function> and <function>#cstime</function> values for all waited-for terminated children.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
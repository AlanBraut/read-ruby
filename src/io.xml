<?xml version="1.0" encoding="utf-8"?>
<chapter version="5.0"
         xml:id="io.io" xml:lang="en" xmlns="http://docbook.org/ns/docbook"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:xlink="http://www.w3.org/1999/xlink">
  
  <title>Input &amp; Output</title>
  
  <epigraph>
    <attribution><biblioref begin="20" end="22" linkend="bib.wall00" units="pages"/></attribution>

    <para>Unless you're using artificial intelligence to model a solipsistic philosopher, your program needs some way to communicate with the outside world.</para>
  </epigraph>

  <para>The <literal>IO</literal> class provides an interface to input and output on the level of file descriptors, while its <literal>File</literal> subclass deals with files on a higher level of abstraction. Accordingly, <literal>File</literal>, which is discussed in <xref linkend="fil.files"/>, is often more appropriate, and easier to use.</para>

  <blockquote>
    <attribution><biblioref begin="201" end="202" linkend="bib.kernighan84" units="pages"/></attribution>
    
    <para>All input and output is done by reading or writing files, because all peripheral devices, even your terminal, are files in the file system. This means that a single interface handles all communication between a program and peripheral devices.</para>
  </blockquote>
  
  <para>In keeping with Unix’s everything-is-a-file philosophy <biblioref linkend="bib.raymond03" units="pages"/>, Ruby allows regular files, directories, block and character devices, symbolic links, hard links, sockets, unnamed pipes, and <acronym>FIFO</acronym>s (named pipes), to be treated conceptually the same. They can be read from and written to.  Before operating on a file, we need to <link linkend="io.open">open</link> it by providing the operating system with the pathname and asking permission to read it, write to it, or both. If our request is granted, we are provided with a integer <emphasis>file descriptor</emphasis> which we must use to refer to the file in future operations. We are allowed only to use the file in the manner, or <link linkend="io.access-mode">access mode</link>, we requested: it is illegal to write to a file opened for reading, or vice versa. With this file descriptor we can <link linkend="io.init">initialize an IO object</link>, or <emphasis>stream</emphasis><footnote><para>Our using <emphasis>stream</emphasis> in this sense fits the spirit if not the letter of its existing meaning in I/O. Loosemore et al. <biblioref begin="220" end="221" linkend="bib.loosemore07" units="pages"/>, for example, differentiate strongly between operations performed on file descriptors and those performed on streams. However, their description of streams as providing a <quote>higher-level interface, layered on top of the primitive file descriptor facilities.</quote> and their remark that <quote>You can also initially open a connection as a file descriptor and then make a stream associated with that file descriptor.</quote>, so closely follows the model of <literal>IO</literal>, that our minor redefinition seems justified.</para></footnote>, which provides an interface for accessing the corresponding file.</para>

  <para>A stream containing binary data can have its <link linkend="io.binmode-textmode">binmode</link> attribute set, which prevents it from being transcoded and associates it with the <link linkend="enc.ascii-8bit">ASCII-8BIT</link> encoding.  Conversely, a stream containing textual data can have its <link linkend="io.binmode-textmode">textmode</link> attribute set, which allows transcoding and newline normalisation.</para>

  <para>Also, associated with a stream is a <firstterm>byte offset</firstterm>, or <link linkend="io.position">file position</link>, which specifies where the next read or write should occur. <quote>When a file is first opened, the file position is zero. Usually, as bytes in the file are read from or written to, byte-by-byte, the file position increases in kind. The file position may also be set manually to a given value, even a value beyond the end of the file.</quote> <biblioref begin="9" end="10" linkend="bib.love07" units="pages"/>. Attempting to read past the end of a file (<acronym>EoF</acronym>) will result in either a <literal>nil</literal> value or an exception being raised, depending on the method used. A file is appended to by writing to a position past its end. The size of a file may be reduced by truncating<footnote><para>We use <emphasis>truncate</emphasis> in its POSIX sense, i.e. to refer to the behaviour of <literal>truncate(2)</literal>. On most file systems, this operation can be used to increase as well as decrease the size of a file, hence our clarification.</para></footnote> it to a smaller size.</para>

  <para>Finally, having used a file descriptor, we should <emphasis>close</emphasis> it to release it back to the operating system.</para>

  <sect1 xml:id="io.standard-streams">
    <title>Standard Input, Output, &amp; Error</title>

    <epigraph>
      <attribution><biblioref begin="201" end="202" linkend="bib.kernighan84" units="pages"/></attribution>

      <para>When it is started by the shell, a program inherits three open files, with file descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error. All of these are by default connected to the terminal, so if a program only reads file descriptor 0 and writes file descriptors 1 and 2, it can do I/O without having to open files. If the program opens any other files, they will have file descriptors 3, 4, etc.</para>
    </epigraph>

    <para>Ruby behaves in the same manner. The constants <literal>STDIN</literal>, <literal>STDOUT</literal>, and <literal>STDERR</literal>, are defined automatically to refer to the program’s standard input, standard output, and standard error streams, respectively. The value of each constant is an <literal>IO</literal> object associated with the corresponding file descriptor. <function>IO#fileno</function> returns the associated file descriptor as an <literal>Integer</literal>.</para>

    <example xml:id="ex.stdin-stdout-stderr">
      <title>Ruby predefines three constants, referring to the standard input, standard output, and standard error streams</title>

      <programlisting><xi:include href="examples/stdin-stdout-stderr.rb" parse="text"/></programlisting>
    </example>

    <para>Three global variables are also defined automatically-<literal>$stdin</literal>, <literal>$stdout</literal>, and <literal>$stderr</literal>-which initially hold the value of the corresponding constant. We have in fact been interacting with <literal>$stdout</literal> implicitly all along: <literal>Kernel.puts</literal> is equivalent to <literal>$stdout.puts</literal>. Similarly, <literal>Kernel.warn</literal> writes to <literal>$stderr</literal>. The reason for the existence of these global variables in addition to the aforementioned constants is that by assigning another <literal>IO</literal> object to one of the global variables, we can temporarily redirect it elsewhere. Then, if we want to restore the original behaviour, we can assign the corresponding constant to the variable.</para>

    <example xml:id="ex.stdout-redirection">
      <title>By assigning <literal>IO</literal> objects to <literal>$stdout</literal> we can redirect our output</title>

      <programlisting><xi:include href="examples/stdout-redirection.rb" parse="text"/></programlisting>
    </example>
  </sect1>
   
  <sect1 xml:id="io.writing">
    <title>Writing</title>

    <para>To write to a stream, <function>IO#print</function> may be used. It takes any number of arguments, which it converts to <literal>String</literal>s before writing them to the receiver. <function>IO#puts</function> is similar, but ensures that what it writes ends with a newline. An idiomatic method for writing a single object to a stream is <function>IO#&lt;&lt;</function> because its selector is <link linkend="glo.less-than-less-than">polymorphic</link>. All three methods are implemented in terms of <function>IO#write</function>, as are most other methods that perform writing. <function>#write</function> takes a single argument, writes it to the stream, then returns the number of bytes written.</para>

    <example xml:id="ex.print-puts">
      <title>The <function>#print</function> and <function>#puts</function> methods of <function>IO</function> and <function>Kernel</function>> write their arguments to an <literal>IO</literal> stream.</title>

      <programlisting><xi:include href="examples/print-puts.rb" parse="text"/></programlisting>
    </example>

    <para><function>Kernel#p</function> provides output suitable for debugging. It accepts any number of arguments, which it converts with <literal>#inspect</literal>, then writes each of them to <literal>$stdout</literal> separated by <literal>"\n"</literal>.</para>

    <example xml:id="ex.object-p">
      <title><function>Kernel#p</function> writes its argument’s <function>#inspect</function>> output to <literal>$stdout</literal></title>
      
      <programlisting><xi:include href="examples/object-p.rb" parse="text"/></programlisting>
    </example>
   </sect1>

   <sect1 xml:id="io.reading">
     <title>Reading</title>

     <para>The simplest way to read from a file is by supplying its name to <function>IO.read</function>. If the file contains binary data, <function>IO.binread</function> should be used instead. Likewise, <function>IO#read</function> and <function>IO#binread</function> read from their receiver, instead.</para>

     <para>If parsing a binary file format, for example, you might treat a file as a stream of bytes. To write a spell checker, you may think in terms of characters. And to analyse a log file you'd think in terms of lines. Its still the same stream, however we think of it, but working in the most appropriate <emphasis>unit</emphasis> leads to clearer code. The key methods for reading from a stream are summarised below. The methods in the <emphasis>Fetch Next</emphasis> column return the unit at the current file position, which they then advance. If called at the end of a stream, they return <literal>nil</literal>. By contrast, the methods listed in <emphasis>Fetch All Remaining</emphasis> return all the units from the current position through to the end of a stream. The <emphasis>Enumerate</emphasis> methods return an <literal>Enumerator</literal>, or if given a block, yield each unit of the stream in turn.</para>

     <informaltable>
       <thead>
	 <tr>
	   <th>Unit</th>
	   <th>Fetch Next</th>
	   <th>Fetch All Remaining</th>
	   <th>Enumerate</th>
	 </tr>
       </thead>
       <tbody>
	 <tr>
	   <td>Bytes</td>
	   <td><function>IO#getbyte</function></td>
	   <td>N/A</td>
	   <td><function>IO#bytes</function></td>
	 </tr>
	 <tr>
	   <td>Characters</td>
	   <td><function>IO#getc</function></td>
	   <td><function>IO#read</function></td>
	   <td><function>IO#chars</function></td>
	 </tr>
	 <tr>
	   <td>Codepoints</td>
	   <td><function>N/A</function></td>
	   <td><function>N/A</function></td>
	   <td><function>IO#codepoints</function></td>
	 </tr>
	 <tr>
	   <td>Lines</td>
	   <td><function>IO#gets</function></td>
	   <td><function>IO#readlines</function></td>
	   <td><function>IO#lines</function></td>
	 </tr>
       </tbody>
     </informaltable>

     <remark>TODO: Xref reading methods in ARGF section.</remark>

     <para>The methods described above are all instance methods, so before use they require that an <literal>IO</literal> object is created. When the only reason for instantiating this object is to enumerate it, a more elegant approach is <function>IO.foreach(<replaceable>fn</replaceable>)</function>, which yields each line of the file named <replaceable>fn</replaceable> to a block, or returns an <literal>Enumerator</literal> if the block is omitted.</para>
  </sect1> 

  <sect1 xml:id="io.access-mode"> 
    <title>Access Mode</title> 

    <para>A file is opened with a particular <firstterm>access mode</firstterm> which specifies the type of action that may be performed on it. It is given as either a <literal>String</literal> or, less commonly, a <link linkend="io.open-flags">bitmask</link>, as shown in the table below. The default access mode is <literal>r</literal>.</para>

    <para>In <xref linkend="io.access-mode-tbl"/>, the access mode is presented as both a <emphasis>String</emphasis> and the equivalent <emphasis>Bitmask</emphasis>. The <emphasis>Read?</emphasis> and <emphasis>Write?</emphasis> columns indicate whether the opened file can be read from or written to, respectively. <emphasis>Truncate?</emphasis> specifies that existing files will be truncated before use. <emphasis>Creates?</emphasis> specifies that non-existent files will be created before use.  Finally, <emphasis>Start Position</emphasis> is the position in the file reading/writing starts from: <emphasis>Beginning</emphasis> is before the first byte; <emphasis>End</emphasis> is after the last.</para>
    
    <table xml:id="io.access-mode-tbl">
      <caption>Access mode specifiers</caption>
      <thead>
	<tr>
	  <th>String</th>
	  <th>Bitmask</th>
	  <th>Read?</th>
	  <th>Write?</th>
	  <th>Truncates?</th>
	  <th>Creates?</th>
	  <th>Start Position</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><literal>r</literal></td>
	  <td><literal>File::RDONLY</literal></td>
	  <td>✔</td>
	  <td>✖</td>
	  <td>✖</td>
	  <td>✖</td>
	  <td>Beginning</td>
	</tr>
	<tr>
	  <td><literal>r+</literal></td>
	  <td><literal>File::RDWR</literal></td>
	  <td>✔</td>
	  <td>✔</td>
	  <td>✖</td>
	  <td>✖</td>
	  <td>〃</td>
	</tr>
	<tr>
	  <td><literal>w</literal></td>
	  <td><literal>File::WRONLY | File::TRUNC | File::CREAT</literal></td>
          <td>✖</td>
	  <td>✔</td>
	  <td>✔</td>
	  <td>✔</td>
	  <td>〃</td>
	</tr>
	<tr>
	  <td><literal>w+</literal></td>
	  <td><literal>File::RDWR | File::TRUNC | File::CREAT</literal></td>
          <td>✔</td>
	  <td>✔</td>
	  <td>✔</td>
	  <td>✔</td>
	  <td>〃</td>
	</tr>
	<tr>
	  <td><literal>a</literal></td>
	  <td><literal>File::APPEND | File::WRONLY | File::CREAT</literal></td>
          <td>✖</td>
	  <td>✔</td>
	  <td>✖</td>
	  <td>✔</td>
	  <td>End.</td>
	</tr>
	<tr>
	  <td><literal>a+</literal></td>
	  <td><literal>File::APPEND | File::RDWR | File::CREAT</literal></td>
          <td>✔</td>
	  <td>✔</td>
	  <td>✖</td>
	  <td>✔</td>
	  <td>〃</td>
	</tr>
      </tbody>
    </table>
  </sect1>

  <sect1 xml:id="io.binmode-textmode">
    <title>Binary &amp; Text Mode</title>

    <para>An <literal>IO</literal> stream may be configured to use binary mode or text mode. These mutually exclusive options determine what automatic modifications, if any, Ruby will make to data read from, and written to, the stream. They have no relationship to the <link linkend="io.access-mode">access mode</link>.</para>

      <para><firstterm>Binary mode</firstterm> is disabled by default. It must be enabled when reading a file with an <link linkend="enc.compatibility">ASCII-incompatible</link> <link linkend="enc.external">external encoding</link>. When enabled it has the following effects:</para>
 
      <itemizedlist>
        <listitem>
          <para>Unless an external encoding has been specified explicitly, it is set to ASCII-8BIT.</para>
	</listitem> 
	<listitem> 
	  <para><link linkend="io.binmode-textmode">Newline conversion</link> is disabled.</para>
	</listitem> 
	<listitem>
          <para>Transcoding is disabled unless both an internal and external encoding have been specified.</para>
	</listitem> 
      </itemizedlist>

      <para>Binary mode may be enabled when opening a stream by either including the <literal>b</literal> modifier in the <link linkend="io.mode-string">mode string</link>, or supplying <literal>binmode: true</literal> for the <link linkend="io.options-hash">options <literal>Hash</literal></link>. It may be enabled for an existing stream with <function>IO#binmode</function>, and queried with the <function>IO#binmode?</function> predicate.</para>

      <para><firstterm>Text mode</firstterm> defaults to on under Microsoft Windows, and off everywhere else. Reading a file in text mode causes <literal>"\r\n"</literal> to be replaced by <literal>"\n"</literal>, and other occurrences of <literal>"\r"</literal> to be replaced by <literal>"\n"</literal>. Writing a file in text mode causes <literal>"\n"</literal> to be replaced with <literal>"\r\n"</literal> under Windows; having no effect on other platforms.</para>
  </sect1> 

  <sect1 xml:id="io.open"> 
    <title>Opening</title>
    
    <para><literal>IO.sysopen</literal> <firstterm>opens</firstterm> a given pathname and returns a corresponding file descriptor. (Use the <link linkend="fil.files">File class</link> for a higher-level interface to this operation). Optionally, it accepts an <link linkend="io.access-mode">access mode</link> as the second argument, and permission bits as the third.</para>
    
    <para>If a file is being created, its initial permissions may be specified as an <literal>Integer</literal>; otherwise, this argument is ignored. On Unix-like systems, these permissions bits are interpreted in the same fashion that <literal>chmod(1)</literal> interprets octal mode arguments. For example, permissions of <literal>0400</literal> gives the user read permission, and no permissions to anybody else. See <xref linkend="fil.permissions"/> for further details.</para>
  </sect1> 

  <sect1 xml:id="io.string"> 
    <title>Encoding String</title>
    
    <para><literal>IO</literal> methods that expect encoding names as arguments, often accept <firstterm>encoding string</firstterm>s, which allow one or both of the <link linkend="enc.external">external encoding</link> and <link linkend="enc.internal">internal encoding</link> to be specified at once in one of the forms below.</para>

    <para>Both <replaceable>external</replaceable> and <replaceable>internal</replaceable> are names of encodings. The <emphasis>Inferred from BOM</emphasis> column indicates that the external encoding is set to that specified by a <acronym>BOM</acronym>, if present, otherwise to the named encoding.</para>
    
    <table>
      <caption>The forms the value of the encoding string may take</caption>
      <thead> 
	<tr>
          <th>Form</th>
	  <th colspan="2">External Encoding</th>
	  <th>Internal Encoding</th>
	</tr> 
	<tr> 
	  <th> </th>
	  <th>Value</th>
	  <th>Inferred from BOM?</th> 
	  <th>Value</th> 
	</tr> 
      </thead> 
      <tbody> 
	<tr> 
	  <td><literal><replaceable>external</replaceable></literal></td>
	  <td rowspan="2"><replaceable>external</replaceable></td> 
	  <td rowspan="2">✖ </td>
          <td rowspan="2"><function>Encoding.default_internal</function></td>
	</tr> 
	<tr> 
	  <td><literal> <replaceable>external</replaceable>:-</literal></td>
	</tr> 
	<tr>
          <td><literal>BOM|<replaceable>external</replaceable></literal></td> 
	  <td rowspan="2"><replaceable>external</replaceable></td>
	  <td rowspan="2">✔</td>
          <td rowspan="2"><function>Encoding.default_internal</function></td> 
	</tr> 
	<tr> 
	  <td><literal>BOM|<replaceable>external</replaceable>:-</literal></td>
        </tr>
	<tr>
          <td><literal><replaceable>external</replaceable>:<replaceable>internal</replaceable></literal></td>
	  <td><replaceable>external</replaceable></td>
	  <td>✖</td> 
	  <td><replaceable>internal</replaceable></td>
        </tr> 
	<tr>
          <td><literal>BOM|<replaceable>external</replaceable>:<replaceable>internal</replaceable> </literal></td>
	  <td><replaceable>external</replaceable></td>
	  <td>✔</td> 
	  <td><replaceable>internal</replaceable></td>
        </tr> 
	<tr>
          <td><literal>:<replaceable>internal</replaceable></literal></td>
	  <td>Default external</td>
	  <td>✖</td> 
	  <td><replaceable>internal</replaceable></td>
        </tr> 
      </tbody> 
    </table> 

    <para>The <literal>BOM|</literal> prefix deserves a fuller explanation. The UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE encodings support the presence of a byte-order mark: a special character occuring at the start of the stream which indicates the byte order of the encoding. This can be used to distinguish between the big-endian and little-endian forms of UTF-16, for example. Prefixing one of the aforementioned encoding names with the case-insensitive string <literal>BOM|</literal> causes the named encoding to be used if the stream doesn’t contain a BoM; otherwise, the BoM is stripped from the stream and the encoding that it specifies is used instead.</para>
  </sect1> 

  <sect1 xml:id="io.init"> 
    <title>Initializing</title> 

    <para>An <literal>IO</literal> instance objectifies a given file descriptor. It may be initialized by supplying this file descriptor as the first argument to <function>IO.new</function>. Optionally, a <link linkend="io.mode-string">mode string</link>, or <link linkend="io.open-flags">numeric access mode</link>, can be provided as the second argument, however this must agree with the <link linkend="io.access-mode">access mode</link> already associated with the file descriptor. An <link linkend="io.options-hash">options Hash</link> may be provided as the final argument.</para>

    <para><function>IO.open</function> accepts the same arguments, but also expects a block. It initializes an <literal>IO</literal> object as before, yields it to the block, then ensures the stream is closed when the block exits.</para>
      
    <sect2 xml:id="io.mode-string">
      <title>Mode String</title> 
      
      <para>The <firstterm>mode string</firstterm> is a concise way to specify options for opening a file. At its simplest, it consists of only the <link linkend="io.access-mode">access mode</link> as a <literal>String</literal>, e.g. a mode string of <literal>"r"</literal> opens a file in read-only mode. If the next character is <literal>b</literal>, it specifies <link linkend="io.binmode-textmode">binary mode</link>; if it is <literal>t </literal>, it specifies <link linkend="io.binmode-textmode">text mode</link>. Finally, the <link linkend="enc.external">external</link> and/or <link linkend="enc.internal">internal</link> encodings may be specified as an <link linkend="io.string">encoding string</link>.</para>

      <para>In the table below, <replaceable>mode</replaceable> denotes one of the access modes given in the <link linkend="io.access-mode">Access Mode</link> table.  The <emphasis>Binary?</emphasis> and <emphasis>Text?</emphasis> columns indicates whether the stream is in binary text mode, respectively. Both <replaceable>internal</replaceable> and <replaceable>external</replaceable> are names of encodings.</para>
      
      <table>
	<caption>The forms a mode string may take</caption>
	<thead> 
	  <tr>
	    <th>Form</th>
	    <th>Binary?</th> 
	    <th>Text?</th> 
	    <th>External Encoding</th> 
	    <th>Internal Encoding</th> 
	  </tr> 
	</thead> 
	<tbody> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable></literal></td> 
	    <td>✖</td>
	    <td>✖</td> 
	    <td><function>Encoding.default_external</function></td> 
	    <td><function>Encoding.default_internal</function></td>
	  </tr> 
	  <tr>
	    <td><literal><replaceable>mode</replaceable>t</literal></td> 
	    <td>✖</td>
	    <td>✔</td> 
	    <td>〃</td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable>b</literal></td> 
	    <td>✔</td>
	    <td>✖</td> 
	    <td><literal>ASCII-8BIT</literal></td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable>:<replaceable>external</replaceable></literal></td>
	    <td>✖</td> 
	    <td>✖</td> 
	    <td><replaceable>external</replaceable></td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable>t:<replaceable>external</replaceable></literal></td>
	    <td>✖</td> 
	    <td>✔</td> 
	    <td>〃</td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal> <replaceable>mode</replaceable>b:<replaceable>external</replaceable> </literal></td>
	    <td>✔</td> 
	    <td>✖</td> 
	    <td>〃</td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable>:<replaceable>external</replaceable>:<replaceable>internal</replaceable></literal></td> 
	    <td>✖</td> 
	    <td>✖</td> 
	    <td>〃</td> 
	    <td><replaceable>internal</replaceable></td>
	  </tr> 
	  <tr>
	    <td><literal><replaceable>mode</replaceable>t:<replaceable>external</replaceable>:<replaceable>internal</replaceable></literal></td>
	    <td>✖</td> 
	    <td>✔</td> 
	    <td>〃</td> 
	    <td>〃</td> 
	  </tr> 
	  <tr> 
	    <td><literal><replaceable>mode</replaceable>b:<replaceable>external</replaceable>:<replaceable>internal</replaceable></literal></td> 
	    <td>✔</td> 
	    <td>✖</td> 
	    <td>〃</td> 
	    <td>〃</td> 
	  </tr> 
	</tbody> 
      </table>
      
      <para>For example, <literal>r:ascii</literal> reads from the beginning of a file, tagging the data it reads as US-ASCII; <literal>a+:ascii:utf-8</literal> opens the file for reading and appending, transcoding from US-ASCII to UTF-8 when reading, and in the opposite direction when writing.</para>
    </sect2> 

    <sect2 xml:id="io.options-hash">
      <title>Options Hash</title> 

      <para>Alternatively, many methods that open files accept an options <literal>Hash</literal> as their final argument. Class methods of <literal>IO</literal> that accept this <literal>Hash</literal> recognise an <literal>:open_args</literal> key whose value is an <literal>Array</literal> of arguments for the underlying <function>open</function> method; if this key is supplied, all others are ignored. In addition to the keys listed below, those of the <link linkend="enc.options-hash"><function>String#encode</function> options <literal>Hash</literal></link> are also recognised.</para>

      <table>
	<caption>Options that may be specified as a <literal>Hash</literal> for certain methods that open files</caption>
	<thead> 
	  <tr>
	    <th>Key</th> 
	    <th>Value </th> 
	    <th>Default value </th>
	    <th>Description
	    </th> 
	  </tr> 
	</thead> 
	<tbody> 
	  <tr> 
	    <td><literal>:mode</literal></td> 
	    <td>The mode string or the access mode as an <literal>Integer</literal>.</td>
	    <td><literal>r</literal></td> 
	    <td>Whether to open the file in read-only, read-write, or write-only mode, and whether to truncate existing files or append to them.</td>
	  </tr> 
	  <tr> 
	    <td><link linkend="io.binmode-textmode"><literal>:textmode</literal></link></td> 
	    <td><literal>true</literal> or <literal>false</literal></td> 
	    <td><literal>false</literal></td>
	    <td>Whether to perform newline conversion.</td>
	  </tr> 
	  <tr>
	    <td><link linkend="io.binmode-textmode"><literal>:binmode</literal></link></td> 
	    <td><literal>true</literal> or <literal>false</literal></td>
	    <td><literal>false</literal></td> 
	    <td>Whether to treat the file as a stream of bytes.</td>
	  </tr> 
	  <tr>
	    <td><literal>:open_args</literal></td> 
	    <td><literal>Array</literal></td>
	    <td><literal>[]</literal></td> 
	    <td>Arguments for <function>Kernel.open</function>.</td>
	  </tr> 
	  <tr>
	    <td><literal>:perm</literal></td> 
	    <td><literal>Integer</literal></td> 
	    <td>Platform-specific</td> 
	    <td>The permissions the file should be created with.</td>
	  </tr> 
	  <tr>
	    <td><literal>:external_encoding</literal></td> 
	    <td><literal>Encoding</literal> object or encoding name</td> 
	    <td><function>Encoding.default_external</function></td> 
	    <td>The external encoding to apply to the stream.</td>
	  </tr> 
	  <tr>
	    <td><literal>:internal_encoding</literal></td> 
	    <td>〃</td> 
	    <td><function>Encoding.default_internal</function></td> 
	    <td>The internal encoding to apply to the stream.</td> 
	  </tr> 
	  <tr> 
	    <td><literal>:encoding</literal></td> 
	    <td>Encoding name or two names separated by a colon.</td> 
	    <td><literal><replaceable>default_external</replaceable>:<replaceable>default_internal</replaceable></literal></td>
	    <td>The external, or external and internal, encodings to apply to the stream.</td>
	  </tr> 
	  <tr> 
	    <td><literal>:autoclose</literal></td> 
	    <td><literal>true</literal> or <literal>false</literal></td> 
	    <td><literal>true</literal></td> 
	    <td>Whether to automatically close the file descriptor when the <literal>IO</literal> object is finalised.</td>
	  </tr> 
	</tbody>
      </table>
    </sect2>
  </sect1> 

  <sect1 xml:id="io.open-flags"> 
    <title>Open Flags</title>
    
    <para>The <link linkend="io.access-mode">access mode</link> may also be given as an <literal>Integer</literal> formed by taking the bitwise OR of one or more <firstterm>open flags</firstterm>, each of which is represented by a constant in the <literal>File</literal> namespace. The available flags are explained below.</para>

    <variablelist>
      <varlistentry>
        <term><literal>File::APPEND</literal></term> 
	<listitem> 
	  <para>Opens the file in <firstterm>append mode</firstterm>. <quote>If set, then all write operations write the data at the end of the file, extending it, regardless of the current file position.  This is the only reliable way to append to a file. In append mode, you are guaranteed that the data you write will always go to the current end of the file, regardless of other processes writing to the file. Conversely, if you simply set the file position to the end of file and write, then another process can extend the file after you set the file position but before you write, resulting in your data appearing someplace before the real end of file.</quote> <biblioref begin="335" end="335" linkend="bib.loosemore07" units="pages"/>.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File::BINARY</literal></term> 
	<listitem> 
	  <para>Puts the stream in <link linkend="io.binmode-textmode">binary mode</link>.</para>
	</listitem> 
      </varlistentry> 
      <varlistentry> 
	<term><literal>File::CREAT</literal></term> 
	<listitem> 
	  <para>Creates the file if it doesn’t already exist. If the file already exists, this has no effect unless <literal>File::EXCL</literal> is also given.</para>
	</listitem> 
      </varlistentry> 
      <varlistentry> 
	<term><literal>File::DSYNC</literal></term> 
	<listitem> 
	  <para>
	  <quote>… specifies that only normal data be synchronized after each write operation, not metadata.</quote> <biblioref begin="40" end="40" linkend="bib.love07" units="pages"/>. On Linux, this is synonymous with <literal>File::SYNC</literal>.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File::EXCL</literal></term> 
	<listitem> 
	  <para>When given with <literal>File::CREAT</literal>, an <literal>Errno::EXIST</literal> exception will be raised if the file already exists. <quote>This is used to prevent race conditions on file creation.</quote> <biblioref begin="24" end="26" linkend="bib.love07" units="pages"/>.</para>
        </listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File:NOATIME</literal></term> 
	<listitem> 
	  <para>Do not update the access time (<emphasis>atime</emphasis>) of the file. <quote>This is used by programs that do backups, so that backing a file up does not count as reading it. Only the owner of the file or the superuser may use this bit.</quote> <biblioref begin="335" end="335" linkend="bib.loosemore07"/>.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File:NOCTTY</literal></term> 
	<listitem> 
	  <para><quote>If the named file is a terminal device, don’t make it the controlling terminal for the process.</quote> <biblioref begin="333" end="334" linkend="bib.loosemore07" units="pages"/>. (<function>IO#tty?</function>, or its alias <function>IO#isatty</function>, can be used to determine whether the stream is a TTY).</para>
        </listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File::NOFOLLOW</literal></term> 
	<listitem> 
	  <para>If the pathname is a symbolic link, an <literal>Errno::ELOOP</literal> exception will be raised. <quote>Normally, the link is resolved, and the target file is opened. If other components in the given path are links, the call will still succeed. For example, if name is <filename>/etc/ship/plank.txt</filename>, the call will fail if <filename>plank.txt</filename> is a symbolic link. It will succeed, however, if <filename>etc</filename> or <filename>ship</filename> is a symbolic link, so long as <filename>plank.txt</filename> is not.</quote> <biblioref begin="24" end="26" linkend="bib.love07" units="pages"/>.</para>
	</listitem> 
      </varlistentry> 
      <varlistentry>
        <term><literal>File:NONBLOCK</literal></term> 
	<listitem> 
	  <para><quote>If possible, the file will be opened in nonblocking mode.  Neither the <literal>open()</literal> call, nor any other operation will cause the process to block (sleep) on the I/O.  This behavior may be defined only for FIFOs.</quote> <biblioref begin="24" end="26" linkend="bib.love07" units="pages"/>.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File:RDONLY</literal></term> 
	<listitem><para>Opens the file for reading.</para></listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File:RDWR</literal></term> 
	<listitem><para>Opens the file for reading and writing.</para></listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File::RSYNC</literal></term> 
	<listitem> 
	  <para><quote>…specifies the synchronization of read requests as well as write requests. It must be used with one of [<literal>File::SYNC</literal>] or [<literal>File::DSYNC</literal>]. As mentioned earlier, reads are already synchronized—they do not return until they have something to give the user, after all. The [<literal>File::RSYNC</literal>] flag stipulates that any side effects of a read operation be synchronized, too. This means that metadata updates resulting from a read must be written to disk before the call returns.</quote> <biblioref begin="40" end="40" linkend="bib.love07" units="pages"/>. On Linux, this is synonymous with <literal>File::SYNC</literal>.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term>
          <literal>File:WRONLY</literal> 
	</term> 
	<listitem> 
	  <para>Opens the file for writing.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>File::SYNC</literal></term> 
	<listitem> 
	  <para><quote>The file will be opened for synchronous I/O. No write operation will complete until the data has been physically written to disk; normal read operations are already synchronous, so this flag has no effect on reads.</quote> <biblioref begin="24" end="26" linkend="bib.love07" units="pages"/>.</para>
	</listitem> 
      </varlistentry> 
      <varlistentry>
        <term><literal>File::TRUNC</literal></term> 
	<listitem> 
	  <para><quote>If the file exists, it is a regular file, and the given flags allow for writing, the file will be truncated to zero length. Use of [<literal>File::TRUNC</literal>] on a FIFO or terminal device is ignored. Use on other file types is undefined.  Specifying [<literal>File::TRUNC</literal>] with [<literal>File::RDONLY</literal>] is also undefined, as you need write access to the file in order to truncate it.</quote> <biblioref begin="24" end="26" linkend="bib.love07" units="pages"/>.</para>
        </listitem>
      </varlistentry> 
    </variablelist> 
  </sect1>

  <sect1 xml:id="io.buffering">
    <title>Buffering</title> 
    
    <para><quote>Buffering writes provides a <emphasis>huge</emphasis> performance improvement, and consequently, any operating system even halfway deserving the mark “modern” implements delayed writes via buffers.</quote> <biblioref begin="37" end="37" linkend="bib.love07" units="pages"/>. Love explains the Linux kernel’s approach-which is similar to that of other operating systems-to write buffering as follows:</para>
    
    <blockquote>
      <attribution><biblioref begin="37" end="37" linkend="bib.love07" units="pages"/></attribution>

      <para>…when a user-space application issues a <literal>write()</literal> system call, the Linux kernel performs a few checks, and then simply copies the data into a buffer.  Later, in the background, the kernel gathers up all of the “dirty” buffers, sorts them optimally, and writes them out to disk (a process known as <emphasis>writeback</emphasis>). This allows write calls to occur lightning fast, returning almost immediately. It also allows the kernel to defer writes to more idle periods, and batch many writes together.</para>
    </blockquote> 

    <para>Further, and for the same reasons, Ruby maintains her own I/O buffer. Therefore, before data is written to disk by Ruby, it passes first through her buffers, and then those of the underlying operating system. The latter are beyond the scope of this text, so we shall focus on the former from now on.</para>

    <para>The <literal>IO</literal> methods for writing that we discussed above, are buffered-that is, they pass through Ruby’s buffers. An exception is <function>IO#syswrite</function>, so shouldn’t be used in conjunction with other methods that perform writing. To understand why, consider a scenario where a given stream has <literal>?a</literal> written to it with <function>IO#print</function>, then <literal>?b</literal> written to it with <function>IO#syswrite</function>, then <literal>?c</literal> written to it with <function>IO#print</function>. The first character written is buffered, the second is written directly, and the third is buffered. When the stream is closed, Ruby flushes her buffer, causing <literal>"ac"</literal> to be written.  Therefore, the data is written out of order: <literal>"bac"</literal>.</para>

    <para>Ruby’s buffer can be flushed manually with <function>IO#flush</function>. This causes the contents of the buffer to be passed to the operating system, and the buffer to be emptied. Alternatively, buffering can be disabled for a given stream by setting <function>IO#sync=</function> to <literal>true</literal>; by default, it is <literal>false</literal>. This value can be queried with <function>IO#sync</function>.</para>

   <para>The operating system’s buffer can be flushed with <function>IO#fsync</function>, which ensures both the data and metadata—e.g. file creation timestamps—associated with the stream are written to disk. A faster alternative is <function>IO#fdatasync</function> because it only flushes the data. Both methods wrap the eponymous system call, so if that is not available an <exceptionname>NotImplementedError</exceptionname> is raised.</para>

    <para>Reads are buffered by Ruby, too, by reading more data than the user requests, and buffering the surplus. Accordingly, when a stream is read from then duplicated or reopened, its replica may return data out of order or report negative values for <function>IO#pos</function>. See <biblioref linkend="bib.ruby-core-28281"/> for more details.</para>

    <para>Buffered reads make possible what Loosemore et al. term <firstterm>unreading</firstterm>: <biblioref linkend="bib.loosemore07" units="pages" begin="241" end="241"/></para>
    
    <blockquote>
      <attribution><biblioref linkend="bib.loosemore07" units="pages" begin="241" end="241"/></attribution>

      <para>Using stream I/O, you can peek ahead at input by first reading it and then <emphasis>unreading</emphasis> it (also called <emphasis>pushing it back</emphasis> on the stream). Unreading a character makes it available to be input again from the stream, by the next call to [an] input function on that stream.</para>
    </blockquote> 
    
    <para>Two methods are provided for this purpose: <function>IO#ungetc</function> and <function>IO#ungetbyte</function>. Both expect an argument-characters for the former; bytes for the latter-which they unread. Subsequent buffered reads from the stream will return the unread characters/bytes in reverse chronological order before reading new data from the stream.</para>
    
  </sect1>
  
  <sect1 xml:id="io.close">
    <title>Closing</title>

    <para>Once an <literal>IO</literal> stream is finished with, it should be <firstterm>closed</firstterm>. This ensures that Ruby’s write buffer is flushed, and the associated file-descriptor is released back to the operating system. A stream is closed for reading and writing with <function>IO#close</function>. Subsequent attempts to read from or write to a closed stream causes an <literal>IOError</literal> to be raised, so the <function>IO#closed?</function> predicate is available for testing a stream. A duplex stream may also be closed just for writing or just for reading, using <function>IO#close_write</function> and <function>IO#close_read</function>, respectively.</para>

    <example xml:id="ex.io-close">
      <title>Closing an <literal>IO</literal> stream</title>

      <programlisting><xi:include parse="text" href="examples/io-close.rb"/></programlisting>
    </example>

    <para>When an <literal>IO</literal> object is finalised its <firstterm>auto-close</firstterm> flag determines whether the underlying file descriptor is closed automatically. By default, this flag has the value <literal>true</literal>, but it can be set explicitly with <function>IO#autoclose=</function>, and queried with <function>IO#autoclose?</function>.</para>

    <para>On a Unix-based system a process created by <function>Kernel.exec</function>, <function>Kernel.fork</function>, or <function>IO.popen</function> inherits the file descriptors of its parent. Depending on the application, this may constitute an information leak in that the child is able to access data that he shouldn’t have access to. If given a true argument, <function>IO#close_on_exec=</function> ensures that its receiver is closed before the new process is created; otherwise, it does not. <function>IO#close_on_exec?</function> returns the status of this flag as either <literal>true</literal> or <literal>false</literal>. On systems that don’t support this feature, these methods raise <literal>NotImplementedError</literal>.</para>
    
    <example xml:id="ex.io-close_on_exec">
      <title>By deafult, child processes can access their parent’s file descriptors</title>

      <programlisting><xi:include parse="text" href="examples/io-close_on_exec.rb"/></programlisting>
    </example>

    <example xml:id="ex.io-close_on_exec2">
      <title>If the <emphasis>close-on-exec</emphasis> flag is set, child processes cannot access their parent’s file descriptors</title>

      <programlisting><xi:include parse="text" href="examples/io-close_on_exec2.rb"/></programlisting>
    </example>
  </sect1>

  <sect1 xml:id="io.position">
    <title>Positions &amp; Seeking</title> 

    <para>Beck et al. explain that an attribute of a file’s structure is <quote>the position of the read/ write pointer at which the next I/O operation will be carried out. This value is updated by every I/O operation and by the system calls <literal>lseek</literal> and <literal>llseek</literal>.</quote> (<biblioref begin="41" end="43" linkend="bib.beck98" units="pages"/>. Ruby exposes the current position in an I/O stream with <function>IO#pos</function> as the offset in bytes. To seek to a given position in a stream, one can assign the new, <literal>Integer</literal>, offset to <function>IO#pos=</function>.  For more control over seeking, use <function>IO#seek(<replaceable>pos</replaceable>, <replaceable>origin</replaceable>)</function>, where <replaceable>pos</replaceable> is a byte offset specified as an <literal>Integer</literal>, and <replaceable>origin</replaceable> is one of the values given below.</para>
    
    <variablelist>
      <varlistentry>
        <term><literal>IO::SEEK_CUR</literal></term> 
	<listitem> 
	  <para>The current position is set to its current value plus <replaceable>pos</replaceable>, which can be negative, zero, or positive. If <replaceable>pos</replaceable> is zero the current position is unchanged.</para>
	</listitem>
      </varlistentry> 
      <varlistentry>
        <term><literal>IO::SEEK_END</literal></term> 
	<listitem> 
	  <para>The current position is set to the length of the file plus <replaceable>pos</replaceable>, which can be negative, zero, or positive. If <replaceable>pos</replaceable> is zero the current position is set to the end of the file.</para>
	</listitem> 
      </varlistentry> 
      <varlistentry> 
	<term><literal>IO::SEEK_SET</literal></term> 
	<listitem> 
	  <para>The current position is set to <replaceable>pos</replaceable>. If <replaceable>pos</replaceable> is zero the current position is set to the beginning of the file.</para>
        </listitem>
      </varlistentry> 
    </variablelist> 
    
    <para>Ruby also keeps track of the current line number in a stream. The line-orientated reading methods increment the line number when they encounter the separator character. It initially has a value of zero, and its current value may be retrieved with <function>IO#lineno</function>, or set explicitly with <function>IO#lineno=</function>. The current position and line number for a given stream may be reset to zero with <function>IO#rewind</function>.</para>

    <para>As described in the introduction to this chapter, a position past the end of a stream is termed <emphasis>End of File</emphasis>, or <acronym>EoF</acronym>. Depending on the method, reading from a stream at <acronym>EoF</acronym> causes either an <literal>EoFError</literal> exception to be raised or <literal>nil</literal> to be returned. If a stream is open for reading, this condition can be tested for with the <function>IO#eof?</function> predicate.</para>
  </sect1>  

  <sect1 xml:id="io.pipes">
    <title>Pipes</title>

    <para>A <firstterm>pipe</firstterm> is a unidirectional<footnote><para>Bi-directional pipes also exit in some systems. <acronym>POSIX</acronym> only requires unidirectional semantics, however, so it is there that we shall focus.</para></footnote>, or <firstterm>half-duplex</firstterm>, inter-process communication channel. It comprises two file descriptors: one of which is open for reading, and the other, writing. Data written to the write end of a pipe can be read from the read end on a first-in-first-out basis.</para>

    <para>A pipe is created in Ruby using <function>IO.pipe</function>. It returns a two-element <literal>Array</literal> of <literal>IO</literal> objects, the first of which is the read end, and the second the write end. If <function>IO.pipe</function> is given a block, it is passed both <literal>IO</literal> objects as arguments, and ensures they are closed when the block exits. The write end of the pipe has its sync mode set automatically such that Ruby does not buffer writes; the read end will block until the write end has been closed for writing. However, as W. Richard Stevens notes <quote>A pipe in a single process is next to useless.</quote> <biblioref linkend="bib.stevens05" units="pages" begin="428" end="429"/>; the <emphasis>Processes &amp; Signals</emphasis><remark>Make into xref</remark> chapter discusses how pipes are used to communicate between processes.</para>

    <example xml:id="ex.io-pipe">
      <title>Communicating via a pipe</title>

      <programlisting><xi:include href="examples/io-pipe.rb" parse="text"/></programlisting>
    </example>
  </sect1>

  <sect1 xml:id="io.async">
    <title>Asynchronous &amp; Multiplexed</title>

    <remark>TODO: Consider trimming this</remark>

    <para>By default, I/O operations are <firstterm>blocking</firstterm> (<firstterm>synchronous</firstterm>): they do not return control to their caller until finished. This can be problematic given the performance disparity between <acronym>CPU</acronym>s and devices such as hard disks and routers. An I/O-bound program may spend the majority of its time idly waiting. Conversely, <firstterm>non-blocking</firstterm> (<firstterm>asynchronous</firstterm>) operations return immediately. They try to perform the operation as normal, but if doing so would require blocking, they signal an error and return.</para>

    <para>We have already seen a partial solution to this problem in the <literal>File::NONBLOCK</literal> flag taken by <literal>Kernel.open</literal>. <function>IO#read_nonblock(<replaceable>max</replaceable>)</function> builds upon this approach by setting the <literal>NONBLOCK</literal> flag for the file descriptor, then attempting to read at most <replaceable>max</replaceable> bytes without blocking. If an optional second argument is supplied, it is a <literal>String</literal> to which the received data is appended. This method works as follows:</para>

    <orderedlist>
      <listitem>
	<para>If there is data in Ruby’s read buffer, up to <replaceable>max</replaceable> bytes are returned.</para>
      </listitem>
      <listitem>
	<para>If the stream can be read from without blocking, at most <replaceable>max</replaceable> bytes are read and returned.</para>
      </listitem>
      <listitem>
	<para>If <function>IO#read</function> would have raised an exception when attempting to read from this stream, the same exception is raised.</para>
      </listitem>
      <listitem>
	<para>Otherwise, either <literal>Errno::EWOULDBLOCK</literal> or <literal>Errno::EAGAIN</literal> is raised to indicate that the stream can not be read without blocking. These two exceptions are virtually synonymous<footnote><para><acronym>POSIX</acronym> allows both to have the same value.</para></footnote>, so Ruby mixes in <literal>IO::WaitReadable</literal> to both, allowing <literal>rescue IO::WaitReadable</literal> to handle either.</para>
      </listitem>
      <listitem>
	<para>If <acronym>EoF</acronym> is reached, <literal>EOFError</literal> is raised.</para>
      </listitem>
    </orderedlist>

    <para>The principle, then, is that if <function>#read_nonblock</function> raises <literal>Errno::EWOULDBLOCK</literal> or <literal>Errno::EAGAIN</literal>, the program can attend to other tasks before it retries the call. <function>IO#readpartial</function> is identical, except it does not set the <literal>NONBLOCK</literal> flag on the file descriptor: if blocking is unavoidable, it blocks.</para>

    <para><function>IO#write_nonblock(<replaceable>string</replaceable>)</function> is similar to <function>#read_nonblock</function>. It flushes the write buffer, then tries to write <replaceable>string</replaceable> to the receiver, raising <literal>Errno::EAGAIN</literal> or <literal>Errno::EWOULDBLOCK</literal> if the write would have blocked. It returns the number of bytes written, which should be compared to <literal><replaceable>string</replaceable>.bytesize</literal> to detect partial writes. On Windows, some <literal>IO</literal> objects cannot be used in this way, so <literal>#write_nonblock</literal> raises <literal>Errno::EBADF</literal>.</para>

    <para>Given a collection of <literal>IO</literal> objects, how does a program know which are available for writing or reading? <function>Kernel.select</function> is one answer. It accepts up to three <literal>Array</literal>s of <literal>IO</literal> objects: those in the first <literal>Array</literal> are monitored for reading, the second, for writing, and the third, for errors. It returns a three-element <literal>Array</literal> of the same configuration containing only the <literal>IO</literal> objects that are ready for their respective operation. If a fourth argument is given, it is a timeout: if none of the streams are ready in the given amount of seconds <function>Kernel.select</function> returns <literal>nil</literal>.</para>
    
    <example xml:id="ex.io-select">
      <title>Managing a message queue with <function>Kernel.select</function></title>

      <programlisting><xi:include href="examples/io-select.rb" parse="text"/></programlisting>
    </example>

    <remark>Mention io/wait in callout?</remark>
  </sect1>

  <sect1 xml:id="io.fcntl">
    <title>Manipulating File Descriptors</title>

    <para><function>IO#fcntl(<replaceable>cmd</replaceable>, <replaceable>arg</replaceable>)</function> performs <replaceable>cmd</replaceable> on the receiver, where <replaceable>cmd</replaceable> is an platform-specific <literal>Integer</literal>. The <literal>Fcntl</literal> module in the standard library provides constants corresponding to some of the more common commands. If <replaceable>cmd</replaceable> requires an argument, it should be supplied as <replaceable>arg</replaceable>.</para>

    <table>
      <caption><literal>IO#fcntl</literal> commands with corresponding constants defined in the <literal>Fcntl</literal> module</caption>
      <thead>
	<tr>
	  <th>Command</th>
	  <th>Argument</th>
	  <th>Returns</th>
	  <th>Description</th>
	</tr>
      </thead>
      <tr>
	<td><literal>F_DUPFD</literal></td>
	<td><literal>Integer</literal></td>
	<td>Positive <literal>Integer</literal>; <literal>-1</literal> on error</td>
	<td>Find the lowest numbered available file descriptor greater than or equal to <replaceable>arg</replaceable> and make it a copy of the receiver’s file descriptor. If <replaceable>arg</replaceable> is omitted, it is assumed to be equal to the receiver’s file descriptor.</td> 
      </tr>
      <tr>
	<td><literal>F_GETFD</literal></td>
	<td>N/A</td>
	<td>File descriptor flags</td>
	<td>Retrieves the associated file descriptor flags. Currently, these are either <literal>0</literal> or <literal>FD_CLOEXEC</literal>. These flags may be set with <literal>F_SETFD</literal>.</td>
      </tr>
      <tr>
	<td><literal>F_GETFL</literal></td>
	<td>N/A</td>
	<td><literal>Integer</literal></td>
	<td>Returns the file status flags, i.e. a bitwise OR of <literal>O_APPEND</literal>, <literal>O_ASYNC</literal>, <literal>O_DIRECT</literal>, etc. <literal>O_ACCMODE</literal> is a bitmask for extracting the access mode from these flags.</td>
      </tr>
      <tr>
	<td><literal>F_GETLK</literal></td>
	<td><literal>struct flock *</literal></td>
	<td>N/A</td>
	<td>The argument describes a lock the caller wishes to place on the file. If this is possible, the <literal>l_type</literal> field of the struct is set to <literal>Fcntl::F_UNLCK</literal>; otherwise the struct is updated with details of the current lock holder.</td>
      </tr>
      <tr>
	<td><literal>F_SETFD</literal></td>
	<td><literal>FD_CLOEXEC</literal> or <literal>0</literal></td>
	<td><literal>0</literal>; <literal>-1</literal> on error</td>
	<td>Sets the file descriptor flags to <replaceable>arg</replaceable>.When <replaceable>arg</replaceable> is <literal>FD_CLOEXEC</literal>, this is equivalent to <function>#close_on_exec=true</function>.</td>
      </tr>
      <tr>
	<td><literal>F_SETFL</literal></td>
	<td><literal>Integer</literal></td>
	<td><literal>0</literal>; <literal>-1</literal> on error</td>
	<td>Set the file status flags to <replaceable>arg</replaceable></td>
      </tr>
      <tr>
	<td><literal>F_SETLK</literal></td>
	<td><literal>struct flock *</literal></td>
	<td><literal>0</literal>; <literal>-1</literal> on error.</td>
	<td>When the struct’s <literal>l_type</literal> field has the value <literal>F_RDLCK</literal> or <literal>F_WRLCK</literal>, acquires the lock; when it has the value <literal>F_UNLCK</literal>, releases the lock.</td>
      </tr>
      <tr>
	<td><literal>F_SETLKW</literal></td>
	<td><literal>struct flock *</literal></td>
	<td><literal>0</literal>; <literal>-1</literal> on error.</td>
	<td>Behaves like <literal>F_SETLK</literal>, except when a conflicting lock is held this call blocks until  the lock is released or a signal is caught.</td>
      </tr>
    </table>

    <example xml:id="ex.io-fcntl">
      <title>Using <literal>IO#fcntl</literal></title> 

      <programlisting><xi:include href="examples/io-fcntl.rb" parse="text"/></programlisting>
    </example>

    <para>Unfortunately, the locking commands are awkward to use from Ruby because they require <replaceable>arg</replaceable> to be a binary <literal>String</literal> representing a specific C struct… If you insist, consult <literal>man 2 fcntl</literal> and <link linkend="str.unpack"><function>String#unpack</function></link>.</para>

    <para>In a similar vein, <function>IO#ioctl(<replaceable>cmd</replaceable>, <replaceable>arg</replaceable>)</function> is an esoteric way to send commands to hardware devices. <replaceable>cmd</replaceable> is the <literal>Integer</literal> associated with the command, and <replaceable>arg</replaceable> is its optional argument. This is utterly unportable because commands and their values are typically specific to particular operating systems, drivers, and hardware. For example, on Linux <literal>man 2 ioctl_list</literal> provides a partial list of values for <replaceable>cmd</replaceable>. One of them is <literal>CDROMEJECT</literal>, which on my system has the value <literal>0x00005309</literal> and doesn’t accept arguments. When sent to a CD-ROM drive, it causes the disc to eject. When <replaceable>arg</replaceable> is an integer it can be supplied as an <literal>Integer</literal>, otherwise <function>String#unpack</function> will be required to craft a <literal>String</literal> resembling the expected data structure. The example that follows animates the <acronym>LED</acronym>s corresponding to my <keycap>Num Lock</keycap>, <keycap>Caps Lock</keycap>, and <keycap>Scroll Lock</keycap> keys. To have any chance of running it on another system, you will at least need to adjust the value of <literal>KDSETLED</literal>.</para>

    <example xml:id="ex.io-ioctl">
      <title>Using <literal>IO#ioctl</literal> to animate <acronym>LED</acronym>s on a keyboard</title> 

      <programlisting><xi:include href="examples/io-ioctl.rb" parse="text"/></programlisting>
    </example>
  </sect1>

  <sect1 xml:id="io.argv">
    <title><literal>ARGV</literal></title> 
    
    <para>The command-line arguments given to a program are available as elements of the <literal>ARGV</literal> <literal>Array</literal>. If <literal>ARGV</literal> is empty, no arguments were provided. Therefore, unlike C, <literal>ARGV[0]</literal> does not hold the program name, which is available as <literal>$0</literal> instead. This <literal>Array</literal> can be modified, so programs may remove an element after they have processed it.</para>

    <example xml:id="ex.argv">
      <title>Using <literal>ARGV</literal> to examine our command-line arguments</title> 

      <programlisting><xi:include href="examples/argv.rb" parse="text"/></programlisting>
    </example> 

    <example xml:id="ex.argv-shell">
      <title>How command-line arguments are interpreted by <literal>ARGV</literal></title>

      <programlisting><xi:include href="examples/argv-shell.txt" parse="text"/></programlisting>
    </example> 
  </sect1> 

  <sect1 xml:id="io.argf"> 
    <title><literal>ARGF</literal></title>
    
    <para><literal>ARGF</literal> is an <literal>IO</literal>-like stream abstracting the contents of a program’s file arguments, representing the concatenation of their contents. An assumption, therefore, is that all arguments in <literal>ARGV</literal> are filenames; the remainder should have been removed.</para>

    <para>Each file is read from in the order they were specified. The filename of the file currently being read is available as <function>ARGF.filename</function>, while <literal>$.</literal> holds the number of the last line read. <function>ARGF.skip</function> advances to the next file, and is a no-op if no more files remain.</para>

    <para><firstterm>In-place mode</firstterm> allows the files in <literal>ARGF</literal> to be modified in-place, possibly after backing them up. It sets <literal>$stdout</literal> to the file being read from <literal>ARGF</literal>, so <literal>Kernel</literal> methods such as <function>puts</function> write their output to this file. It is enabled by either giving the interpreter an <option>-i <replaceable>extension</replaceable></option> switch, or setting <function>ARGF.inplace_mode=</function> to <replaceable>extension</replaceable>. When the argument to <option>-i</option> is omitted, or <replaceable>extension</replaceable> is the empty <literal>String</literal>, no backups are made. Otherwise, before each file is modified it is copied to a filename formed by appending <replaceable>extension</replaceable> to it.</para>

    <para>If <literal>ARGV</literal> is empty, <literal>ARGF</literal> refers to <literal>$stdin</literal> instead. The current filename is set to <literal>-</literal>.</para>
    
    <remark>TODO: Describe Kernel.gets and  Kernel.read, and Kernel.readlines</remark>

    <example xml:id="ex.argf">
      <title><literal>ARGF</literal> encapsulates the file arguments of a program</title>

      <programlisting><xi:include href="examples/argf.rb" parse="text"/></programlisting>
    </example> 

    <example xml:id="ex.argf-shell">
      <title>How <literal>ARGF</literal> interprets command-line arguments</title>

      <programlisting><xi:include href="examples/argf-shell.txt" parse="text"/></programlisting>      
    </example> 
  </sect1>

  <sect1 xml:id="io.ref">
    <title>Reference</title>

    <!-- Use <parameter> instead of <replaceable> -->
    <para><methodsynopsis><type>String</type><methodname>IO.binread</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam choice="opt"><parameter>length</parameter></methodparam><methodparam choice="opt"><parameter>offset</parameter></methodparam></methodsynopsis> Opens the file named <replaceable>filename</replaceable>, reads from it in binary mode, then returns its contents as an ASCII-8BIT-encoded <literal>String</literal>. If <replaceable>length</replaceable> is given, a maximum of this many bytes are read; if <replaceable>offset</replaceable> is also given, reading starts from this byte.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO.copy_stream</methodname><methodparam><parameter>source</parameter></methodparam><methodparam><parameter>destination</parameter></methodparam><methodparam choice="opt"><parameter>length</parameter></methodparam><methodparam choice="opt"><parameter>offset</parameter></methodparam></methodsynopsis> Copies data from <replaceable>source</replaceable> to <replaceable>destination</replaceable>—both of which may be filenames or <literal>IO</literal> streams—returning the number of bytes copied. If <replaceable>length</replaceable> is given, a maximum of this many bytes are copied; if <replaceable>offset</replaceable> is also given, copying starts from this byte instead of the current file position of <parameter>from</parameter>. <remark>Example available in examples/io-copy.rb</remark></para>

    <para><methodsynopsis><type>IO</type><methodname>IO.for_fd</methodname><methodparam><parameter>file_descriptor</parameter></methodparam><methodparam><parameter>mode</parameter></methodparam></methodsynopsis> Aliases <function>IO.new</function>.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO.foreach</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>options</parameter></methodparam><methodparam><parameter>{|line| }</parameter></methodparam></methodsynopsis> Invokes the block with each line found in the file named <replaceable>filename</replaceable>. Lines are separated by <replaceable>separator</replaceable>, but if this value is <literal>nil</literal> the entire file is treated as a single <literal>String</literal>. If <replaceable>limit</replaceable> is given, it is the maximum number of characters to return for each line. If <replaceable>options</replaceable> is given it is an options <literal>Hash</literal> that may contain <literal>:encoding</literal>, <literal>:mode</literal>, and <literal>:open_args</literal> keys.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO.new</methodname><methodparam><parameter>file_descriptor</parameter></methodparam><methodparam><parameter>mode</parameter></methodparam></methodsynopsis> Returns a new <literal>IO</literal> stream for the given file descriptor and access mode. Aliased to <function>IO.for_fd</function>.</para>

    <para><methodsynopsis><type>Object</type><methodname>IO.open</methodname><methodparam rep="repeat"><parameter>argument</parameter></methodparam><methodparam choice="opt"><parameter>{|io| }</parameter></methodparam></methodsynopsis> Instantiates an <literal>IO</literal> object by passing <replaceable>argument</replaceable>(s) to the class’s constructor, then returning the <literal>IO</literal> object. If a block is given, the new <literal>IO</literal> object is passed to it as a parameter, then closed automatically when the block exits; the return value is that of the block.</para> 

    <para><methodsynopsis><type>Array</type><methodname>IO.pipe</methodname><void></void></methodsynopsis> Creates a pipe, the ends of which it returns as an <literal>Array</literal> of <literal>IO</literal> objects. The first element is the read end; the last element is the write end, which is in sync mode.</para>

    <para><methodsynopsis><type>Object</type><methodname>IO.popen</methodname><methodparam><parameter>command</parameter></methodparam><methodparam choice="opt"><parameter>mode="r"</parameter></methodparam></methodsynopsis> Executes a command as a subprocess, opening a pipe to this subprocess’s standard input and output streams, which it returns as an <literal>IO</literal> object. If <replaceable>command</replaceable> is a <literal>String</literal> it names a command in the user’s path, and is subject to shell expansion. If it is a <literal>"-"</literal>, and the platform supports forking, the current process forks: an <literal>IO</literal> pipe connected to the child’s standard input and output streams is returned to the parent; <literal>nil</literal> is returned to the child.</para>

    <para>Otherwise, <replaceable>command</replaceable> is an <literal>Array</literal> of <literal>String</literal>s, the first of which specifies the command name; the remainder, its arguments. The shell is bypassed, so none of these <literal>String</literal>s are subject to shell expansion. If the first element of this <literal>Array</literal> is a <literal>Hash</literal>, it specifies the names and corresponding values of environment variables that should be set in the subprocess. An <link linkend="prc.options-hash">options <literal>Hash</literal></link> may be supplied as the last element of this <literal>Array</literal>.</para>

    <para>If a block is supplied, Ruby’s end of the pipe is passed to it as a parameter, then closed when the block exits. <literal>$?</literal> is set to the exit status of the subprocess, and the value of the block is returned.</para>

    <para>When a block is supplied along with a <replaceable>command</replaceable> of <literal>"-"</literal>, Ruby forks, running the block in both processes. In the parent process the block is passed an <literal>IO</literal> pipe connected to the child’s standard input and output streams; in the child process the block is passed <literal>nil</literal>.</para>

    <para><literal>Kernel.open("|<replaceable>command</replaceable>", <replaceable>mode</replaceable>='r')</literal> behaves like <literal>IO.popen(<replaceable>command</replaceable>, <replaceable>mode</replaceable>='r')</literal>, when <replaceable>command</replaceable> is a <literal>String</literal>. Likewise, <literal>Kernel.open("|-", <replaceable>mode</replaceable>='r')</literal> behaves like <literal>IO.popen("-", <replaceable>mode</replaceable>='r')</literal></para>

    <para><methodsynopsis><type>String</type><methodname>IO.read</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam choice="opt"><parameter>length</parameter></methodparam><methodparam choice="opt"><parameter>offset=0</parameter></methodparam><methodparam choice="opt"><parameter>options</parameter></methodparam></methodsynopsis> Opens the file named <parameter>filename</parameter>, then returns its contents from byte <parameter>offset</parameter> to the end of the file. If <parameter>length</parameter> is given, it is the maximum number of bytes to return. If <parameter>options</parameter> is given it is an <link linkend="prc.options-hash">options <literal>Hash</literal></link>.</para>

    <para><methodsynopsis><type>String</type><methodname>IO.readlines</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>options</parameter></methodparam></methodsynopsis> Returns the lines contained in the file named <parameter>filename</parameter> as an <literal>Array</literal> of <literal>String</literal>s. Lines are delimited by <parameter>separator</parameter>; if this value is <literal>nil</literal> the entire file is treated as a single line. If <parameter>limit</parameter> is given, at most that many characters will be returned for each line. If <parameter>options</parameter> is given it is an <link linkend="prc.options-hash">options <literal>Hash</literal></link>.</para>

    <para><methodsynopsis><type>Array or nil</type><methodname>IO.select</methodname><methodparam><parameter>read</parameter></methodparam><methodparam choice="opt"><parameter>write</parameter></methodparam><methodparam choice="opt"><parameter>error</parameter></methodparam><methodparam choice="opt"><parameter>timeout</parameter></methodparam></methodsynopsis> Aliases <function>Kernel#select</function>.</para>

    <para><methodsynopsis><type>Fixnum</type><methodname>IO.sysopen</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam choice="opt"><parameter>mode</parameter></methodparam><methodparam choice="opt"><parameter>permissions</parameter></methodparam></methodsynopsis> Opens the file named <parameter>filename</parameter> and returns its file descriptor.</para>

    <para><methodsynopsis><type>IO or nil</type><methodname>IO.try_convert</methodname><methodparam><parameter>object</parameter></methodparam></methodsynopsis> Returns <parameter>object</parameter> converted to an <literal>IO</literal> object by calling its <function>#to_io</function> method; or <literal>nil</literal> if this is impossible.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#&lt;&lt;</methodname><methodparam><parameter>object</parameter></methodparam></methodsynopsis> Converts <parameter>object</parameter> to a <literal>String</literal> with <function>#to_s</function>, writes it to the receiver, then returns <literal>self</literal>.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#binmode</methodname><void></void></methodsynopsis> Puts the receiver into binary mode.</para>

    <para><methodsynopsis><type>Enumerator or IO</type><methodname>IO#bytes</methodname><methodparam choice="opt"><parameter>{|byte| }</parameter></methodparam></methodsynopsis> Returns an <literal>Enumerator</literal> of the receiver’s bytes, each represented as a <literal>Fixnum</literal>. If a block is given, yields each byte to the block in turn, then returns the receiver.</para>

    <para><methodsynopsis><type>Enumerator or IO</type><methodname>IO#chars</methodname><methodparam choice="opt"><parameter>{|char| }</parameter></methodparam></methodsynopsis> Returns an <literal>Enumerator</literal> of the receiver’s characters, each represented as a <literal>String</literal>. If a block is given, yields each character to the block in turn, then returns the receiver.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#close</methodname><void></void></methodsynopsis> Closes the receiver’s stream, flushing any pending writes to the operating system.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#close_on_exec?</methodname><void></void></methodsynopsis> Returns <literal>true</literal> if the receiver’s <emphasis>close on exec</emphasis> flag is set; <literal>false</literal> otherwise. Raises <exceptionname>NotImplementedError</exceptionname> if unavailable on this platform.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#close_read</methodname><void></void></methodsynopsis> Closes the read end of a duplex stream such as a pipe. Raises <exceptionname>IOError</exceptionname> if the receiver is not a duplex stream.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#close_write</methodname><void></void></methodsynopsis> Closes the write end of a duplex stream such as a pipe. Raises <exceptionname>IOError</exceptionname> if the receiver is not a duplex stream.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#closed?</methodname><void></void></methodsynopsis> Returns <literal>true</literal> if the receiver is closed—for duplex streams, both ends must be closed; <literal>false</literal>, otherwise.</para>

    <para><methodsynopsis><type>IO or Enumerator</type><methodname>IO#each</methodname><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>{|line| }</parameter></methodparam></methodsynopsis> Enumerates the lines in the receiver. If a block is given, each line is yielded to it in turn; otherwise, an <literal>Enumerator</literal> is returned. Lines are separated by <parameter>separator</parameter>; if this value is <literal>nil</literal>, the entire file is treated as a single line. If <parameter>length</parameter> is given it is the maximum number of characters to return for each line.</para>

    <para><methodsynopsis><type>Enumerator or IO</type><methodname>IO#each_byte</methodname><methodparam choice="opt"><parameter>{|byte| }</parameter></methodparam></methodsynopsis> Aliases <function>IO#bytes</function>.</para>

    <para><methodsynopsis><type>Enumerator or IO</type><methodname>IO#each_char</methodname><methodparam choice="opt"><parameter>{|char| }</parameter></methodparam></methodsynopsis> Aliases <function>IO#chars</function>.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#eof</methodname><void></void></methodsynopsis> Returns <literal>true</literal> if the receiver is at end of file; <literal>false</literal> otherwise. If the receiver is not open for reading, and <exceptionname>IOError</exceptionname> is raised.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#eof?</methodname><void></void></methodsynopsis> Aliases <function>IO#eof</function>.</para>

    <para><methodsynopsis><type>Encoding</type><methodname>IO#external_encoding</methodname><void></void></methodsynopsis> Returns the external encoding associated with the receiver.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#fcntl</methodname><methodparam><parameter>command</parameter></methodparam><methodparam><parameter>argument</parameter></methodparam></methodsynopsis> Issues, via the <function>fcntl(2)</function> system call, the command <parameter>command</parameter> to the receiver’s stream with an argument of <parameter>argument</parameter>. See <xref linkend="io.fcntl"/> for more details.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#fileno</methodname><void></void></methodsynopsis> Returns the file descriptor associated with the receiver. Aliased by <function>IO#to_i</function>.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#flush</methodname><void></void></methodsynopsis> Flushes Ruby’s I/O buffers, returning <literal>self</literal>.</para>

    <para><methodsynopsis><type>0 or nil</type><methodname>IO#fsync</methodname><void></void></methodsynopsis> Flushes the operating system’s I/O buffers via the <function>fsync(2)</function> system call, returning <literal>0</literal>; returns <literal>nil</literal> if this system call is unimplemented.</para>

    <para><methodsynopsis><type>Fixnum or nil</type><methodname>IO#getbyte</methodname><void></void></methodsynopsis> Returns the next byte from the receiver, or <literal>nil</literal> at end of file.</para>

    <para><methodsynopsis><type>String or nil</type><methodname>IO#getc</methodname><void></void></methodsynopsis> Returns the next character from the receiver, or <literal>nil</literal> at end of file.</para>

    <para><methodsynopsis><type>String or nil</type><methodname>IO#gets</methodname><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam></methodsynopsis> Returns the next line from the receiver’s stream, and assigns it to <literal>$_</literal>. Lines are delimited by <parameter>separator</parameter>: a value of <literal>""</literal> is equivalent to <literal>"\n\n"</literal>, while a <literal>nil</literal> value treats the entire file as a single line. If <parameter>limit</parameter> is given, at most that many characters are returned per line. Returns <literal>nil</literal> at end of file.</para>

    <para><methodsynopsis><type>Encoding</type><methodname>IO#internal_encoding</methodname><void></void></methodsynopsis> Returns the internal encoding associated with the receiver.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#ioctl</methodname><methodparam><parameter>command</parameter></methodparam><methodparam><parameter>argument</parameter></methodparam></methodsynopsis> Issues, via the <function>ioctl(2)</function> system call, the command <parameter>command</parameter> to the receiver’s stream with an argument of <parameter>argument</parameter>. See <xref linkend="io.fcntl"/> for more details.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#isatty</methodname><void></void></methodsynopsis> Returns <literal>true</literal> if the receiver is associated with a terminal device; <literal>false</literal> otherwise. Aliased to <function>IO#tty?</function>.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#lineno</methodname><void></void></methodsynopsis> Returns the current line number read from the receiver. If the stream is not open for reading, an <exceptionname>IOError</exceptionname> is raised.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#lineno=</methodname><methodparam><parameter>line</parameter></methodparam></methodsynopsis> Sets the current line number to the <literal>Integer</literal> <parameter>line</parameter>.</para>

    <para><methodsynopsis><type>IO or Enumerator</type><methodname>IO#lines</methodname><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>{|line| }</parameter></methodparam></methodsynopsis> Aliases <function>IO#each</function>.</para>

    <para><methodsynopsis><type>Integer or nil</type><methodname>IO#pid</methodname><void></void></methodsynopsis> Returns the process ID associated with the receiver—as set by <function>IO.popen</function>—or <literal>nil</literal> if there isn’t one.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#pos</methodname><void></void></methodsynopsis> Returns the current byte offset of the receiver.</para>

    <para><methodsynopsis><type>0</type><methodname>IO#pos=</methodname><methodparam><parameter>offset</parameter></methodparam></methodsynopsis> Seeks to the given <literal>Integer</literal> byte offset.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#print</methodname><methodparam rep="repeat" choice="opt"><parameter>object=$_</parameter></methodparam></methodsynopsis> Converts the given objects with <function>#to_s</function>, then writes them to the receiver’s stream. Unless <literal>$\</literal> is <literal>nil</literal>, writes it, too.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#printf</methodname><methodparam><parameter>format</parameter></methodparam><methodparam rep="repeat" choice="opt"><parameter>object=$_</parameter></methodparam></methodsynopsis> Expands the format string, <parameter>format</parameter> and its given arguments with <function>Kernel.sprintf</function>, then writes the result to the receiver’s stream.</para>

    <para><methodsynopsis><type>Object</type><methodname>IO#putc</methodname><methodparam><parameter>object</parameter></methodparam></methodsynopsis> Writes a single byte to its receiver’s stream, then returns its argument. It interprets a <literal>Numeric</literal> argument as a character code, writing the least-significant byte of the character corresponding to its integer part. A non-numeric argument is converted to a <literal>String</literal>, then its least-significant byte written to the stream. Please note the term <emphasis>byte</emphasis>: before Ruby 1.9.3, this method would only ever write a single byte, even when given a multi-byte character; as of 1.9.3, it behaves correctly with multi-byte characters.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#puts</methodname><methodparam rep="repeat" choice="opt"><parameter>object=nil</parameter></methodparam></methodsynopsis> Converts the given objects with <function>#to_s</function>, appends <literal>"\n"</literal> to each of which that do not already end with a newline, then writes them to the receiver’s stream. If <parameter>object</parameter> responds to <function>#to_ary</function>, it is substituted for this method’s return value—i.e., the elements of <literal>Array</literal> arguments are printed one per line.</para>

    <para><methodsynopsis><type>String or nil</type><methodname>IO#read</methodname><methodparam choice="opt"><parameter>length</parameter></methodparam><methodparam choice="opt"><parameter>buffer</parameter></methodparam></methodsynopsis> Reads from the current position in the receiver’s stream through to the end, returning the result. If <parameter>length</parameter> is given, it is the maximum number of bytes to read. If a <literal>String</literal> <parameter>buffer</parameter> is given, the data is read into it. At the end of file, <literal>nil</literal> is returned.</para>

    <para><methodsynopsis><type>Fixnum</type><methodname>IO#readbyte</methodname><void></void></methodsynopsis> Returns the next byte from the receiver’s stream, raising <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>String</type><methodname>IO#readchar</methodname><void></void></methodsynopsis> Returns the next character from the receiver’s stream, raising <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>String or nil</type><methodname>IO#readline</methodname><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam></methodsynopsis> Reads the next line from the receiver’s stream in the manner of <function>IO#gets</function>, raising <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>Array</type><methodname>IO#readlines</methodname><methodparam choice="opt"><parameter>separator=$/</parameter></methodparam><methodparam choice="opt"><parameter>limit</parameter></methodparam></methodsynopsis> Returns the lines from the receiver’s stream as an <literal>Array</literal> of <literal>String</literal>s. Lines are delimited by <parameter>separator</parameter>: a value of <literal>""</literal> is equivalent to <literal>"\n\n"</literal>, while a <literal>nil</literal> value treats the entire file as a single line. If <parameter>limit</parameter> is given, at most that many characters are returned per line.</para>

    <para><methodsynopsis><type>String</type><methodname>IO#readpartial</methodname><methodparam><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>result=""</parameter></methodparam></methodsynopsis> Attempts to read at most <parameter>limit</parameter> bytes from the receiver’s stream without blocking by returning buffered data before reading from the stream. If <parameter>result</parameter> is given it is a <literal>String</literal> to which the read data is appended. Raises <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>String</type><methodname>IO#read_nonblock</methodname><methodparam><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>result=""</parameter></methodparam></methodsynopsis> Sets the <literal>NONBLOCK</literal> flag on the receiver’s file descriptor, then attempts to read at most <parameter>limit</parameter> bytes from the receiver’s stream without blocking. If there is buffered data, that is returned before trying to read from the stream. If the stream can be read from without blocking, it is read from. Otherwise, either <exceptionname>Errno::EWOULDBLOCK</exceptionname> or <exceptionname>Errno::EAGAIN</exceptionname> is raised to indicate that the stream can not be read without blocking. If <parameter>result</parameter> is given it is a <literal>String</literal> to which the read data is appended. Raises <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#reopen</methodname><methodparam><parameter>io</parameter></methodparam></methodsynopsis><methodsynopsis><type>IO</type><methodname>IO#reopen</methodname><methodparam><parameter>filename</parameter></methodparam><methodparam><parameter>mode</parameter></methodparam></methodsynopsis> Re-associates the receiver with the given I/O stream, <parameter>io</parameter>, or a new stream for a file named <parameter>filename</parameter> that is opened with access mode <parameter>mode</parameter>. Due to the way I/O operations perform buffering, reopening a stream—especially one that has already been read from—can lead to unexpected behaviour. See <xref linkend="io.buffering"/> and <biblioref linkend="bib.ruby-core-28281"/> for more details.</para>

    <para><methodsynopsis><type>0</type><methodname>IO#rewind</methodname><void></void></methodsynopsis> Resets both the position of the receiver’s stream and its line number to <literal>0</literal>.</para>

    <para><methodsynopsis><type>0</type><methodname>IO#seek</methodname><methodparam><parameter>offset</parameter></methodparam><methodparam choice="opt"><parameter>whence=File::SEEK_SET</parameter></methodparam></methodsynopsis> Seeks to <parameter>offset</parameter> in the receiver’s stream. See <xref linkend="io.position"/> for an explanation of <parameter>whence</parameter>.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#set_encoding</methodname><methodparam><parameter>external</parameter></methodparam><methodparam choice="opt"><parameter>internal=external</parameter></methodparam></methodsynopsis><methodsynopsis><type>IO</type><methodname>IO#set_encoding</methodname><methodparam><parameter>string</parameter></methodparam></methodsynopsis> Sets the external and internal encodings of the receiver’s stream. Both <parameter>external</parameter> and <parameter>internal</parameter> may be <literal>Encoding</literal> objects or encoding names as <literal>String</literal>s. The <parameter>string</parameter> contains the name of the external encoding, a colon, then the name of the internal encoding; or, just one encoding name for both.</para> 

    <para><methodsynopsis><type>File::Stat</type><methodname>IO#stat</methodname><void></void></methodsynopsis> Returns a <link linkend="fil.file-stat"><literal>File::Stat</literal></link> object for the receiver’s stream.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#sync</methodname><void></void></methodsynopsis> Returns <literal>true</literal> if the receiver is in <emphasis>sync mode</emphasis>; <literal>false</literal>, otherwise.</para>

    <para><methodsynopsis><type>true or false</type><methodname>IO#sync=</methodname><methodparam><parameter>boolean</parameter></methodparam></methodsynopsis> Sets the <emphasis>sync mode</emphasis> of the receiver to <parameter>boolean</parameter>—<literal>true</literal> or <literal>false</literal>—which it then returns.</para>

    <para><methodsynopsis><type>String</type><methodname>IO#sysread</methodname><methodparam><parameter>limit</parameter></methodparam><methodparam choice="opt"><parameter>buffer</parameter></methodparam></methodsynopsis> Reads at most <parameter>limit</parameter> bytes from the receiver’s stream, bypassing Ruby’s I/O buffer, returning them as a <literal>String</literal>. If the <literal>String</literal> <parameter>buffer</parameter> is given, it has the read data appended. Raises <exceptionname>SystemCallError</exceptionname> on error and <exceptionname>EOFError</exceptionname> at end of file.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#sysseek</methodname><methodparam><parameter>offset</parameter></methodparam><methodparam choice="opt"><parameter>whence=File::SEEK_SET</parameter></methodparam></methodsynopsis> Behaves as <function>IO#seek</function> but bypasses Ruby’s I/O buffer.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#tell</methodname><void></void></methodsynopsis> Aliases <function>IO#pos</function>.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#to_i</methodname><void></void></methodsynopsis> Aliases <function>IO#fileno</function>.</para>

    <para><methodsynopsis><type>IO</type><methodname>IO#to_io</methodname><void></void></methodsynopsis> Returns the receiver.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#ungetbyte</methodname><methodparam><parameter>byte</parameter></methodparam></methodsynopsis> Pushes back the given byte(s) onto the receiver’s read buffer. <parameter>byte</parameter> may be a <literal>String</literal> or a single byte given as a <literal>Fixnum</literal>.</para>

    <para><methodsynopsis><type>nil</type><methodname>IO#ungetc</methodname><methodparam><parameter>character</parameter></methodparam></methodsynopsis> Pushes back the characters contained in the <parameter>character</parameter> <literal>String</literal> onto the receiver’s read buffer.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#write</methodname><methodparam><parameter>object</parameter></methodparam></methodsynopsis> Converts <parameter>object</parameter> to a <literal>String</literal> with <function>#to_s</function>, writes it to the receiver’s stream, then returns the number of bytes written.</para>

    <para><methodsynopsis><type>Integer</type><methodname>IO#write_nonblock</methodname><methodparam><parameter>object</parameter></methodparam></methodsynopsis> Sets the <literal>File::NONBLOCK</literal> flag on the receiver’s stream then behaves as <function>IO#write</function>. If a write would block, either <exceptionname>Errno::EWOULDBLOCK</exceptionname> or <exceptionname>Errno::EAGAIN</exceptionname>. If the platform doesn’t support non-blocking writes for this type of <literal>IO</literal> object, <exceptionname>Errno::EBADF</exceptionname> is raised.</para>
  </sect1>
</chapter>
<!DOCTYPE html>
<!-- vim: set fdm=indent tw=78: --> 
<html>
  <head>
    <title>Classes</title>
    <meta charset="utf-8"/>
    <!-- <script src="http://html5-now.appspot.com/base2-legacy.js"></script> 
    <script src="http://html5-now.appspot.com/html5-now.js"></script>
    -->
  </head>
  <body>
<h2>Classes</h2>

  <!-- http://blog.rubybestpractices.com/posts/rklemme/018-Complete_Class.html -->
  <!-- What does it mean to dup or clone a class? -->

  <p>A <dfn id=class>class</dfn> is a <i>classification</i> of objects. It
  constitutes a template from which such objects can be constructed. Hence
  <code>3</code> and <code>198705</code> are both instances of the
  <code>Integer</code> class. Their data (i.e. their numerical value) differs
  but they behave as any other instance of their class. <!-- Not necessarily
  true --> That is, by their nature as integers both objects can be multiplied
  by another integer, and both are either odd or even, etc.
  <!-- snip etc. -->

  <aside>
    The term <i>class</i> is roughly analogous to its biological definition
    where it denotes a taxonomic rank, however this analogy does not extend to
    subclasses. That is, a subclass of a class is termed a <i>subclass</i>;
    not an <i>order</i>.
  </aside>

  <h3>Names</h3>

    <!-- Mention the Class::Subclass name qualification here or in Constants
    section? In same place mention Ruby's preference for flat hierarchies -->

    <!-- Scope of constants -->
    <p>A non-anonymous <!-- Does it make sense to introduce anonymous classes
    here? --> class is named with a constant, i.e. an identifier
    which begins with an ASCII capital letter. <!-- Class#name returns name as
    String; nil for anonymous classes --> <!-- Explain that names are defined
    by a blacklist -->

    <h4>Rules</h4>

      <p>The name of class must: 
        <ul>
          <li>Begin with an uppercase ASCII letter (A-Z) (U+0041..U+005A).
          <li>Not contain a colon (U+003A).
          <li>Not contain an ASCII space character (U+0020)
        </ul>
        <!-- FIXME: Derive and enumerate rules -->

      <p>More generally, a class name consists of an uppercase ASCII
      character, optionally followed by a sequence of other alphanumeric
      characters

      <aside class=warning>
        Class names containing non-ASCII characters cannot be referred to from
        source files using a different encoding. For example, a class name
        containing character U+03BB (<i>GREEK SMALL LETTER LAMDA</i>) can only be
        referenced from source files using the UTF-8 source encoding. <!-- FIXME:
        What about other Unicode character sets? -->
       </aside>

    <h4>Conventions</h4>

      <p>Conventionally class names use camel-case capitalization: The initial letter of each word is
      capitalized, and spaces between the words are removed. For example:
      <code>RubyProgrammingLanguage</code> or <code>NutsAndBolts</code>.</p>

      <p>A class name is a constant. The use of camel-case for class names and uppercase for constant
      names ensures that the two don't clash.

  <h3>Inheritance</h3>

    <p>A class <dfn title=inheritance>inherits</dfn> behaviour and certain
    state <!-- is state inherited? --> from another class called its <dfn
      title=superclass>superclass</dfn>. The exception is
    <code>BasicObject</code>, which sits at the top of the class hierarchy
    <!-- Discuss this concept? --> so doesn’t have a superclass. The default
    superclass is <code>Object</code>. Classes that inherit from a given class
    are its <dfn title=subclasses>subclasses</dfn>.<!-- reword this --> A
    subclass is, therefore, a specialisation of its superclass.
    
    <section>
      <h4>Superclass</h4>
        
        <p>The superclass is a class object. It is typically specified as a
        constant literal, but can be any expression evaluating to the same.
        <code>Class#superclass</code> returns the receiver’s superclass as a
        <code>Class</code> object, or <code>nil</code> if the receiver is
        <code>BasicObject</code>.
        
        <!-- Example of subclassing a Struct, i.e. class S < Struct.new(:foo,
        :bar) -->

        <p>A class’s superclass is fixed for its lifetime. (A new class may be
        created with the same name and a different a superclass, of course).
    </section>

    <p>Inheritance merely determines the initial behaviour of a class; the
    subclass can diverge by defining, redefining, or removing methods, and
    modifying <!-- must we talk about the modification of constants? --> and
    undefining or constants.

    <p>Inheritance occurs because the method— and constant—lookup  <!--
    is this all? --> algorithms consider the superclass when unable to resolve
    the given name against the current class. Methods and constants are not
    copied to subclasses. 

    <p>It is worth stating explicitly that instance variables and class
    variables are <em>not</em> inherited. <a href=#refFLAN08
      class=ref>Flanagan &amp; Matsumoto</a> (pp. 239–240) note a corollary:
    <q>If a subclass uses an instance variable with the same name as a
      variable used by one of its ancestors, it will overwrite the value of
      its ancestor’s variable.</q> 

    <p>Class variables are, however, <i>shared</i> between subclasses: the
    same variable is accessed by all; it is neither duplicated nor shadowed.
    Therefore, the modification of a class variable defined in a superclass
    affects the superclass along with any sibling classes.

    <!-- Is this the right place to discuss constants? -->

    <p>Constants are inherited in a similar way to methods. A subclass may
    access his superclass’s constants by referring to them with either their
    fully— or non—qualified name. If a subclass assigns to an unqualified
    constant name defined in his superclass, a new constant with that name is
    defined in the subclass. <!-- Refer to constant-lookup algorithm
    description -->

    <h4>The <code>Class#inherited</code> hook</h4>  
    <!-- def Object.inherited -->
  <h3>Creation</h3>

    <h4>The <code>class</code> Keyword</h4>

      <p>The <code>class <var>name</var> &lt; <var>superclass</var>…end</code>
      expression opens a class named <var>name</var>. If the constant
      <var>name</var> is already defined it must refer to an existing class,
      otherwise a <code>TypeError</code> is raised.  If <var>name</var> was
      previously undefined, it is created as a <code>Class</code> object. The
      <code>&lt; <var>superclass</var></code> portion may be omitted, in which
      case the <var>superclass</var> defaults to <code>Object</code>.
      <var>superclass</var> may be any expression that evaluates to a
      <code>Class</code> object. 

      <section>
        <h5>Reopening Classes</h5>

          <p>If <code>class</code> is used with the name of a pre-existing class
          that class is <i>re-opened</i>. If a method is defined in a re-opened
          class with the same name as a pre-existing method in the same class the
          old method is overwritten with the new.

          <figure id=reopened-class>
            <dt>Re-defining a method in an existing class</dt>
            <dd>
              <pre><code>
                'hello'.size #=&gt; 5
                class String
                  def size
                    'How long is a piece of string?'
                  end
                end
                'hello'.size #=&gt; 'How long is a piece of string?'
              </code></pre>
            </dd>
          </figure>  

          <p>Classes can be made immutable, effectively preventing them from
          being reopened by freezing the class object. Frozen classes raise
          <code>RuntimeError</code>s when methods are defined, or variables
          maniplauted, in their context. 
      </section>

      <p>The class body, which may be empty, is the elliptical region in the
      expression. It introduces a new context in which <code>self</code> refers
      to the class.

      <figure id=class-keyword>
        <dt>Usage of the <code>class</code> keyword to <i>open</i> a class named
        <code>Dog</code></dt>
        <dd>
          <pre><code>
          class Dog
          end
          </code></pre>
        </dd>
      </figure>

    <h4><code>Class.new</code></h4>
  
      <p>The <code><var>name</var> = Class.new do…end</code> constructor may
      be used to similar effect. The principle difference being that existing
      classes are overwritten rather than reopened.

      <figure id=class-new>
        <dt>Usage of the <code>Class.new</code> constructor to create a class
        named <code>Dog</code></dt>
        <dd>
          <pre><code>
          Dog = Class.new
          </code></pre>
        </dd>
      </figure>

      <section>
        <h5>Anonymous Classes</h5>

          <p>When a constant is used as a class name it has global scope. This
          gives rise to the characteristic described above in <i>Reopening
            Classes</i>. If this behaviour is not desirable, a class can be
          made anonymous by assigning the value of <code>Class.new</code> to a
          local variable, thus restricting the class to the local scope.
          Subsequently assigning this variable to a constant, names the class.
          <!-- Example -->
          
          
          <figure id=anonymous-class>
          <dt>Creating an anonymous class with <code>Class.new</code></dt>
            <dd>
              <pre><code>
                dog = Class.new
                dog.class_eval do
                  def bark
                    :woof
                  end
                end
                dog.new.bark #=&gt; :woof
              </code></pre>
            </dd>
          </figure>

      </section>

    <h3>Nesting</h3>

      <p>A class may be defined within the body of another class. The fully
      qualified name of the inner class is
      <code><var>outer</var>::<var>inner</var></code>, where <var>outer</var> is
      the name of the enclosing class, and <var>inner</var> that of the
      enclosed. This <dfn title=nesting>nesting</dfn> behaviour is primarily
      used for namespacing. Modules are another alternative.

      <p>Since class names are constants and constants are inherited, classes
      defined at the top level, as core classes conventionally are, can be
      referred to by their unqualified name throughout the inheritance
      hierarchy. However, if the name is shadowed at an intervening level of
      the hierarchy, the unqualified name refers to the shadowed class/module.
      For example, if a class named <code>Products::String</code> was defined,
      its subclasses that used the <code>String</code> class would be
      referring to <code>Products::String</code>; not the core
      <code>String</code> class (which would need referring to as
      <code>::String</code>).

      <p>Classes may, therefore, re-purpose the names of their ancestors to
      create materially different classes, as above, or to customise them
      through inheritance.<!-- examples of both --> In either case their changes
      will only affect themselves and their children; other classes using the
      unqualified name will be unaffected. Regardless, re-using names in this
      manner can obfuscate code, so should only be done intentionally with due
      consideration of the implications.

      <p>A class’ nesting bears no relation to its superclass. A nested class
      defined without an explicit superclass does not inherit from its
      enclosing class; it inherits from <code>Object</code>, as normal.

      <p>The nesting of a class is returned as an <code>Array</code> of
      <code>Class</code> objects by <code>Module#nesting</code>, where the
      first element is the innermost class, and the last the outermost.

  <h3>Context</h3>
  <!-- class_eval / class_exec -->
  <h3>Structs</h3>
  <h3>Singletons</h3>
  <h3>Class Instance Variables</h3>
  <!--  Classes are objects and can have instance variables just as other objects can. The
instance variables of a class—often called class instance variables—are not the same as
class variables. But they are similar enough that they can often be used instead of class
variables.
An instance variable used inside a class definition but outside an instance method
definition is a class instance variable. Like class variables, class instance variables are
associated with the class rather than with any particular instance of the class. A
disadvantage of class instance variables is that they cannot be used within instance
methods as class variables can. Another disadvantage is the potential for confusing
them with ordinary instance variables. Without the distinctive punctuation prefixes, it
may be more difficult to remember whether a variable is associated with instances or
with the class object.
One of the most important advantages of class instance variables over class variables
has to do with the confusing behavior of class variables when subclassing an existing
class. We’ll return to this point later in the chapter.
Let’s port our statistics-gathering version of the Point class to use class instance varia-
bles instead of class variables. The only difficulty is that because class instance variables
cannot be used from instance methods, we must move the statistics gathering code out
of the initialize method (which is an instance method) and into the new class method
used to create points:
     class Point
       # Initialize our class instance variables in the class definition itself
       @n = 0               # How many points have been created
       @totalX = 0          # The sum of all X coordinates
       @totalY = 0          # The sum of all Y coordinates
       def initialize(x,y) # Initialize method
         @x,@y = x, y       # Sets initial values for instance variables
       end
       def self.new(x,y)    # Class method to create new Point objects
         # Use the class instance variables in this class method to collect data
         @n += 1            # Keep track of how many Points have been created
         @totalX += x       # Add these coordinates to the totals
         @totalY += y
         super              # Invoke the real definition of new to create a Point
                            # More about super later in the chapter
       end
                                                                  7.1 Defining a Simple Class | 231
      # A class method to report the data we collected
      def self.report
        # Here we use the class instance variables in a class method
        puts "Number of points created: #@n"
        puts "Average X coordinate: #{@totalX.to_f/@n}"
        puts "Average Y coordinate: #{@totalY.to_f/@n}"
      end
    end
Because class instance variables are just instance variables of class objects, we can use
attr, attr_reader, and attr_accessor to create accessor methods for them. The trick,
however, is to invoke these metaprogramming methods in the right context. Recall that
one way to define class methods uses the syntax class << self. This same syntax allows
us to define attribute accessor methods for class instance variables:
    class << self
      attr_accessor :n, :totalX, :totalY
    end
With these accessors defined, we can refer to our raw data as Point.n, Point.totalX,
and Point.totalY. -->

  <h3>Class Variables</h3>

  <h3>Eigenclasses</h3>
  <h3>Reflection</h3>
  <ol>
    <li>is_a? / === / kind_of?
    <li>class
    <li>ancestors
    <li>name
    <li>#methods / #instance_methods / etc.
    <!-- Do the following belong here or in Methods? -->
    <li>method_added
    <li>singleton_method_added
    <li>method_removed / singleton_method_removed
    <li>method_undefined / singleton_method_undefined
    <li>const_missing (kind of like class_missing...)
    <li>Enumerating classes with #constants (Code example from understand).
    Right heading? )
  <h3>Type</h3> 

    <p><q>In many object-oriented languages, class names are used…for the type
      of objects generated from the class.</q> <a class=ref
      href=#refBRUCE02>Bruce</a> (p 20). <a href=#refKLAS95 class=ref>Klas
      &amp; Schrefl</a> concur: <q>A class…defines…the type of [its]
      instances</q> (p 10). Applying this notion to Ruby is problematic
    because while it is certainly possible for a method to dynamically <i>type
      check</i> its arguments with the
    <code>Kernel#is_a?(<var>class</var>)</code> predicate, this approach is
    both insufficient and unnecessary. 

    <p>It is insufficient because an object’s class is not indicative of its
    suitability for a specific role. Class-based type checking rests on
    the premise that all objects of a given type will respond to the same
    messages in the same fashion. However, Ruby’s classes may be modified at
    will—allowing their methods to be redefined or removed—so two objects of
    the same class will not necessarily provide the same behaviour. Similarly,
    methods may be defined on, or removed from, individual objects, again
    breaking the assumption.

    <p>It is unnecessary because Ruby offers a superior, meritocratic
    alternative called “duck typing” (<a href=#refTHOM09 class=ref>Thomas et
      al.</a>, p 372): if an object responds to the messages it would be sent
    in the course of a computation it constitutes suitable input. The
    yardstick is ability; not class.
     
    <p>An optimistic method simply assumes that its arguments are suitable;
    allowing them to raise a <code>NoMethodError</code> if sent a message they
    don't understand. This allows for particularly flexible <abbr
      title="Application Programming Interface">API</abbr>s at the cost of
    potentially obscure error messages for nonsensical arguments.
    
      <!--
      def m(a)
        a.roger
      rescue NoMethodError
        raise ArgumentError
      end
      -->
    
    <p>More typically, the
    <code>Kernel#respond_to?(<var>selector</var>)</code> predicate is used to
    determine the suitability of an object. For instance, a method may raise
    an <code>ArgumentError</code> unless its argument responds to
    <code>:&lt;&lt;</code>.
    
    <p>A refinement on the above is to send an argument the appropriate
    <code>:try_convert</code> message, raising an exception if
    <code>nil</code> is returned. <!-- Think about this more fully. Link with
    .try_convert explanation -->
    
    <!-- Discuss meaning of TypeError -->
    <!-- Note that "respond to" doesn't necessarily imply the object will
    accept the arguments its given (mention #understand? idea). -->
    <!-- Discuss somewhere the concept of selectors having a shared meaning
    -->
  </body>
</html>

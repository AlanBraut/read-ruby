<!DOCTYPE html>
<html>
  <head>
    <title>Ruby</title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <h1>Ruby</h1>
      
      <h2>Objects</h2>
      <p>Ruby embodies the object-orientated paradigm. She holds as
      fundamental that <q>everything is an object</q>.

      <p>An <dfn id=object>object</dfn> is a compilation of data
      (attributes) and behaviour (methods) which encapsulate a specific
      <i>instance</i> of a <i>class</i>. The String <code>"hello"</code> and
      the Integer <code>3</code> are both examples of objects, and instances
      of the <i>String</i> and <i>Integer</i> classes, respectively. They
      constitute data (<q>hello</q> and <q>3</q>, respectively) and behaviour
      relevant to that data.

      <p>A <dfn id=class>class</dfn> is a <i>classification</i> of objects. It
      constitutes a template from which such objects can be constructed. Hence
      <code>3</code> and <code>198705</code> are both instances of the
      <code>Integer</code> class. Their data (i.e. their numerical value)
      differs but they behave as any other instance of their class. That is,
      by their nature as integers both objects can be multiplied by another
      integer, and both are either odd or even, etc.
      
      <aside>The term <i>class</i> is roughly analogous to its biological
      definition where it denotes a taxonomic rank, however this analogy does not
      extend to subclasses. That is, a subclass of a class is termed a
      <i>subclass</i>; not an <i>order</i>.</aside>
      
      <h2>Methods</h2>
        
        <p>A <dfn id=method>method</dfn> is a named block of code associated
        with an object. For now we will define <i>block of code</i> as a
        sequence of one or more statements.

        <h3>Communication Through Message Sending</h3>

        <p>An object communicates with another by sending it a <dfn
          id=message>message</dfn>. The simplest message is a
        <code>Symbol</code>. Upon receiving such a message the recipient
        object attempts to invoke a method of the same name on itself. For
        example, sending a <code>String</code> object a message of
        <code>:size</code> causes that object to invoke the
        <code>String#size</code> method.

        <!-- TODO: Mention telegram idea -->

        <p>At this stage we will assume a 1∶1 mapping between messages and
        methods.  That is, for a given object, we will consider as analogous
        the sending of a message, <var>m</var>, and the invoking of a method,
        <var>m</var>. Therefore the phrases <q>sending a message</q> and
        <q>invoking a method</q> are equivalent.
        <!-- TODO: Connect with explanation of method_missing -->

        <figure id=sending-a-message>
        <dt>Sending the message <code>:size</code> to a <code>String</code>
        object. The first example uses the standard method calling syntax; the
        second uses <code>Object#send</code>.
          <dd>
            <pre><code>
              "wool".size #=&gt; 4
              "wool".send(:size) #=&gt; 4
            </code></pre>  
          </dd>
        </figure>

<!-- TODO: Move instructions for _creating_ these methods out of these
sections -->

        <h3>Instance Methods</h3>

        <p>An instance method is a behaviour of an object. It is typically
        created with the <code>def</code> keyword in the context of a class.
        
        <aside>
        It is conventional to employ the <code>Class#method</code> notation
        when referring to instance methods in documentation and prose. For
        example: <code>Integer#even?</code>.
        </aside>
        
        <figure id=def-instance-method>
        <dt>Defining an instance method named <code>bark</code> for the <code>Dog</code> class
          with the <code>def</code> keyword.
          <dd>
            <pre><code>
              class Dog
                def bark
                  :woof
                end
              end
              Dog.new.bark #=&gt; :woof
            </code></pre>  
          </dd>
        </figure>

        <h3>Singleton Methods</h3>

        <p>A singleton method is associated with a class as opposed to its
        instances. Indeed, it is typically a <i>factory method</i>: a constructor of
        instances. They are also created with the <code>def</code> keyword,
        but their names are prefixed with <code>self.</code> to denote their
        singleton status.
        
        <figure id=def-singleton-method>
        <dt>Defining a singleton method named <code>breed</code> for the
        <code>Dog</code> class with the <code>def</code> keyword.
          <dd>
            <pre><code>
              class Dog
                def self.breed
                  [new, new]
                end
              end
              Dog.breed #=&gt; [#<Dog:0x95cb530>, #<Dog:0x95cb508>]
            </code></pre>  
          </dd>
        </figure>

        <aside>
        It is conventional to employ the <code>Class.method</code>
        notation when referring to singleton methods in documentation and
        prose. For example: <code>File.exists?</code>.
        </aside>

          <h3>Method Invocation</h3>

          <p>To send a message, <var>m</var>, to an object, <var>o</var>, is
          to <dfn id=invoke-method>invoke</dfn> <var>m</var> on <var>o</var>.
          
          <p>The simplest expression for invoking a method consists of only
          the method’s name: <code><var>m</var></code> invokes method
          <var>m</var>. Omitting the name of the object on which <var>m</var>
          should be invoked causes an implicit receiver of <code>self</code>
          to be assumed. <code>self</code> is a special variable which evaluates
          to the current object. <!-- TODO: Where to describe this in more
          detail? --> Its value is initially
          <code>Object</code> so a method invoked without an explicit
          receiver outside of a class definition is actually invoked on
          <code>Object</code>. <!-- TODO: Explain how 'puts "glark"' works in
          this context? -->

          <p>The receiver can be specified explicitly with the
          <code><var>receiver</var>.<var>method</var></code> syntax, i.e. the
          method name is prefixed with the receiver name followed by a period
          (U+002E: <code>.</code>). <var>receiver</var> is an expression which
          evaluates to an object. For example,
          <code>"esrever".reverse</code> invokes the method
          <code>:reverse</code> on the <code>String</code>
          <code>"esrever"</code>. <code>(1 + 2).odd?</code> invokes
          <code>:odd?</code> on the <code>Fixnum</code> <code>3</code>.

          <aside class=note>
            An alternative to the
            <code><var>receiver</var>.<var>method</var></code> syntax is
            <code><var>receiver</var>::<var>method</var></code>, where the
            period (<code>.</code>) is replaced with a double colon
            (<code>::</code>). However, the latter syntax has fallen out of
            favour due to the confusion it creates between method invocations
            and constant reference expressions. It is not recommended for use
            in new code.
          </aside>

          <p>In either case a <code>NoMethodError</code> is raised if the
          named method does not exist.

          <p>A message may be accompanied by one or more <dfn
            id=method-arguments>arguments</var>: variables to be used in the
          method’s computations. Arguments are supplied as a parenthesized
          list of variables separated by commas:
          <code><var>receiver</var>.<var>message</var>(<var>arg<sub>0</sub>,…,<var>arg</var><sub>n</sub>)</code>.
            For example, to send the <code>String</code>
            <code>"haystack"</code> the <code>:include?</code> message with
            the argument <code>"needle"</code>:
            <code>"haystack".include?("needle")</code>.

          <p>If a method is invoked with a parameter list other than what it
          expects it raises an <code>ArgumentError</code>.
          
          <p>A method invocation followed by a block literal causes the block
          to be passed to the method. A block literal may be enclosed in curly
          braces (<code>{</code>…<code>}</code>) or a
          <code>do</code>…<code>end</code> construct. These forms are
          semantically equivalent, however it is conventional to use the
          former for short blocks that fit on a single line, and the latter
          for multi-line blocks.

     <h3>Element Reference</h3>

     <p>The <code>[<var>subscript</var>]</code> notation for referring to an
     element of an <code>Array</code> or <code>Hash</code> is called <dfn
       id=element-reference>element reference</dfn> syntax. It is a special
     case of the method invocation syntax because it invokes a method named
     <code>:[]</code> on the receiver, passing in the contents of
     <code>[</code>…<code>]</code> as arguments. For example,
     <code>[1,2,3][0]</code> is equivalent to <code>[1,2,3].[](0)</code>.

     <p>Indeed, any object may define a method named <code>:[]</code>, allowing
     it to be used in this fashion. 

     <!-- TODO: Example of a #[] method -->

     <p>Similarly, assignment to an element reference invokes a method named
     <code>:[]=</code>. For example, where <code>fruit</code> is a
     <code>Hash</code>, <code>fruit[:apple] = :red</code> is
     equivalent to <code>fruit.[]=(:apple, :red)</code>.

      <h3>Attribute Accessors and Setters</h3>

      <p>A method which accepts no arguments and returns the value of the
      corresponding instance variable, or <dfn
        id=attribute>attribute</dfn>, in the receiver is sometimes referred to as an <dfn
        id=attribute-accessor>attribute accessor</dfn> method. For
      example, <code>person.name</code> is said to return the
      <code>name</code> attribute of the <code>person</code> object.
      
      <!-- TODO: Link with discussion of _attr_ -->
      
      <p>There is not necessarily a correspondence between the accessor’s
      name and that of the corresponding instance variable. There is not,
      for that matter, necessarily a corresponding instance variable at
      all: the attribute value might have been computed dynamically, for
      example. 

      <p>An instance method whose name is that of an attribute accessor
      but suffixed with an equals sign (<code>=</code>) and accepts an
      argument, is called an <dfn id=attribute-setter>attribute
        setter</dfn>. It sets the attribute to the value supplied.

        <!-- TODO: Diagram -->

        <!-- TODO: Lookup rules? -->

        <p>A message may be accompanied by a series of variables, or <dfn
          id=method-arguments>arguments</dfn>, to be understood in the context
        of the message. 
        <p>A method is invoked for the side-effect it causes, the value it
        returns, or a combination of these factors. Note that this definition
        encompasses <i>accessor</i> and <i>mutator</i> methods; Ruby makes no
        such distinction.


          <h3>Return Values</h3>

          <p>A method is a expression so always returns a value. This is
          <code>nil</code> if the method was defined without a body; the last
          statement executed otherwise. Multiple values can be returned by
          using an <code>Array</code> as the last statement. 

          <figure id=def-implicit-return>
            <dt>A method which returns the Symbol <code>:to_sender</code>
            <dd>
              <pre><code>
                def elvis
                  :to_sender
                end
              </code></pre>
            </dd>
          </figure>

          <figure id=def-implicit-return-multiple>
          <dt>A method which returns multiple values as an <code>Array</code>.
            <dd>
              <pre><code>
                def elvis
                  [:to_sender, :hound_dog]
                end
                elvis #=&gt; [:to_sender, :hound_dog]
              </code></pre>
            </dd>
          </figure>

          <p>A <code>return</code> statement causes <code>nil</code> to be
          immediately returned to the caller. <code>return</code> may be
          followed by an argument in which case its value is returned instead.
          If multiple arguments are given they will be returned as an
          <code>Array</code>. 

          <figure id=def-explicit-return-multiple>
          <dt>A method which explicitly returns multiple values.
            <dd>
              <pre><code>
                def elvis
                  return :to_sender, :hound_dog
                  # Not reached
                end
                elvis #=&gt; [:to_sender, :hound_dog]
              </code></pre>
            </dd>
          </figure>

          <p>This gives rise to two conventions:
            <ul>
              <li>A method uses a <code>return</code> statement iff it may
              return before its last statement.
              <li>A method intended to return a value has that value as its
              last statement
            </ul>
          </p>
          
          <!-- TODO: Mention Object#tap -->


          <h3>Names</h3>

            <h4>Conventions</h4>

            <p>Method names begin with a lowercase letter. If they consist of
            multiple words underscores (U+005F: <code>_</code>) are used to
            separate.

            <aside>
              It is legal for a method name to begin with an uppercase letter,
              but then they may be confused with constants or class names. In
              fact, several core classes have methods named this way for
              precisely this reason: they provide a syntactical shortcut for
              constructing instances. For example, <code>Array()</code> is a
              method of <code>Kernel</code> which coerces its argument into an
              <code>Array</code> object.
            </aside>
            
            <p><i>Predicate</i> methods (those which return either
            <code>true</code> or <code>false</code>) typically use a <code>?</code>
            suffix. For example: <code>Integer#even?</code>. A method with a
            <code>?</code> suffix is not necessarily a predicate, however;
            <code>Float#infinite?</code>, for example, returns
            <code>nil</code> for finite numbers, <code>-1</code> for negative
            infinity, or <code>+1</code> for positive infinity. <!-- TODO: Use
            infinity symbols -->

            <p>The <code>!</code> suffix (colloquially called a <i>bang</i>)
            is used <q>…to mark a method as special. It doesn’t necessarily
              mean that it will be destructive or dangerous, but it means that
              it will require more attention than its alternative.</q> <a
              class=ref href=#refBROWN09>[Brown,
            2009, pp. 52]</a>. <q>Usually, the method without the exclamation
            mark returns a modified copy of the object it is invoked on, and
            the one with the exclamation mark is a mutator method that alters
            the object in place.</q> <a class=ref href=#refFLAN08>[Flanagan
            &amp; Matsumoto, 2008, pp. 7]</a> 

            <h4>The <code>=</code> Suffix</h4>
            
            <p>Methods named with a <code>=</code> suffix can be used in
            assignment statements as <i>lvalues</i>. That is, a method defined
            as <code>name=(value)</code> on object <code>obj</code> can be
            invoked as <code>obj.name = value</code> or
            <code>obj.name=(value)</code>.     

            <aside class=warning>
            <p>The syntax <code>name = value</code> is therefore ambiguous. Is
            the intent to assign the value <code>value</code> to the local variable
            <code>name</code> or to invoke the method named <code>name=</code>
            with <code>value</code> as the argument?

            <p>The resolution is to always invoke a <code>=</code>-suffixed method with an explicit
            receiver, such as <code>self</code>. Alternatively, make it
            explicit that you are invoking a method with the
            <code>name=(value)</code> syntax.
            </aside>
           
            <!-- TODO: Unite this with section on attribute setters -->
          <h3>Defining</h3>

          <p>A method consists of a name, an optional parameter list, and a
          body. Names have already been discussed, the parameter list is
          explained in <i>Arguments</i> below. The <dfn
            id=method-body>body</dfn> is a sequence of statements terminated
          with the <code>end</code> keyword.

          <figure id=def-syntax>
          <dt>The syntax of a method definition.
            <dd>
              <pre><code>
                def <var>name</var> (<var>parameters</var>)
                  <var>body</var>
                end
              </code></pre>
            </dd>
          </figure>

          <!-- TODO: Returns value which is not a method object -->

          <!-- TODO: Distinguish between defining instance and singleton
          methods -->
The methods we’ve defined so far are all global methods. If we place a def statement
like the ones shown earlier inside a class statement, then the methods that are defined
are instance methods of the class; these methods are defined on all objects that are
instances of the class. (Classes and instance methods are explained in Chapter 7.)
It is also possible, however, to use the def statement to define a method on a single
specified object. Simply follow the def keyword with an expression that evaluates to
an object. This expression should be followed by a period and the name of the method
to be defined. The resulting method is known as a singleton method because it is
available only on a single object:
      o = "message"    # A string is an object
      def o.printme    # Define a singleton method for this object
        puts self
      end
      o.printme        # Invoke the singleton
Class methods (covered in Chapter 7) such as Math.sin and File.delete are actually
singleton methods. Math is a constant that refers to a Module object, and File is a constant
that refers to a Class object. These two objects have singleton methods named sin and
delete, respectively.

Ruby implementations typically treat Fixnum and Symbol values as immediate values
rather than as true object references. (See §3.8.1.1.) For this reason, singleton methods
may not be defined on Fixnum and Symbol objects. For consistency, singletons are also
prohibited on other Numeric objects.

        <h3>Undefining</h3>
        
        <p>The <code>undef</code> statement takes one or more
        <code>Symbol</code>s as arguments, then undefines the corresponding
        instance methods. It does not work with singleton methods.

        <figure id=undef-method>
        <dt>Undefining a method with <code>undef</code>.
          <dd>
            <pre><code>
            def boo!
              "(goose)"
            end
            boo! #=&gt; "(goose)"              
            undef :boo!
            boo! #=&gt; NoMethodError: undefined method `boo!' for main:Object 
            </code></pre>
          </dd>
        </figure>
        
        <p>Undefining a method defined in a superclass does not affect the
        superclass’s definition. For example, consider a <code>Rectangle</code>
        class which defines <code>:height</code> and <code>:width</code>
        methods. A <code>Square</code> class inherits from it, but it doesn't
        make sense for <code>Square</code> to have both a
        <code>:height</code> and <code>:width</code> method.
        <code>Square</code> can <code>undef</code> <code>:height</code>,
        preventing <code>Square#height</code> from being called without
        affecting <code>Rectangle#height</code>.

          <h3>Arguments</h3> 
          
          <p>A method may accept one or more arguments, variables passed in
          from the caller.

          <p>When a method is defined with the <code>def</code> keyword its
          name may be followed by a set of parentheses (<code>(</code>,
          <code>)</code>). The contents thereof (hereafter: <dfn
            id=parameter-list>the parameter list</dfn>) dictate the arguments
          the method will accept.

          <p>The parameter list specifies:
            <ul>
              <li>The local variable names (hereafter: <dfn
                id=parameters>parameters</dfn>) to which the corresponding
              argument will be aliased to inside the method.
              <li>Whether the arguments are required or optional.
              <li>Whether a fixed or variable number of arguments are allowed.
              <li>The default value, if any, of each parameter.
              <li>Whether an argument is expected to be a block.
            </ul>
          
            <p>Each parameter name must be unique in the parameter list.

            <h4>Pass By Reference</h4>
            
            <p>Arguments are passed to methods by reference instead of value.
            If the method modifies an object it receives the caller’s copy is
            modified, too.

            <figure id=pass-by-reference>
              <dt>The effect of a method’s modification of an argument on its
              caller</dt>
              <dd>
                <pre>
                  <code>
                    def llama_sans_l(llama)
                      llama.gsub!(/l/i,'')
                    end
                    llama = 'Larry'
                    llama_sans_l(llama) #=&amp; 'arry'
                    llama #=&gt; 'arry'
                  </code>
                </pre>
              </dd>
            </figure>

            <p>Methods may <i>dup</i> (<code>Object#dup</code>) their
            arguments to avoid this situation.    

            <figure id=pass-by-reference-dup>
            <dt>The effect of a method’s modification of a <code>dup</code>’d
            argument on its caller</dt>
              <dd>
                <pre>
                  <code>
                    def llama_sans_l(llama)
                      llama.dup.gsub!(/l/i,'')
                    end
                    llama = 'Larry'
                    llama_sans_l(llama) #=&amp; 'arry'
                    <mark>llama #=&gt; 'Larry'</mark>
                  </code>
                </pre>
              </dd>
            </figure>

            <h3>Required Arguments</h3>

            <p>A <dfn id=required-argument>required argument</dfn>
            <em>must</em> be supplied by the caller. A method which requires
            exactly 4 arguments must receive them all, otherwise it raises an
            <code>ArgumentError</code>.

            <aside class=note>
              <code>nil</code> and <code>false</code> are as valid an
              argument any other. If a method requires an argument and
              <code>nil</code> is supplied in its place, Ruby will not
              complain. Methods wishing to prohibit such values must do so
              themselves.
            </aside>

            <p>Required arguments are specified with a comma-separated list of
            parameter names. Each parameter represents a mandatory argument.

            <figure id=required-arguments>
            <dt>Defining a method which requires exactly two arguments.</dt>
              <dd>
                <pre>
                  <code>
                    class Llama
                      def laugh(how, volume)
                        puts volume == :loudly ? how.upcase : how
                      end
                    end
                    Llama.new.laugh #=&gt; ArgumentError: wrong number of arguments (0 for 2)
                    Llama.new.laugh(:snicker) #=&gt; ArgumentError: wrong number of arguments (1 for 2)
                    Llama.new.laugh(:chortle,:softly) #=&gt; chortle
                    Llama.new.laugh(:guffaw,:loudly) #=&gt; GUFFAW
                    Llama.new.laugh(:ho, :ho, :ho) #=&gt; ArgumentError: wrong number of arguments (3 for 2)
                  </code>
                </pre>
              </dd>
            </figure>

            <h3>Optional Arguments and Default Values</h3>

            <p>An <dfn id=optional-argument>optional argument</dfn>
            <em>may</em> be supplied by the caller. If it is not the
            corresponding parameter will be assigned the value given as its
            default.

            <p>Optional arguments are specified with a comma-separated list of
            <code><var>name</var>=<var>value</var></code> pairs, where
            <var>name</var> is a parameter name and <var>value</var> is its
            default value. The <var>value</var> may be any Ruby expression. 
            
            <figure id=optional-arguments>
            <dt>Defining a method which takes an optional argument.</dt>
              <dd>
                <pre>
                  <code>
                    class Llama
                      def name(name='Larry')
                        name + ' the llama (beast of burden)'
                      end
                    end
                    Llama.new.name #=&gt; "Larry the llama (beast of burden)"
                    Llama.new.name('Lyle Jr.') #=&gt; "Lyle Jr. the llama (beast of burden)"
                    Llama.new.name('Lama', 'glama') #=&gt; ArgumentError: wrong number of arguments (2 for 1)
                  </code>
                </pre>
              </dd>
            </figure>

            <p>Optional and required arguments can be specified alongside each
            other in a reasonably natural fashion. However, it is a
            <code>SyntaxError</code> to both precede and follow a required
            argument with optional arguments. Namely, one or more optional
            arguments may precede one or more required arguments, <em>or</em>
            one or more required arguments may precede one or more optional
            arguments.

            <figure id=required-arguments-with-optional-arguments>
            <dt>Defining a method which takes both optional and required
            arguments.</dt>
              <dd>
                <pre>
                  <code>
                    def required_optional(a,b=1) end
                    def required_required_optional(a,b,c=1) end
                    def optional_required(a=1,b) end
                    def optional_optional_required(a=1,b=2,c) end
                    <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                    SyntaxError</mark>
                  </code>
                </pre>
              </dd>
            </figure>

            <h3>Variable-Length Argument Lists</h3>

            <!-- TODO: Standardise on terms: 'rest' or 'splat' -->

            <p>A <dfn id=rest-parameter>rest parameter</dfn> (or <dfn
              id=splat-parameter>splat parameter</dfn>) consumes every
            argument that follows it while still allowing subsequent required
            parameters to receive their corresponding arguments. Put simply:
            it takes an arbitrary number of arguments from its position
            onward. It is passed to the method as an <code>Array</code>
            containing one argument per element.
            
            <aside class=note>
              Rest parameters do not <em>require</em> any arguments, so a
              method whose parameter list consists solely of a rest parameter,
              for example, may be invoked with zero or more arguments.
            </aside>

            <p>A rest parameter is specified by preceding a parameter name
            with an asterisk (U+002A: <code>*</code>). Only one rest parameter
            may appear in a parameter list.
            
            <figure id=rest-arguments>
            <dt>Defining a method which takes a variable number of arguments.</dt>
              <dd>
                <pre>
                  <code>
                  def zero_or_more(*rest)
                    rest.join(', ')
                  end
                  zero_or_more #=&gt; ""
                  zero_or_more(1) #=&gt; "1"
                  zero_or_more(1,2,3) #=&gt; "1, 2, 3"
                  </code>
                </pre>
              </dd>
            </figure>

            <aside class=note>
              The following syntax rules are complex, but do not be deterred.
              They are unlikely to ever be relevant in practice.
            </aside>

            <!-- FIXME: Clarify this explanation; derive a general principle
            which better expresses the rule -->

            <p>A rest parameter must not be followed by an optional parameter
            because of the resulting ambiguity: if two or more arguments were
            supplied for the former, should the latter be assigned its default
            value or take one of the aforementioned? However, there is no
            ambiguity when optional parameters precede the rest parameter, so
            this arrangement is legal.

            <p>Conversely, a rest parameter may be either followed or preceded
            by one or more required parameters

            <figure id=required-arguments-with-optional-arguments>
            <dt>Defining a method which takes both optional and required
            arguments.</dt>
              <dd>
                <pre>
                  <code>
                    def required_optional(a,b=1) end
                    def required_required_optional(a,b,c=1) end
                    def optional_required(a=1,b) end
                    def optional_optional_required(a=1,b=2,c) end
                    <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                    SyntaxError</mark>
                  </code>
                </pre>
              </dd>
            </figure>

            <p>A rest parameter may be supplied as a sole asterisk, omitting
            the corresponding parameter name. The effect is to consume the
            corresponding arguments as an ordinary rest parameter, without
            assigning them to a local variable. The arguments are ignored.
            This allows methods to accept an arbitrary number of arguments,
            but discard, say, all but the last. 
            
            <p>Thomas et al. (<a href=#refTHOM09>[THOM09]</a>) suggest that
            this technique can used in conjunction with <code>super</code> to
            define a method which accepts an arbitrary number of arguments
            then passes them all to its superclass.

            <figure id=rest-parameter-with-super>
              <dt>A method which accepts a variable number of arguments then
              passes them to its superclass (<code>Parent</code>) with the
              implicit-argument form of <code>super</code>. (<a
                href=#refTHOM09>[THOM09]</a>).
              <dd>
                <pre>
                  <code>
                    class Child &lt; Parent
                      def do_something(*)
                        # our processing
                        super
                      end
                    end
                  </code>
                </pre>
              </dd>
            </figure>

            <h3>Named Arguments</h3>

            <p>The parameter forms described above are positional in nature.
            They depend on the argument’s location in the parameter list to
            marry it with the correct parameter. An alternative approach, that
            can aid the readability of otherwise ungainly parameter lists, is <dfn id=named-arguments>named
              arguments</dfn>. Named arguments allow the method to be invoked
            with a series of key-value pairs, arranged in an arbitrary order.

            <p>Ruby does not offer explicit support for this style of argument
            passing, but it can be ably approximated by defining methods that
            expect a <code>Hash</code> argument: the keys of which become the parameter
            names; and the values, the arguments.

            <!-- TODO: Mention that File/IO, String#encode use this technique -->

            <figure id=named-arguments>
            <dt>A method which uses a <code>Hash</code> argument to simulate
            named arguments.
              <dd>
                <pre>
                  <code>
                    class Chair
                      def initialize(args)
                        @legs = args[:legs] or raise ArgumentError
                        @style = args[:style] || :victorian
                        @height = args[:height] || :average
                        @colour = args[:colour] || args[:color] || :brown
                      end
                    end
                  Chair.new(legs: 4, height: :tall) #=&gt; 
                    #&lt;Chair:0x8249908 @legs=4, @style=:victorian,
                    @height=:tall, @colour=:brown&gt;
                  Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                    #&lt;Chair:0x86958f4 @legs=7, @style=:victorian,
                    @height=:average, @colour=:fuschia&gt;
                  Chair.new(height: :childs, color: :fuschia) #=&gt;
                  ArgumentError 
                  </code>
                </pre>
              </dd>
            </figure>

            <p>The advantages of this approach include:
              <ul>
                <li>Arguments can be specified in any order.
                <li>Arguments with default values can be omitted.
                <li>If <code>Symbol</code>s are used for the <code>Hash</code>
                keys the invocation is particularly readable.
                <li>Variable-length argument lists are supported.
              </ul>

            <figure id=named-arguments-with-defaults>
            <dt>A method which uses a <code>Hash</code> argument to simulate
            named arguments with default values.
              <dd>
                <pre>
                  <code>
                    class Chair
                      DEFAULT_ARGS = {legs: 2, style: :victorian, height: :average, colour: :brown}
                      def initialize(args)
                        @attributes = DEFAULT_ARGS.merge args
                      end
                    end
                    Chair.new(legs: 4, height: :tall) #=&gt;
                      #&lt;Chair:0x9039af4 @attributes={
                      :legs=&gt;4,       :style=&gt;:victorian, 
                      :height=&gt;:tall, :colour=&gt;:brown
                      }&gt;
                    Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                      #&gt;Chair:0x998a9dc @attributes={
                      :legs=&gt;7, :style=&gt;:victorian, 
                      :height=&gt;:average, :colour=&gt;:fuschia
                      }&gt;
                  </code>
                </pre>
              </dd>
            </figure>
            
            <p>The primary shortcoming is that Ruby can not determine
            automatically whether an invalid number of arguments have been
            supplied; the programmer must validate the arguments instead. This
            is unlikely to be particularly significant, however, because a
            method expecting a variable number of arguments would otherwise
            use rest arguments, which would also render it unable to perform
            this validation.

            <!-- TODO: Mention parentheses can be omitted? -->

        <h3>Block Arguments</h3>
          
          <p>Any method may be invoked with a block literal as an argument by
          specifying the block after the method invocation.

            <figure id=method-invocation-with-block-literal>
            <dt>A method which receives, and ignores, a block specified with
            either of the block literal constructs.
              <dd>
                <pre>
                  <code>
                  def m
                    :m
                  end
                  m { 1 + 2 }
                  m do
                    1 + 2
                  end
                  </code>
                </pre>
              </dd>
            </figure>
           
            <p>The method may determine whether it has received a block by
            using the <code>block_given?</code> predicate.

            <figure id=method-using-block_given>
            <dt>A method which uses the <code>block_given?</code> predicate
            to determine whether it has been passed a block.
              <dd>
                <pre>
                  <code>
                  def m
                    puts "Thanks" if block_given?
                  end
                  m { 1 + 2 } #=&gt; "Thanks"
                  m #=&gt; nil
                  </code>
                </pre>
              </dd>
            </figure>

            <p>A block passed to a method in this way is not called; the
            method must use the <code>yield</code> keyword to do so. An
            implication of this is that methods not expecting blocks will
            ignore them. The return value of <code>yield</code> is that of the
            block.

            <!-- TODO: Mention that yield takes arguments -->

            <figure id=method-using-block_given-yield>
            <dt>A method which uses the <code>block_given?</code> predicate
            to determine whether it has been passed a block, and if so calls
            it.
              <dd>
                <pre>
                  <code>
                  def m
                    puts "This block returns: #{yield}" if block_given?
                  end
                  m { 1 + 2 } #=&gt; This block returns: 3
                  m #=&gt; nil
                  </code>
                </pre>
              </dd>
            </figure>

            <p>A method needing a reference to the block it was given, perhaps
            to pass to another method, is defined with a final parameter whose
            name is prefixed with an ampersand (U+0026: <code>&amp;</code>).
            For example: <code> def m(a,b,&amp;block)</code>. The method can
            access the block as a <code>Proc</code> object named after the
            parameter (sans ampersand). The method is invoked in precisely the
            same way as before.

            <figure id=method-using-block-argument>
            <dt>A method which uses a <code>&amp;block</code> parameter to
            refer to the block it is given.
              <dd>
                <pre>
                  <code>
                  def m(&amp;block)
                    puts "This block returns: #{block.call}" if block_given?
                  end
                  m { 1 + 2 } #=&gt; This block returns: 3
                  m #=&gt; nil
                  </code>
                </pre>
              </dd>
            </figure>

        <aside class=note>
          The discussion above applies only to block literals; a method
          expecting a <em>reference</em> to a block, i.e. a <code>proc</code> or
          <code>lambda</code>, need not pay heed. Such a method employs
          precisely the same parameter list as in the previous sections.

            <figure id=method-receiving-block-ref>
            <dt>A method which expects a reference to a block uses the same
            parameter list as it would if expecting any other type of variable.
              <dd>
                <pre>
                  <code>
                  def m(b)
                    b.call
                  end
                  m -&gt;{ "I am a \u{3bb}!" } #=&gt; "I am a λ!"
                  </code>
                </pre>
              </dd>
            </figure>
        </aside>

        <h3>Visibility</h3>

        <p>An instance method is either <i>public</i>, <i>private</i>, or
        <i>protected</i>. It is declared as such with
        <code>Module#public</code>, <code>Module#private</code>, and
        <code>Module#protected</code> (hereafter: <i>visibility
          specifiers</i>), respectively.

         <p>A visibility specifier invoked without arguments affects every
         method subsequently defined in the same class definition until
         another visibility specifier is encountered.

          <figure id=visibility-specifiers>
            <dt>Declaring the visibility of methods with visibility specifiers
            <dd>
              <pre><code>
              class C                
                # This method is public because it hasn't been specified
                # otherwise
                def pub
                end
                
                private
                # This method is private because it appears after the
                #'private' visibility specifier
                def pri
                end

                # This method is also private because the previous visibility
                # specifier has not been overridden
                def pri2
                end

                protected
                # This method is protected because it appears after the
                #'protected' visibility specifier
                def pro
                end
                
                public
                # This method is public because the protected visibility
                # specifier has been explicitly overridden. Typically this would
                # have been defined after 'pub', removing the need for a
                # visibility specifier
                def pub2
                end  
              end  
              </code></pre>
            </dd>
          </figure>

         <p>A visibility specifier with one or more method names (given as
         Symbols or Strings) affects only the named methods, which must have
         already been defined.

          <figure id=visibility-specifiers-args>
            <dt>Declaring the visibility of methods with visibility specifiers
            that take arguments
            <dd>
              <pre><code>
              class C                
                # This method is public because it hasn't been specified
                # otherwise
                def pub
                end
                
                def pri
                end

                def pri2
                end

                # Both :pri and :pri2 are made private because their names are
                # given as arguments to the 'private' visibility specifier
                private :pri, :pri2

                def pro
                end
                # This method is made protected because its name is given to
                # the 'protected' visibility specifier
                protected 'pro'
                
                # This method is public because it hasn't been declared
                # otherwise; the previous 'protected' specifier only affects the
                # method it was called for
                def pub2
                end  
              end  
              </code></pre>
            </dd>
          </figure>

          <h4>Advisory Privacy</h4>

          <p>Method visibility is merely an advisory construct. Ruby does not
          <i>prohibit</i> the invocation of private methods; she ensures that
          they will not be called accidentally as follows:

          <ul>
            <li>Standard method invocation syntax (<code>obj.method</code>)
            raises a <code>NoMethodError</code>, signaling that the
            programmer's intent is ill-advised. The caviller programmer must
            use a technique such as <code>Object#send</code> to explicitly
            ignore the privacy advice.
            <li>The method introspection API (e.g.
            <code>Object#private_methods</code>,
            <code>Object#protected_methods</code>, and
            <code>Object#public_methods</code>) delineates methods by their visibility,
            allowing private and protected methods to be determined
            automatically.
            <li>RDoc/<code>ri</code> only displays public methods by default.
          </ul>

          <h4>Public Methods</h4>

          <p>A method is public unless explicitly declared otherwise, or
          declared outside of a class definition. The <code>initialize</code>
          method is private by default.

          <h4>Private Methods</h4>

          <p>A <dfn id=private-method>private method</dfn> cannot be invoked
          with an explicit receiver.  Therefore they can only be called by
          other instance methods of the class in which they were defined, or a
          subclass thereof. 

          <p><code>self</code> is also regarded as an explicit receiver so a
          method invocation of the form <code>self.<var>private</var></code>,
          where <var>private</var> is a private instance method in the same
          class, is disallowed.


          <h4>Protected Methods</h4>

          <p>Protected methods can invoked only from the class in which
          they were defined or a subclass thereof, that is they behave the
          same as private methods. However, unlike private methods
          they can be explicitly invoked on any instance of their class.

          <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
            232)</a> suggest that <q>A
            protected method can be used, for example, to define an accessor
            that allows instances of a class to share internal state with each
            other, but does not allow users of the class to access that
            state.</q>


        <h3><code>Object#send</code></h3>

        <figure id=object-send>
        <dt><code>Object#send</code> sends an object a message whose name can
        be determined at runtime.
          <dd>
            <pre><code>
              name = :size
              # Sends "wool" the :name message
              "wool".name #=&gt; NoMethodError: undefined method `name' for "wool":String
              # Sends "wool" the :size message
              "wool".send(name) #=&gt; 4
            </code></pre>  
          </dd>
          </figure>
We’ll see later in this chapter that many of Ruby’s operators are defined as methods,
and expressions like x+y are evaluated as x.+(y), where the method name is +. The fact
that many of Ruby’s operators are defined as methods means that you can redefine
these operators in your own classes.
Now let’s consider this very simple expression:
     x
If a variable named x exists (that is, if the Ruby interpreter has seen an assignment to
x), then this is a variable reference expression. If no such variable exists, then this is an
invocation of the method x, with no arguments, on self.


6.2.1 Operator Methods
Many of Ruby’s operators, such as +, *, and even the array index operator [], are im-
plemented with methods that you can define in your own classes. You define an
operator by defining a method with the same “name” as the operator. (The only ex-
ceptions are the unary plus and minus operators, which use method names +@ and
-@.) Ruby allows you to do this even though the method name is all punctuation. You
might end up with a method definition like this:
      def +(other)               # Define binary plus operator: x+y is x.+(y)
        self.concatenate(other)
      end
Table 4-2 in Chapter 4 specifies which of Ruby’s operators are defined as methods.
These operators are the only punctuation-based method names that you can use: you
can’t invent new operators or define methods whose names consist of other sequences
of punctuation characters. There are additional examples of defining method-based
operators in §7.1.6.
Methods that define a unary operator are passed no arguments. Methods that define
binary operators are passed one argument and should operate on self and the argu-
ment. The array access operators [] and []= are special because they can be invoked
with any number of arguments. For []=, the last argument is always the value being
assigned.
6.2.2 Method Aliases
It is not uncommon for methods in Ruby to have more than one name. The language
has a keyword alias that serves to define a new name for an existing method. Use it
like this:
      alias aka also_known_as   # alias new_name existing_name
                                                                       6.2 Method Names | 181
After executing this statement, the identifier aka will refer to the same method thats
also_known_as does.
Method aliasing is one of the things that makes Ruby an expressive and natural lan-
guage. When there are multiple names for a method, you can choose the one that seems
most natural in your code. The Range class, for example, defines a method for testing
whether a value falls within the range. You can call this method with the name
include? or with the name member?. If you are treating a range as a kind of set, the name
member? may be the most natural choice.
A more practical reason for aliasing methods is to insert new functionality into a
method. The following is a common idiom for augmenting existing methods:
     def hello                              # A nice simple method
       puts "Hello World"                   # Suppose we want to augment it...
     end
     alias original_hello hello             # Give the method a backup name
     def hello                              #  Now we define a new method with the old name
       puts "Your attention please"         #  That does some stuff
       original_hello                       #  Then calls the original method
       puts "This has been a test"          #  Then does some more stuff
     end
In this code, we’re working on global methods. It is more common to use alias with
the instance methods of a class. (We’ll learn about this in Chapter 7.) In this situation,
alias must be used within the class whose method is to be renamed. Classes in Ruby
can be “reopened” (again, this is discussed in Chapter 7)—which means that your code
can take an existing class, ‘open’ it with a class statement, and then use alias as shown
in the example to augment or alter the existing methods of that class. This is called
“alias chaining” and is covered in detail in §8.11.
                                    Aliasing Is Not Overloading
   A Ruby method may have two names, but two methods cannot share a single name. In
   statically typed languages, methods can be distinguished by the number and type of
   their arguments, and two or more methods may share the same name as long as they
   expect different numbers or types of arguments. This kind of overloading is not possible
   in Ruby.
   On the other hand, method overloading is not really necessary in Ruby. Methods can
   accept arguments of any class and can be written to do different things based on the
   type of the arguments they are passed. Also (as we’ll see later), Ruby’s method argu-
   ments can be declared with default values, and these arguments may be omitted form
   method invocations. This allows a single method to be invoked with differing numbers
   of arguments.
182 | Chapter 6: Methods, Procs, Lambdas, and Closures
6.3 Methods and Parentheses
Ruby allows parentheses to be omitted from most method invocations. In simple cases,
this results in clean-looking code. In complex cases, however, it causes syntactic am-
biguities and confusing corner cases. We’ll consider these in the sections that follow.
6.3.1 Optional Parentheses
Parentheses are omitted from method invocations in many common Ruby idioms. The
following two lines of code, for example, are equivalent:
     puts "Hello World"
     puts("Hello World")
In the first line, puts looks like a keyword, statement, or command built in to the
language. The equivalent second line demonstrates that it is simply the invocation of
a global method, with the parentheses omitted. Although the second form is clearer,
the first form is more concise, more commonly used, and arguably more natural.
Next, consider this code:
     greeting = "Hello"
     size = greeting.length
If you are accustomed to other object-oriented languages, you may think that length
is a property, field, or variable of string objects. Ruby is strongly object oriented, how-
ever, and its objects are fully encapsulated; the only way to interact with them is by
invoking their methods. In this code, greeting.length is a method invocation. The
length method expects no arguments and is invoked without parentheses. The
following code is equivalent:
     size = greeting.length()
Including the optional parentheses emphasizes that a method invocation is occurring.
Omitting the parentheses in method invocations with no arguments gives the illusion
of property access, and is a very common practice.
Parentheses are very commonly omitted when there are zero or one arguments to the
invoked method. Although it is less common, the parentheses may be omitted even
when there are multiple arguments, as in the following code:
     x = 3               # x is a number
     x.between? 1,5      # same as x.between?(1,5)
Parentheses may also be omitted around the parameter list in method definitions,
though it is hard to argue that this makes your code clearer or more readable. The
following code, for example, defines a method that returns the sum of its arguments:
     def sum x, y
       x+y
     end
                                                                6.3 Methods and Parentheses | 183
6.3.2 Required Parentheses
Some code is ambiguous if the parentheses are omitted, and here Ruby requires that
you include them. The most common case is nested method invocations of the form
f g x, y. In Ruby, invocations of that form mean f(g(x,y)). Ruby 1.8 issues a warning,
however, because the code could also be interpreted as f(g(x),y). The warning has
been removed in Ruby 1.9. The following code, using the sum method defined above,
prints 4, but issues a warning in Ruby 1.8:
     puts sum 2, 2
To remove the warning, rewrite the code with parentheses around the arguments:
     puts sum(2,2)
Note that using parentheses around the outer method invocation does not resolve the
ambiguity:
     puts(sum 2,2)     # Does this mean puts(sum(2,2)) or puts(sum(2), 2)?
An expression involving nested function calls is only ambiguous when there is more
than one argument. The Ruby interpreter can only interpret the following code in one
way:
     puts factorial x      # This can only mean puts(factorial(x))
Despite the lack of ambiguity here, Ruby 1.8 still issues a warning if you omit the
parentheses around the x.
Sometimes omitting parentheses is a true syntax error rather than a simple warning.
The following expressions, for example, are completely ambiguous without parenthe-
ses, and Ruby doesn’t even attempt to guess what you mean:
     puts 4, sum 2,2      # Error: does the second comma go with the 1st or 2nd method?
     [sum 2,2]            # Error: two array elements or one?
There is another wrinkle that arises from the fact that parentheses are optional. When
you do use parentheses in a method invocation, the opening parenthesis must imme-
diately follow the method name, with no intervening space. This is because parentheses
do double-duty: they can be used around an argument list in a method invocation, and
they can be used for grouping expressions. Consider the following two expressions,
which differ only by a single space:
     square(2+2)*2      # square(4)*2 = 16*2 = 32
     square (2+2)*2     # square(4*2) = square(8) = 64
In the first expression, the parentheses represent method invocation. In the second,
they represent expression grouping. To reduce the potential for confusion, you should
always use parentheses around a method invocation if any of the arguments use
parentheses. The second expression would be written more clearly as:
     square((2+2)*2)
184 | Chapter 6: Methods, Procs, Lambdas, and Closures
We’ll end this discussion of parentheses with one final twist. Recall that the following
expression is ambiguous and causes a warning:
    puts(sum 2,2)   # Does this mean puts(sum(2,2)) or puts(sum(2), 2)?
The best way to resolve this ambiguity is to put parentheses around the arguments to
the sum method. Another way is to add a space between puts and the opening
parenthesis:
    puts (sum 2,2)
Adding the space converts the method invocation parentheses into expression grouping
parentheses. Because these parentheses group a subexpression, the comma can no
longer be interpreted as an argument delimiter for the puts invocation.
6.4 Method Arguments
Simple method declarations include a comma-separated list of argument names (in
optional parentheses) after the method name. But there is much more to Ruby’s method
arguments. The subsections that follow explain:
  • How to declare an argument that has a default value, so that the argument can be
    omitted when the method is invoked
  • How to declare a method that accepts any number of arguments
  • How to simulate named method arguments with special syntax for passing a hash
    to a method
  • How to declare a method so that the block associated with an invocation of the
    method is treated as a method argument
6.4.1 Parameter Defaults
When you define a method, you can specify default values for some or all of the
parameters. If you do this, then your method may be invoked with fewer argument
values than the declared number of parameters. If arguments are omitted, then the
default value of the parameter is used in its place. Specify a default value by following
the parameter name with an equals sign and a value:
    def prefix(s, len=1)
      s[0,len]
    end
This method declares two parameters, but the second one has a default. This means
that we can invoke it with either one argument or two:
    prefix("Ruby", 3)    # => "Rub"
    prefix("Ruby")       # => "R"
                                                                  6.4 Method Arguments | 185
Argument defaults need not be constants: they may be arbitrary expressions, and can
be referred to instance variables and to previous parameters in the parameter list. For
example:
     # Return the last character of s or the substring from index to the end
     def suffix(s, index=s.size-1)
       s[index, s.size-index]
     end
Parameter defaults are evaluated when a method is invoked rather than when it is
parsed. In the following method, the default value [] produces a new empty array on
each invocation, rather than reusing a single array created when the method is defined:
     # Append the value x to the array a, return a.
     # If no array is specified, start with an empty one.
     def append(x, a=[])
       a << x
     end
In Ruby 1.8, method parameters with default values must appear after all ordinary
parameters in the parameter list. Ruby 1.9 relaxes this restriction and allows ordinary
parameters to appear after parameters with defaults. It still requires all parameters with
defaults to be adjacent in the parameter list—you can’t declare two parameters with
default values with an ordinary parameter between them, for example. When a method
has more than one parameter with a default value, and you invoke the method with an
argument for some, but not all, of these parameters, they are filled in from left to right.
Suppose a method has two parameters, and both of those parameters have defaults.
You can invoke this method with zero, one, or two arguments. If you specify one ar-
gument, it is assigned to the first parameter and the second parameter uses its default
value. There is no way, however, to specify a value for the second parameter and use
the default value of the first parameter.
6.4.2 Variable-Length Argument Lists and Arrays
Sometimes we want to write methods that can accept an arbitrary number of argu-
ments. To do this, we put an * before one of the method’s parameters. Within the body
of the method, this parameter will refer to an array that contains the zero or more
arguments passed at that position. For example:
     # Return the largest of the one or more arguments passed
     def max(first, *rest)
       # Assume that the required first argument is the largest
       max = first
       # Now loop through each of the optional arguments looking for bigger ones
       rest.each {|x| max = x if x > max }
       # Return the largest one we found
       max
     end
186 | Chapter 6: Methods, Procs, Lambdas, and Closures
The max method requires at least one argument, but it may accept any number of ad-
ditional arguments. The first argument is available through the first parameter. Any
additional arguments are stored in the rest array. We can invoke max like this:
      max(1)        # first=1, rest=[]
      max(1,2)      # first=1, rest=[2]
      max(1,2,3)    # first=1, rest=[2,3]
Note that in Ruby, all Enumerable objects automatically have a max method, so the
method defined here is not particularly useful.
No more than one parameter may be prefixed with an *. In Ruby 1.8, this parameter
must appear after all ordinary parameters and after all parameters with defaults speci-
fied. It should be the last parameter of the method, unless the method also has a
parameter with an & prefix (see below). In Ruby 1.9, a parameter with an * prefix must
still appear after any parameters with defaults specified, but it may be followed by
additional ordinary parameters. It must also still appear before any &-prefixed
parameter.
6.4.2.1 Passing arrays to methods
We’ve seen how * can be used in a method declaration to cause multiple arguments to
be gathered or coalesced into a single array. It can also be used in a method invocation
to scatter, expand, or explode the elements of an array (or range or enumerator) so that
each element becomes a separate method argument. The * is sometimes called the splat
operator, although it is not a true operator. We’ve seen it used before in the discussion
of parallel assignment in §4.5.5.
Suppose we wanted to find the maximum value in an array (and that we didn’t know
that Ruby arrays have a built-in max method!). We could pass the elements of the array
to the max method (defined earlier) like this:
      data = [3, 2, 1]
      m = max(*data)    # first = 3, rest=[2,1] => 3
Consider what happens without the *:
      m = max(data)    # first = [3,2,1], rest=[] => [3,2,1]
In this case, we’re passing an array as the first and only argument, and our max method
returns that first argument without performing any comparisons on it.
The * can also be used with methods that return arrays to expand those arrays for use
in another method invocation. Consider the polar and cartesian methods defined
earlier in this chapter:
      # Convert the point (x,y) to Polar coordinates, then back to Cartesian
      x,y = cartesian(*polar(x, y))
In Ruby 1.9, enumerators are splattable objects. To find the largest letter in a string,
for example, we could write:
      max(*"hello world".each_char)    # => 'w'
                                                                    6.4 Method Arguments | 187
6.4.3 Mapping Arguments to Parameters
When a method definition includes parameters with default values or a parameter pre-
fixed with an *, the assignment of argument values to parameters during method
invocation gets a little bit tricky.
In Ruby 1.8, the position of the special parameters is restricted so that argument values
are assigned to parameters from left to right. The first arguments are assigned to the
ordinary parameters. If there are any remaining arguments, they are assigned to the
parameters that have defaults. And if there are still more arguments, they are assigned
to the array argument.
Ruby 1.9 has to be more clever about the way it maps arguments to parameters because
the order of the parameters is no longer constrained. Suppose we have a method that
is declared with o ordinary parameters, d parameters with default values, and one array
parameter prefixed with *. Now assume that we invoke this method with a arguments.
If a is less than o, an ArgumentError is raised; we have not supplied the minimum
required number of arguments.
If a is greater than or equal to o and less than or equal to o+d, then the leftmost a–o
parameters with defaults will have arguments assigned to them. The remaining (to the
right) o+d–a parameters with defaults will not have arguments assigned to them, and
will just use their default values.
If a is greater than o+d, then the array parameter whose name is prefixed with an * will
have a–o–d arguments stored in it; otherwise, it will be empty.
Once these calculations are performed, the arguments are mapped to parameters from
left to right, assigning the appropriate number of arguments to each parameter.
6.4.4 Hashes for Named Arguments
When a method requires more than two or three arguments, it can be difficult for the
programmer invoking the method to remember the proper order for those arguments.
Some languages allow you to write method invocations that explicitly specify a pa-
rameter name for each argument that is passed. Ruby does not support this method
invocation syntax, but it can be approximated if you write a method that expects a hash
as its argument or as one of its arguments:
      # This method returns an array a of n numbers. For any index i, 0 <= i < n,
      # the value of element a[i] is m*i+c. Arguments n, m, and c are passed
      # as keys in a hash, so that it is not necessary to remember their order.
      def sequence(args)
        # Extract the arguments from the hash.
        # Note the use of the || operator to specify defaults used
        # if the hash does not define a key that we are interested in.
        n = args[:n] || 0
        m = args[:m] || 1
        c = args[:c] || 0
188 | Chapter 6: Methods, Procs, Lambdas, and Closures
       a = []                       # Start with an empty array
       n.times {|i| a << m*i+c }    # Calculate the value of each array element
       a                            # Return the array
     end
You might invoke this method with a hash literal argument like this:
     sequence({:n=>3, :m=>5})       # => [0, 5, 10]
In order to better support this style of programming, Ruby allows you to omit the curly
braces around the hash literal if it is the last argument to the method (or if the only
argument that follows it is a block argument, prefixed with &). A hash without braces
is sometimes called a bare hash, and when we use one it looks like we are passing
separate named arguments, which we can reorder however we like:
     sequence(:m=>3, :n=>5)         # => [0, 3, 6, 9, 12]
As with other ruby methods, we can omit the parentheses, too:
     # Ruby 1.9 hash syntax
     sequence c:1, m:3, n:5         # => [1, 4, 7, 10, 13]
If you omit the parentheses, then you must omit the curly braces. If curly braces follow
the method name outside of parentheses, Ruby thinks you’re passing a block to the
method:
     sequence {:m=>3, :n=>5}        # Syntax error!
6.4.5 Block Arguments
Recall from §5.3 that a block is a chunk of Ruby code associated with a method invo-
cation, and that an iterator is a method that expects a block. Any method invocation
may be followed by a block, and any method that has a block associated with it may
invoke the code in that block with the yield statement. To refresh your memory, the
following code is a block-oriented variant on the sequence method developed earlier in
the chapter:
     # Generate a sequence of n numbers m*i + c and pass them to the block
     def sequence2(n, m, c)
       i = 0
       while(i < n)          # loop n times
         yield i*m + c       # pass next element of the sequence to the block
         i += 1
       end
     end
     # Here is how you might use this version of the method
     sequence2(5, 2, 2) {|x| puts x } # Print numbers 2, 4, 6, 8, 10
One of the features of blocks is their anonymity. They are not passed to the method in
a traditional sense, they have no name, and they are invoked with a keyword rather
than with a method. If you prefer more explicit control over a block (so that you can
                                                                    6.4 Method Arguments | 189
pass it on to some other method, for example), add a final argument to your method,
and prefix the argument name with an ampersand.* If you do this, then that argument
will refer to the block—if any—that is passed to the method. The value of the argument
will be a Proc object, and instead of using yield, you invoke the call method of the Proc:
     def sequence3(n, m, c, &b) # Explicit argument to get block as a Proc
        i = 0
        while(i < n)
           b.call(i*m + c)            # Invoke the Proc with its call method
           i += 1
        end
     end
     # Note that the block is still passed outside of the parentheses
     sequence3(5, 2, 2) {|x| puts x }
Notice that using the ampersand in this way changes only the method definition. The
method invocation remains the same. We end up with the block argument being
declared inside the parentheses of the method definition, but the block itself is still
specified outside the parentheses of the method invocation.
                                  Passing Proc Objects Explicitly
   If you create your own Proc object (we’ll see how to do this later in the chapter) and
   want to pass it explicitly to a method, you can do this as you would pass any other
   value—a Proc is an object like any other. In this case, you should not use an ampersand
   in the method definition:
          # This version expects an explicitly-created Proc object, not a block
          def sequence4(n, m, c, b) # No ampersand used for argument b
            i = 0
            while(i < n)
              b.call(i*m + c)          # Proc is called explicitly
              i += 1
            end
          end
          p = Proc.new {|x| puts x }    # Explicitly create a Proc object
          sequence4(5, 2, 2, p)         # And pass it as an ordinary argument
Twice before in this chapter, we’ve said that a special kind of parameter must be the
last one in the parameter list. Block arguments prefixed with ampersands must really
be the last one. Because blocks are passed unusually in method invocations, named
block arguments are different and do not interfere with array or hash parameters in
which the brackets and braces have been omitted. The following two methods are legal,
for example:
* We use the term “block argument” instead of “block parameter” for method parameters prefixed with &.
  This is because the phrase “block parameter” refers to the parameter list (such as |x|) of the block itself.
190 | Chapter 6: Methods, Procs, Lambdas, and Closures
      def sequence5(args, &b) # Pass arguments as a hash and follow with a block
        n, m, c = args[:n], args[:m], args[:c]
        i = 0
        while(i < n)
          b.call(i*m + c)
          i += 1
        end
      end
      # Expects one or more arguments, followed by a block
      def max(first, *rest, &block)
        max = first
        rest.each {|x| max = x if x > max }
        block.call(max)
        max
      end
These methods work fine, but notice that you can avoid the complexity of these cases
by simply leaving your blocks anonymous and calling them with yield.
It is also worth noting that the yield statement still works in a method defined with an
& parameter. Even if the block has been converted to a Proc object and passed as an
argument, it can still be invoked as an anonymous block, as if the block argument was
not there.
6.4.5.1 Using & in method invocation
We saw earlier that you can use * in a method definition to specify that multiple argu-
ments should be packed into an array, and that you can use * in a method invocation
to specify that an array should be unpacked so that its elements become separate
arguments. & can also be used in definitions and invocations. We’ve just seen that & in
a method definition allows an ordinary block associated with a method invocation to
be used as a named Proc object inside the method. When & is used before a Proc object
in a method invocation, it treats the Proc as if it was an ordinary block following the
invocation.
Consider the following code which sums the contents of two arrays:
      a, b = [1,2,3], [4,5]                     # Start with some data.
      sum = a.inject(0) {|total,x| total+x }    # => 6. Sum elements of a.
      sum = b.inject(sum) {|total,x| total+x }  # => 15. Add the elements of b in.
We described the inject iterator earlier in §5.3.2. If you don’t remember, you can look
up its documentation with ri Enumerable.inject. The important thing to notice about
this example is that the two blocks are identical. Rather than having the Ruby inter-
preter parse the same block twice, we can create a Proc to represent the block, and use
the single Proc object twice:
      a, b = [1,2,3], [4,5]                     # Start with some data.
      summation = Proc.new {|total,x| total+x } # A Proc object for summations.
      sum = a.inject(0, &summation)             # => 6
      sum = b.inject(sum, &summation)           # => 15
                                                                    6.4 Method Arguments | 191
If you use & in a method invocation, it must appear before the last argument in the
invocation. Blocks can be associated with any method call, even when the method is
not expecting a block, and never uses yield. In the same way, any method invocation
may have an & argument as its last argument.
In a method invocation an & typically appears before a Proc object. But it is actually
allowed before any object with a to_proc method. The Method class (covered later in
this chapter) has such a method, so Method objects can be passed to iterators just as
Proc objects can.
In Ruby 1.9, the Symbol class defines a to_proc method, allowing symbols to be prefixed
with & and passed to iterators. When a symbol is passed like this, it is assumed to be
the name of a method. The Proc object returned by the to_proc method invokes the
named method of its first argument, passing any remaining arguments to that named
method. The canonical case is this: given an array of strings, create a new array of those
strings, converted to uppercase. Symbol.to_proc allows us to accomplish this elegantly
as follows:
     words = ['and', 'but', 'car']             # An array of words
     uppercase = words.map &:upcase            # Convert to uppercase with String.upcase
     upper = words.map {|w| w.upcase } # This is the equivalent code with a block
6.5 Procs and Lambdas
Blocks are syntactic structures in Ruby; they are not objects, and cannot be manipulated
as objects. It is possible, however, to create an object that represents a block. Depending
on how the object is created, it is called a proc or a lambda. Procs have block-like
behavior and lambdas have method-like behavior. Both, however, are instances of class
Proc.
The subsections that follow explain:
  •  How to create Proc objects in both proc and lambda forms
  •  How to invoke Proc objects
  •  How to determine how many arguments a Proc expects
  •  How to determine if two Proc objects are the same
  •  How procs and lambdas differ from each other
6.5.1 Creating Procs
We’ve already seen one way to crfate a Proc object: by associating a block with a method
that is defined with an ampersand-prefixed block argument. There is nothing prevent-
ing such a method from returning the Proc object for use outside the method:
     # This method creates a proc from a block
     def makeproc(&p) # Convert associated block to a Proc and store in p
192 | Chapter 6: Methods, Procs, Lambdas, and Closures
       p                 # Return the Proc object
     end
With a makeproc method like this defined, we can create a Proc object for ourselves:
     adder = makeproc {|x,y| x+y }
The variable adder now refers to a Proc object. Proc objects created in this way are procs,
not lambdas. All Proc objects have a call method that, when invoked, runs the code
contained by the block from which the proc was created. For example:
     sum = adder.call(2,2)    # => 4
In addition to being invoked, Proc objects can be passed to methods, stored in data
structures and otherwise manipulated like any other Ruby object.
As well as creating procs by method invocation, there are three methods that create
Proc objects (both procs and lambdas) in Ruby. These methods are commonly used,
and it is not actually necessary to define a makeproc method like the one shown earlier.
In addition to these Proc-creation methods, Ruby 1.9 also supports a new literal syntax
for defining lambdas. The subsections that follow discuss the methods Proc.new,
lambda, and proc, and also explain the Ruby 1.9 lambda literal syntax.
6.5.1.1 Proc.new
We’ve already seen Proc.new used in some of the previous examples in this chapter.
This is the normal new method that most classes support, and it’s the most obvious way
to create a new instance of the Proc class. Proc.new expects no arguments, and returns
a Proc object that is a proc (not a lambda). When you invoke Proc.new with an associated
block, it returns a proc that represents the block. For example:
     p = Proc.new {|x,y| x+y }
If Proc.new is invoked without a block from within a method that does have an asso-
ciated block, then it returns a proc representing the block associated with the containing
method. Using Proc.new in this way provides an alternative to using an ampersand-
prefixed block argument in a method definition. The following two methods are
equivalent, for example:
     def invoke(&b)       def invoke
       b.call               Proc.new.call
     end                  end
6.5.1.2 Kernel.lambda
Another technique for creating Proc objects is with the lambda method. lambda is a
method of the Kernel module, so it behaves like a global function. As its name suggests,
the Proc object returned by this method is a lambda rather than a proc. lambda expects
no arguments, but there must be a block associated with the invocation:
     is_positive = lambda {|x| x > 0 }
                                                                    6.5 Procs and Lambdas | 193
                                            Lambda History
   Lambdas and the lambda method are so named in reference to lambda calculus, a branch
   of mathematical logic that has been applied to functional programming languages. Lisp
   also uses the term “lambda” to refer to functions that can be manipulated as objects.
6.5.1.3 Kernel.proc
In Ruby 1.8, the global proc method is a synonym for lambda. Despite its name, it returns
a lambda, not a proc. Ruby 1.9 fixes this; in that version of the language, proc is a
synonym for Proc.new.
Because of this ambiguity, you should never use proc in Ruby 1.8 code. The behavior
of your code might change if the interpreter was upgraded to a newer version. If you
are using Ruby 1.9 code and are confident that it will never be run with a Ruby 1.8
interpreter, you can safely use proc as a more elegant shorthand for Proc.new.
6.5.1.4 Lambda Literals
Ruby 1.9 supports an entirely new syntax for defining lambdas as literals. We’ll begin
with a Ruby 1.8 lambda, created with the lambda method:
     succ = lambda {|x| x+1}
In Ruby 1.9, we can convert this to a literal as follows:
  • Replace the method name lambda with the punctuation ->.
  • Move the list of arguments outside of and just before the curly braces.
  • Change the argument list delimiters from || to ().
With these changes, we get a Ruby 1.9 lambda literal:
     succ = ->(x){ x+1 }
succ now holds a Proc object, which we can use just like any other:
     succ.call(2)      # => 3
The introduction of this syntax into Ruby was controversial, and it takes some getting
used to. Note that the arrow characters -> are different from those used in hash literals.
A lambda literal uses an arrow made with a hyphen, whereas a hash literal uses an arrow
made with an equals sign.
As with blocks in Ruby 1.9, the argument list of a lambda literal may include the dec-
laration of block-local variables that are guaranteed not to overwrite variables with the
same name in the enclosing scope. Simply follow the parameter list with a semicolon
and a list of local variables:
     # This lambda takes 2 args and declares 3 local vars
     f = ->(x,y; i,j,k) { ... }
194 | Chapter 6: Methods, Procs, Lambdas, and Closures
One benefit of this new lambda syntax over the traditional block-based lambda creation
methods is that the Ruby 1.9 syntax allows lambdas to be declared with argument
defaults, just as methods can be:
     zoom = ->(x,y,factor=2) { [x*factor, y*factor] }
As with method declarations, the parentheses in lambda literals are optional, because
the parameter list and local variable lists are completely delimited by the ->, ;, and {.
We could rewrite the three lambdas above like this:
     succ = ->x { x+1 }
     f = -> x,y; i,j,k { ... }
     zoom = ->x,y,factor=2 { [x*factor, y*factor] }
Lambda parameters and local variables are optional, of course, and a lambda literal can
omit this altogether. The minimal lambda, which takes no arguments and returns
nil, is the following:
     ->{}
One benefit of this new syntax is its succinctness. It can be helpful when you want to
pass a lambda as an argument to a method or to another lambda:
     def compose(f,g)             # Compose 2 lambdas
       ->(x) { f.call(g.call(x)) }
     end
     succOfSquare = compose(->x{x+1}, ->x{x*x})
     succOfSquare.call(4)         # => 17: Computes (4*4)+1
Lambda literals create Proc objects and are not the same thing as blocks. If you want
to pass a lambda literal to a method that expects a block, prefix the literal with &, just
as you would with any other Proc object. Here is how we might sort an array of numbers
into descending order using both a block and a lambda literal:
     data.sort {|a,b| b-a }    # The block version
     data.sort &->(a,b){ b-a } # The lambda literal version
In this case, as you can see, regular block syntax is simpler.
6.5.2 Invoking Procs and Lambdas
Procs and lambdas are objects, not methods, and they cannot be invoked in the same
way that methods are. If p refers to a Proc object, you cannot invoke p as a method. But
because p is an object, you can invoke a method of p. We’ve already mentioned that
the Proc class defines a method named call. Invoking this method executes the code
in the original block. The arguments you pass to the call method become arguments
to the block, and the return value of the block becomes the return value of the call
method:
     f = Proc.new {|x,y| 1.0/(1.0/x + 1.0/y) }
     z = f.call(x,y)
                                                                  6.5 Procs and Lambdas | 195
The Proc class also defines the array access operator to work the same way as call. This
means that you can invoke a proc or lambda using a syntax that is like method
invocation, where parentheses have been replaced with square brackets. The proc
invocation above, for example, could be replaced with this code:
     z = f[x,y]
Ruby 1.9 offers an additional way to invoke a Proc object; as an alternative to square
brackets, you can use parentheses prefixed with a period:
     z = f.(x,y)
.() looks like a method invocation missing the method name. This is not an operator
that can be defined, but rather is syntactic-sugar that invokes the call method. It can
be used with any object that defines a call method and is not limited to Proc objects.
6.5.3 The Arity of a Proc
The arity of a proc or lambda is the number of arguments it expects. (The word is
derived from the “ary” suffix of unary, binary, ternary, etc.) Proc objects have an
arity method that returns the number of arguments they expect. For example:
     lambda{||}.arity              # => 0. No arguments expected
     lambda{|x| x}.arity           # => 1. One argument expected
     lambda{|x,y| x+y}.arity # => 2. Two arguments expected
The notion of arity gets confusing when a Proc accepts an arbitrary number of argu-
ments in an *-prefixed final argument. When a Proc allows optional arguments, the
arity method returns a negative number of the form -n-1. A return value of this form
indicates that the Proc requires n arguments, but it may optionally take additional ar-
guments as well. -n-1 is known as the one’s-complement of n, and you can invert it
with the ~ operator. So if arity returns a negative number m, then ~m (or -m-1) gives you
the number of required arguments:
     lambda {|*args|}.arity               # => -1.     ~-1 = -(-1)-1 = 0 arguments required
     lambda {|first, *rest|}.arity # => -2.            ~-2 = -(-2)-1 = 1 argument required
There is one final wrinkle to the arity method. In Ruby 1.8, a Proc declared without
any argument clause at all (that is, without any || characters) may be invoked with any
number of arguments (and these arguments are ignored). The arity method returns
–1 to indicate that there are no required arguments. This has changed in Ruby 1.9: a
Proc declared like this has an arity of 0. If it is a lambda, then it is an error to invoke it
with any arguments:
     puts lambda {}.arity       # –1 in Ruby 1.8; 0 in Ruby 1.9
196 | Chapter 6: Methods, Procs, Lambdas, and Closures
6.5.4 Proc Equality
The Proc class defines an == method to determine whether two Proc objects are equal.
It is important to understand, however, that merely having the same source code is not
enough to make two procs or lambdas equal to each other:
      lambda {|x| x*x } == lambda {|x| x*x }     # => false
The == method only returns true if one Proc is a clone or duplicate of the other:
      p = lambda {|x| x*x }
      q = p.dup
      p == q                         # => true: the two procs are equal
      p.object_id == q.object_id     # => false: they are not the same object
6.5.5 How Lambdas Differ from Procs
A proc is the object form of a block, and it behaves like a block. A lambda has slightly
modified behavior and behaves more like a method than a block. Calling a proc is like
yielding to a block, whereas calling a lambda is like invoking a method. In Ruby 1.9,
you can determine whether a Proc object is a proc or a lambda with the instance method
lambda?. This predicate returns true for lambdas and false for procs. The subsections
that follow explain the differences between procs and lambdas in detail.
6.5.5.1 Return in blocks, procs, and lambdas
Recall from Chapter 5 that the return statement returns from the lexically enclosing
method, even when the statement is contained within a block. The return statement
in a block does not just return from the block to the invoking iterator, it returns from
the method that invoked the iterator. For example:
      def test
        puts "entering method"
        1.times { puts "entering block"; return } # Makes test method return
        puts "exiting method" # This line is never executed
      end
      test
A proc is like a block, so if you call a proc that executes a return statement, it attempts
to return from the method that encloses the block that was converted to the proc. For
example:
      def test
        puts "entering method"
        p = Proc.new { puts "entering proc"; return }
        p.call                    # Invoking the proc makes method return
        puts "exiting method" # This line is never executed
      end
      test
                                                                        6.5 Procs and Lambdas | 197
Using a return statement in a proc is tricky, however, because procs are often passed
around between methods. By the time a proc is invoked, the lexically enclosing method
may already have returned:
     def procBuilder(message)                     # Create and return a proc
       Proc.new { puts message; return } # return returns from procBuilder
       # but procBuilder has already returned here!
     end
     def test
       puts "entering method"
       p = procBuilder("entering proc")
       p.call                       # Prints "entering proc" and raises LocalJumpError!
       puts "exiting method" # This line is never executed
     end
     test
By converting a block into an object, we are able to pass that object around and use it
“out of context.” If we do this, we run the risk of returning from a method that has
already returned, as was the case here. When this happens, Ruby raises a
LocalJumpError.
The fix for this contrived example is to remove the unnecessary return statement, of
course. But a return statement is not always unnecessary, and another fix is to use a
lambda instead of a proc. As we said earlier, lambdas work more like methods than
blocks. A return statement in a lambda, therefore, returns from the lambda itself, not
from the method that surrounds the creation site of the lambda:
     def test
       puts "entering method"
       p = lambda { puts "entering lambda"; return }
       p.call                       # Invoking the lambda does not make the method return
       puts "exiting method" # This line *is* executed now
     end
     test
The fact that return in a lambda only returns from the lambda itself means that we
never have to worry about LocalJumpError:
     def lambdaBuilder(message)                # Create and return a lambda
       lambda { puts message; return } # return returns from the lambda
     end
     def test
       puts "entering method"
       l = lambdaBuilder("entering lambda")
       l.call                       # Prints "entering lambda"
       puts "exiting method" # This line is executed
     end
     test
198 | Chapter 6: Methods, Procs, Lambdas, and Closures
6.5.5.2 Break in blocks, procs and lambdas
Figure 5-3 illustrated the behavior of the break statement in a block; it causes the block
to return to its iterator and the iterator to return to the method that invoked it. Because
procs work like blocks, we expect break to do the same thing in a proc. We can’t easily
test this, however. When we create a proc with Proc.new, Proc.new is the iterator that
break would return from. And by the time we can invoke the proc object, the iterator
has already returned. So it never makes sense to have a top-level break statement in a
proc created with Proc.new:
     def test
       puts "entering test method"
       proc = Proc.new { puts "entering proc"; break }
       proc.call                        # LocalJumpError: iterator has already returned
       puts "exiting test method"
     end
     test
If we create a proc object with an & argument to the iterator method, then we can invoke
it and make the iterator return:
     def iterator(&proc)
       puts "entering iterator"
       proc.call # invoke the proc
       puts "exiting iterator"       # Never executed if the proc breaks
     end
     def test
       iterator { puts "entering proc"; break }
     end
     test
Lambdas are method-like, so putting a break statement at the top-level of a lambda,
without an enclosing loop or iteration to break out of, doesn’t actually make any sense!
We might expect the following code to fail because there is nothing to break out of in
the lambda. In fact, the top-level break just acts like a return:
     def test
       puts "entering test method"
       lambda = lambda { puts "entering lambda"; break; puts "exiting lambda" }
       lambda.call
       puts "exiting test method"
     end
     test
6.5.5.3 Other control-flow statements
A top-level next statement works the same in a block, proc, or lambda: it causes the
yield statement or call method that invoked the block, proc, or lambda to return. If
next is followed by an expression, then the value of that expression becomes the return
value of the block, proc, or lambda.
                                                                       6.5 Procs and Lambdas | 199
redo also works the same in procs and lambdas: it transfers control back to the begin-
ning of the proc or lambda.
retry is never allowed in procs or lambdas: using it always results in a LocalJumpError.
raise behaves the same in blocks, procs, and lambdas. Exceptions always propagate
up the call stack. If a block, proc, or lambda raises an exception and there is no local
rescue clause, the exception first propagates to the method that invoked the block with
yield or that invoked the proc or lambda with call.
6.5.5.4 Argument passing to procs and lambdas
Invoking a block with yield is similar to, but not the same as, invoking a method. There
are differences in the way argument values in the invocation are assigned to the argu-
ment variables declared in the block or method. The yield statement uses yield
semantics, whereas method invocation uses invocation semantics. Yield semantics are
similar to parallel assignment and are described in §5.4.4. As you might expect,
invoking a proc uses yield semantics and invoking a lambda uses invocation semantics:
     p = Proc.new {|x,y| print x,y }
     p.call(1)         # x,y=1:         nil used for missing rvalue:     Prints 1nil
     p.call(1,2)       # x,y=1,2:       2 lvalues, 2 rvalues:            Prints 12
     p.call(1,2,3)     # x,y=1,2,3: extra rvalue discarded:              Prints 12
     p.call([1,2])     # x,y=[1,2]: array automatically unpacked:        Prints 12
This code demonstrates that the call method of a proc handles the arguments it
receives flexibly: silently discarding extras, silently adding nil for omitted arguments,
and even unpacking arrays. (Or, not demonstrated here, packing multiple arguments
into a single array when the proc expects only a single argument.)
Lambdas are not flexible in this way; like methods, they must be invoked with precisely
the number of arguments they are declared with:
     l = lambda {|x,y|    print x,y }
     l.call(1,2)       #  This works
     l.call(1)         #  Wrong number of      arguments
     l.call(1,2,3)     #  Wrong number of      arguments
     l.call([1,2])     #  Wrong number of      arguments
     l.call(*[1,2]) #     Works: explicit      splat to unpack the array
6.6 Closures
In Ruby, procs and lambdas are closures. The term “closure” comes from the early days
of computer science; it refers to an object that is both an invocable function and a
variable binding for that function. When you create a proc or a lambda, the resulting
Proc object holds not just the executable block but also bindings for all the variables
used by the block.
200 | Chapter 6: Methods, Procs, Lambdas, and Closures
You already know that blocks can use local variables and method arguments that are
defined outside the block. In the following code, for example, the block associated with
the collect iterator uses the method argument n:
       # multiply each element of the data array by n
       def multiply(data, n)
         data.collect {|x| x*n }
       end
       puts multiply([1,2,3], 2)   # Prints 2,4,6
What is more interesting, and possibly even surprising, is that if the block were turned
into a proc or lambda, it could access n even after the method to which it is an argument
had returned. The following code demonstrates:
       # Return a lambda that retains or "closes over" the argument n
       def multiplier(n)
         lambda {|data| data.collect{|x| x*n } }
       end
       doubler = multiplier(2)     # Get a lambda that knows how to double
       puts doubler.call([1,2,3]) # Prints 2,4,6
The multiplier method returns a lambda. Because this lambda is used outside of the
scope in which it is defined, we call it a closure; it encapsulates or “closes over” (or just
retains) the binding for the method argument n.
6.6.1 Closures and Shared Variables
It is important to understand that a closure does not just retain the value of the variables
it refers to—it retains the actual variables and extends their lifetime. Another way to
say this is that the variables used in a lambda or proc are not statically bound when the
lambda or proc is created. Instead, the bindings are dynamic, and the values of the
variables are looked up when the lambda or proc is executed.
As an example, the following code defines a method that returns two lambdas. Because
the lambdas are defined in the same scope, they share access to the variables in that
scope. When one lambda alters the value of a shared variable, the new value is available
to the other lambda:
       # Return a pair of lambdas that share access to a local variable.
       def accessor_pair(initialValue=nil)
         value = initialValue # A local variable shared by the returned lambdas.
         getter = lambda { value }          # Return value of local variable.
         setter = lambda {|x| value = x }   # Change value of local variable.
         return getter,setter               # Return pair of lambdas to caller.
       end
       getX, setX = accessor_pair(0) # Create accessor lambdas for initial value 0.
       puts getX[]        # Prints 0. Note square brackets instead of call.
       setX[10]           # Change the value through one closure.
       puts getX[]        # Prints 10. The change is visible through the other.
                                                                              6.6 Closures | 201
The fact that lambdas created in the same scope share access to variables can be a feature
or a source of bugs. Any time you have a method that returns more than one closure,
you should pay particular attention to the variables they use. Consider the following
code:
     # Return an array of lambdas that multiply by the arguments
     def multipliers(*args)
       x = nil
       args.map {|x| lambda {|y| x*y }}
     end
     double,triple = multipliers(2,3)
     puts double.call(2)          # Prints 6 in Ruby 1.8
This multipliers method uses the map iterator and a block to return an array of lambdas
(created inside the block). In Ruby 1.8, block arguments are not always local to the
block (see §5.4.3), and so all of the lambdas that are created end up sharing access to
x, which is a local variable of the multipliers method. As noted above, closures don't
capture the current value of the variable: they capture the variable itself. Each of the
lambdas created here share the variable x. That variable has only one value, and all of
the returned lambdas use that same value. That is why the lambda we name double
ends up tripling its argument instead of doubling it.
In this particular code, the issue goes away in Ruby 1.9 because block arguments are
always block-local in that version of the language. Still, you can get yourself in trouble
any time you create lambdas within a loop and use a loop variables (such as an array
index) within the lambda.
6.6.2 Closures and Bindings
The Proc class defines a method named binding. Calling this method on a proc or
lambda returns a Binding object that represents the bindings in effect for that closure.
                                       More About Bindings
   We’ve been discussing the bindings of a closure as if they were simply a mapping from
   variable names to variable values. In fact, bindings involve more than just variables.
   They hold all the information necessary to execute a method, such as the value of
   self, and the block, if any, that would be invoked by a yield.
A Binding object doesn’t have interesting methods of its own, but it can be used as the
second argument to the global eval function (see §8.2), providing a context in which
to evaluate a string of Ruby code. In Ruby 1.9, Binding has its own eval method, which
you may prefer to use. (Use ri to learn more about Kernel.eval and Binding.eval.)
The use of a Binding object and the eval method gives us a back door through which
we can manipulate the behavior of a closure. Take another look at this code from earlier:
202 | Chapter 6: Methods, Procs, Lambdas, and Closures
     # Return a lambda that retains or "closes over" the argument n
     def multiplier(n)
         lambda {|data| data.collect{|x| x*n } }
     end
     doubler = multiplier(2)       # Get a lambda that knows how to double
     puts doubler.call([1,2,3]) # Prints 2,4,6
Now suppose we want to alter the behavior of doubler:
     eval("n=3", doubler.binding) # Or doubler.binding.eval("n=3") in Ruby 1.9
     puts doubler.call([1,2,3])     # Now this prints 3,6,9!
As a shortcut, the eval method allows you to pass a Proc object directly instead of
passing the Binding object of the Proc. So we could replace the eval invocation above
with:
     eval("n=3", doubler)
Bindings are not only a feature of closures. The Kernel.binding method returns a
Binding object that represents the bindings in effect at whatever point you happen to
call it.
6.7 Method Objects
Ruby’s methods and blocks are executable language constructs, but they are not ob-
jects. Procs and lambdas are object versions of blocks; they can be executed and also
manipulated as data. Ruby has powerful metaprogramming (or reflection) capabilities,
and methods can actually be represented as instances of the Method class. (Metaprog-
ramming is covered in Chapter 8, but Method objects are introduced here.) You should
note that invoking a method through a Method object is less efficient than invoking it
directly. Method objects are not typically used as often as lambdas and procs.
The Object class defines a method named method. Pass it a method name, as a string or
a symbol, and it returns a Method object representing the named method of the receiver
(or throws a NameError if there is no such method). For example:
     m = 0.method(:succ)    # A Method representing the succ method of Fixnum 0
In Ruby 1.9, you can also use public_method to obtain a Method object. It works like
method does but ignores protected and private methods (see §7.2).
The Method class is not a subclass of Proc, but it behaves much like it. Method objects
are invoked with the call method (or the [] operator), just as Proc objects are. And
Method defines an arity method just like the arity method of Proc. To invoke the Method
m:
     puts m.call      # Same as puts 0.succ. Or use puts m[].
Invoking a method through a Method object does not change the invocation semantics,
nor does it alter the meaning of control-flow statements such as return and break. The
                                                                        6.7 Method Objects | 203
call method of a Method object uses method-invocation semantics, not yield semantics.
Method objects, therefore, behave more like lambdas than like procs.
Method objects work very much like Proc objects and can usually be used in place of
them. When a true Proc is required, you can use Method.to_proc to convert a Method to
a Proc. This is why Method objects can be prefixed with an ampersand and passed to a
method in place of a block. For example:
     def square(x); x*x; end
     puts (1..10).map(&method(:square))
                                   Defining Methods with Procs
   In addition to obtaining a Method object that represents a method and converting it to
   a Proc, we can also go in the other direction. The define_method method (of Module)
   expects a Symbol as an argument, and creates a method with that name using the asso-
   ciated block as the method body. Instead of using a block, you can also pass a Proc or
   a Method object as the second argument.
One important difference between Method objects and Proc objects is that Method objects
are not closures. Ruby’s methods are intended to be completely self-contained, and
they never have access to local variables outside of their own scope. The only binding
retained by a Method object, therefore, is the value of self—the object on which the
method is to be invoked.
In Ruby 1.9, the Method class defines three methods that are not available in 1.8: name
returns the name of the method as a string; owner returns the class in which the method
was defined; and receiver returns the object to which the method is bound. For any
method object m, m.receiver.class must be equal to or a subclass of m.owner.
6.7.1 Unbound Method Objects
In addition to the Method class, Ruby also defines an UnboundMethod class. As its name
suggests, an UnboundMethod object represents a method, without a binding to the object
on which it is to be invoked. Because an UnboundMethod is unbound, it cannot be
invoked, and the UnboundMethod class does not define a call or [] method.
To obtain an UnboundMethod object, use the instance_method method of any class or
module:
     unbound_plus = Fixnum.instance_method("+")
In Ruby 1.9, you can also use public_instance_method to obtain an UnboundMethod
object. It works like instance_method does, but it ignores protected and private methods
(see §7.2).
In order to invoke an unbound method, you must first bind it to an object using the
bind method:
204 | Chapter 6: Methods, Procs, Lambdas, and Closures
    plus_2 = unbound_plus.bind(2)  # Bind the method to the object 2
The bind method returns a Method object, which can be invoked with its call method:
    sum = plus_2.call(2)    # => 4
Another way to obtain an UnboundMethod object is with the unbind method of the
Method class:
    plus_3 = plus_2.unbind.bind(3)
In Ruby 1.9, UnboundMethod has name and owner methods that work just as they do for
the Method class.

      <h2>Classes</h2>

      <p>We have introduced classes as templates from which objects can be
      created. A class is typically created with the <code>class</code>
      keyword followed by the class name.

      <figure id=class-keyword>
      <dt>Usage of the <code>class</code> keyword to <i>open</i> a class named
      <code>Dog</code></dt>
        <dd>
          <pre><code>
          class Dog
          end
          </code></pre>
        </dd>
      </figure>

      <p>The <code>Class.new</code> constructor may be used to the same effect
      if it is assigned to a constant.

      <figure id=class-new>
      <dt>Usage of the <code>Class.new</code> constructor to create a class
      named <code>Dog</code></dt>
        <dd>
          <pre><code>
          Dog = Class.new
          </code></pre>
        </dd>
      </figure>

        <h3>Names</h3>
          
          <h4>Rules</h4>
          
          <p>The name of class must: 
            <ul>
              <li>Begin with an uppercase ASCII letter (A-Z) (U+0041..U+005A).
              <li>Not contain a colon (U+003A).
              <li>Not contain an ASCII space character (U+0020)
            </ul>
            <!-- FIXME: Derive and enumerate rules -->

          <p>More generally, a class name consists of an uppercase ASCII
          character, optionally followed by a sequence of other alphanumeric
          characters

          <aside class=warning>
            Class names containing non-ASCII characters cannot be referred to
            from source files using a different encoding. For example, a class
            name containing character U+03BB (<i>GREEK SMALL LETTER LAMDA</i>)
            can only be referenced from source files using the UTF-8 source
            encoding. <!-- FIXME: What about other Unicode character sets? -->
           </aside>

          <h4>Conventions</h4>

          <p>Conventionally class names use camel-case capitalization: The
          initial letter of each word is capitalized, and spaces between the
          words are removed. For example:
          <code>RubyProgrammingLanguage</code> or
          <code>NutsAndBolts</code>.</p>

          <p>A class name is a constant. The use of camel-case for class names
          and uppercase for constant names ensures that the two don't clash.

        <h3>Reopening Classes</h3>

        <p>If <code>class</code> is used with the name of a pre-existing class
        that class is <i>re-opened</i>. If a method is defined in a re-opened
        class with the same name as a pre-existing method in the same class
        the old method is overwritten with the new.

        <figure id=reopened-class>
          <dt>Re-defining a method in an existing class</dt>
          <dd>
            <pre><code>
              'hello'.size #=&gt; 5
              class String
                def size
                  'How long is a piece of string?'
                end
              end
              'hello'.size #=&gt; 'How long is a piece of string?'
            </code></pre>
          </dd>
        </figure>  

        <h3>Anonymous Classes</h3>

        <p>When a constant is used as a class name it has global scope. This
        gives rise to the characteristic described above in <i>Reopening
          Classes</i>. If this behaviour is not desirable, a class can be made
        anonymous by assigning the value of <code>Class.new</code> to a local
        variable, thus restricting the class to the local scope.

        <figure id=anonymous-class>
        <dt>Creating an anonymous class with <code>Class.new</code></dt>
          <dd>
            <pre><code>
              dog = Class.new
              dog.class_eval do
                def bark
                  :woof
                end
              end
              dog.new.bark #=&gt; :woof
            </code></pre>
          </dd>
        </figure>
  
  <h2>References</h2>
    <dl>
      <dt id=refBROWN09>[BROWN09]</dt>
      <dd><cite><a href=//rubybestpractices.com/>Ruby Best Practices</a></cite>,
      G. Brown, O'Reilly Media, 2009.</dd>
      <dt id=refFLAN08>[FLAN08]</dt>
      <dd><cite><a href=//oreilly.com/catalog/9780596516178>The Ruby Programming Language</a></cite>,
      D. Flanagan &amp; Y. Matsumoto, O'Reilly Media, 2008.</dd>
      <dt id=refTHOM09>[THOM09]</dt>
      <dd><cite><a
      href=//books.pragprog.com/titles/ruby3/programming-ruby-1-9>Programming
      Ruby 1.9: The Pragmatic Programmers’ Guide</a></cite>, D. Thomas, et
      al., The Pragmatic Bookshelf, 2009.</dd>
    </dl>
  <body>
</html>

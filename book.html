<!DOCTYPE html>
<!-- vim: set fdm=indent tw=78: --> 
<html>
  <head>
    <title>Ruby</title>
    <meta charset="utf-8"/>
  </head>
  <body>
<h1>Ruby</h1>

<h2>Principles</h2>

<ol>
  <!-- Mention that objects _are_ individualistic? (as opposed to SmallTalk) -->
  <!-- Mention variables? -->
  <li><b>Every value is an object</b>. Numbers, strings, blocks of code,
  methods, times, and files are all examples of values. <!-- Define 'value'
  instead? --> <q>An object consists of a set of operations on some hidden
    data.</q> (<a href=#refMITCHELL04 class=ref>Mitchell</a>, pp. 277). The
  former are <i>methods</i>; the latter <i>attributes</i>. It is a specific
  entity, such as the number 43 or the file <code>/etc/passwd</code>. <!--
  Explain that everything _isn't_ an object -->
  
  <li><b>Objects communicate by sending and receiving messages</b>. A message
  is a request for an object to perform a specific operation. It is
  <i>sent</i> from one object to another.
  
  <li><b>Objects respond to messages by defining methods</b>. <!-- Do we want
  to claim the _object_ defines the method? --> <!-- "defining"? How about
  "invoking"? --> A method is a description of
  how an object can perform a specific operation, i.e. it is the
  <i>method</i> by which the object responds to a message. Typically, an
  object will respond to a message of <i>size</i> by performing the
  instructions in its <i>size</i> method.
  
  <li><b>Every object is an instance of exactly one class</b>. A class is <q>A
    template defining the implementation of a set of objects.</q> (<a
    href=#refMITCHELL04 class=ref>Mitchell</a>, pp. 312) Or, as <a class=ref
    href=#refLIU99>Liu</a> suggests, <q>…a factory that can produce
    programming objects. Each factory makes just one kind of object, or
    product.</q>. An <i>instance of</i> simply describes the class from which
  the object was created, the template that it follows.
  
  <li><b>Classes inherit behaviour (methods) from their superclass</b>.
  Inheritance allows a class to be defined in terms of another (its
  <i>superclass</i>. The former inherits the behaviour of the latter, then
  specialises itself by defining additional behaviour. A <code>Mammal</code>
  class may be a superclass of a <code>Dog</code> class because a dog can do
  everything a mammal can, plus fetch newspapers, etc.
  <li><b>Classes are objects</b>.
  <!-- Is this a fundamental? -->
</ol>

<!-- Chapter on variables? -->


<h2>Messages</h2>

  <p>A message is a <q>request for an object to perform some operation</q> (<a
    href=#refBUDD87 class=ref>Budd</a>, pp. 6). It consists of <q>a
    <i>receiver</i>, a message <i>selector</i>, and zero or more
    <i>arguments</i>.</q> (<a href=#refBUDD87 class=ref>Budd</a>, pp. 16). We
  use the term <i>send</i> to describe the action of making the request: an
  object <i>sends</i> a message to another object. 

  <aside>
    <p><a href=#refLIU99 class=ref>Liu</a> (pp. 2) suggests that it can be
    helpful to envisage messages as telegrams:
    
    <blockquote>
      “Message” is too abstract a word. A better word is <i>telegram</i>. A
      “telegram” is tangible: I can touch it, I can see the information it
      carries, and I can picture the moment it arrives at the door of its
      addressee. It is not some vague electronic-sounding thing like a
      “message”. Therefore, I encourage you to think of an old-fashioned
      telegram whenever you see the term “message”.
    </blockquote>
    <!-- How do we markup the source of the blockquote? -->
  </aside>

  <!-- Integrate this into the text -->
  <p>Dr Alan Kay (1998) explains why messages, not objects, are the <q>big
    idea</q>:

  <blockquote
    cite="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">  
    <p>…Smalltalk is not only NOT its syntax or the class library, it is not
    even about classes. I'm sorry that I long ago coined the term “objects”
    for this topic because it gets many people to focus on the lesser idea.

    <p>The big idea is “messaging” -- that is what the kernal[<i>sic</i>] of
    Smalltalk/Squeak is all about (and it’s something that was never quite
    completed in our Xerox PARC phase). The Japanese have a small
    word—<i>ma</i>—for “that which is in between”—perhaps the nearest English
    equivalent is “interstitial”. The key in making great and growable systems
    is much more to design how its modules communicate rather than what their
    internal properties and behaviors should be. 
  </blockquote>

  <h3>The Distinction Between Messages and Methods</h3>

    <p>A message selector often corresponds to the name of a method in the
    receiver. That is, sending the message <var>s</var> to receiver
    <var>r</var> is equivalent to invoking the method <var>s</var> on
    <var>r</var>. Indeed, <a href=#refFLAN08 class=ref>Flanagan &amp;
      Matsumoto</a> (pp. 178) claim that <q>…methods are called
      ‟messages”</q>. However, this analogy is problematic for the following
    reasons:

    <p>In the definitions of <a href=#refBUDD87 class=ref>Budd</a> (pp. 6), <a
      href=#refHUNT97 class=ref>Hunt</a> (pp. 73), <a href=#refMITCHELL04
      class=ref>Mitchell</a> (pp. 279), and <a href=#refKLAS95 class=ref>Klas
      &amp; Schrefl</a> (pp. 13) <i>message</i> refers to the <i>request</i>
    being made of an object; whereas <a href=#refFLAN08 class=ref>Flanagan &amp;
      Matsumoto</a> use it to refer the means with which the receiver would
    respond to such a request. We prefer what Mitchell terms <q>Smalltalk
      terminology</q> because it is well established in the literature, and the
    basis for Ruby’s misappropriation.

    <p>Further, there is not necessarily a one-to-one correspondence between
    message selector and method name. If the named method does not exist, the
    receiver may respond by sending itself a <code>method_missing</code> message,
    which would contradict this simplistic assertion, but still fulfil the
    request the message represented.

    <p>The proper relation of <i>message</i> to <i>method</i> can be understood
    by Budd's use of the term <i>operation</i>: a method must perform the
    requested operation, invoking whatever method is most appropriate to do so.

    <!-- Expand on this idea: shared vocabulary? -->
    <p>Defining messages in terms of operations also provides the framework for
    our discussion of <i>duck typing</i> later in this chapter.

  <h3>Receivers</h3>

    <p>Every message is sent to a receiver object, which may be explicit or
    implicit.

    <h4>Implicit Receivers</h4>

      <p>If a receiver is not specified an <i>implicit receiver</i> of
      <code>self</code> is assumed. <code>self</code> always refers
      to the current object. Outside of any class definition, i.e. at the top-level,
      the current object is an instance of <code>Object</code>. Inside a class
      definition, but outside of a method definition, the current object is an
      instance of <code>Class</code>. Within a method definition the current object
      is the instance of the containing class.

      <p>There are three situations where the implicit receiver can not be used:

      <ol>
        <li>The message is also a keyword such as <code>class</code>
        <li>The message is used as an lvalue.
        <li>The message name is identical to a local variable. There are other ways
        to disambiguate this case.
      </ol>

      <p>By contrast, the implicit receiver must be used when the message is
      private. <!-- Are _messages_ private? -->
       <!-- TODO: Explain how 'puts "glark"' works in this context? -->

    <h4>Explicit Receivers</h4>

      <p>An explicit receiver is an expression that evaluates to an object. It
      cannot be used when the message is private.

  <h3>Message Selectors</h3>

    <!-- TODO: Clarify that we referto the selector as a Symbol subsequently
    -->

    <!-- TODO: Talk here about "significant names"? Decide what material moves
    from the Method > Names section to here -->

    <p>The message selector is the name of the operation the receiver should
    perform. It is unique to a given object.

    <p>The selector is assumed to be the name of a method defined upon the
    receiver. If a corresponding method is not found in the receiver or its
    parents, the receiver is sent a <code>method_missing</code> message, whose
    arguments are the original message selector and its arguments.

    <p>A message selector may consist of any <code>Symbol</code>, even those
    which are illegal when defining a method with the <code>def</code>
    keyword. Methods with corresponding names can be defined with
    <code>Object#define_method</code>, or such messages can be handled by
    <code>method_missing</code>

    <figure id=sending-a-message>
    <dt>Sending the message <code>:size</code> to a <code>String</code> object. The first example uses
    the standard message sending syntax; the second uses <code>Object#send</code>.
      <dd>
        <pre><code>
          "wool".size #=&gt; 4
          "wool".send(:size) #=&gt; 4
        </code></pre>  
      </dd>
    </figure>


    <h4>Conventions</h4>

  <h3>Tone</h3>

    <p>By convention, a selector with a question mark (<code>?</code>) suffix
    denotes that the message poses a polar question to the receiver. For example,
    <code>Fixnum#odd?</code> asks the receiver whether it is odd, returning
    <code>true</code> if it is; <code>false</code> otherwise. Such messages
    are referred to as <dfn title="predicate message">predicate</dfn>s.

    <p>Following similar convention, a selector with an exclamation mark
    (<code>!</code>) suffix (colloquially called a <i>bang</i>) is used <q>…to
      mark a method as special. It doesn’t necessarily mean that it will be
      destructive or dangerous, but it means that it will require more
      attention than its alternative.</q> <a class=ref
      href=#refBROWN09>[Brown, 2009, pp. 52]</a>. <q>Usually, the method
      without the exclamation mark returns a modified copy of the object it is
      invoked on, and the one with the exclamation mark is a mutator method
      that alters the object in place.</q> <a class=ref
      href=#refFLAN08>[Flanagan &amp; Matsumoto, 2008, pp. 7]</a> 

      <p>Both suffixes are merely <i>conventional</i>, however; they do not
      guarantee that the receiver will respond in the aforementioned manner. For
      example, <code>Float#infinite?</code> returns <code>nil</code> for finite
      numbers, <code>-1</code> for negative infinity, or <code>+1</code> for
      positive infinity. <!-- TODO: Use infinity symbols -->

  <h3>Responding to Messages</h3>

    <p>An object is said to <i>respond to</i> a given message if it expects to
    receive it. The <code>Kernel#respond_to?(<var>selector</var>)</code>
    predicate returns <code>true</code> if a method is defined with the same
    name as the selector; <code>false</code> otherwise. However, by defining
    <code>method_missing</code> an object may respond to a message without
    having a corresponding method defined, making the behaviour of
    <code>Kernel#respond_to?</code> insufficient. The solution is
    <code>Kernel#respond_to_missing?</code>, which is explained later. <!--
    TODO: Link -->

    <p><code>Kernel#respond_to?</code> ignores private methods by default. If it
    is sent with a second argument of <code>true</code>, private methods are
    included in its search.  
    
  <h3>Message Expression Syntax</h3>

    <!-- We're using _message expression_ to describe this syntax... (dfn it?) -->

    <p>The simplest expression for sending a message is
    <code><var>s</var></code>, where <var>s</var> is the message selector.
    Omitting the name of the receiver to which <var>s</var> should be sent
    causes an implicit receiver of <code>self</code> to be assumed. <!-- TODO:
    Link to implicit receiver section -->

    <aside class=note>
      The syntax explained above is potentially ambiguous. If Ruby sees a bare
      identifier, e.g. <code>glark</code>, is that a reference to a local
      variable or an attempt to send a message to <code>self</code>? If Ruby
      has previously seen the identifier being assigned to, e.g. <code>glark =
        2</code>, it is treated as a variable reference; otherwise it is a
      message.
    </aside>

    <p>The receiver can be specified explicitly with the
    <code><var>receiver</var>.<var>selector</var></code> syntax, i.e. the
    message selector is prefixed with the receiver name followed by a period
    (U+002E: <code>.</code>). <var>receiver</var> is an expression which
    evaluates to an object. <!-- TODO: Link to explicit receiver section --> For
    example, <code>"esrever".reverse</code> sends the message
    <code>:reverse</code> to the <code>String</code> <code>"esrever"</code>.
    <code>(1 + 2).odd?</code> sends <code>:odd?</code> to the
    <code>Fixnum</code> <code>3</code>.

    <aside class=note>
      An alternative to the <code><var>receiver</var>.<var>selector</var></code>
      syntax is <code><var>receiver</var>::<var>selector</var></code>, where the
      period (<code>.</code>) is replaced with a double colon (<code>::</code>).
      However, the latter syntax has fallen out of favour due to the confusion
      it creates between message sending and constant reference expressions.
      It is not recommended for use in new code.
    </aside>

    <p>In either case a <code>NoMethodError</code> is raised if the receiver
    neither defines a corresponding method nor defines a
    <code>method_missing</code> method that handles the message.

    <p>A message may be accompanied by one or more <dfn
      id=method-arguments>arguments</var>: variables to be used in the
    resulting computations. Arguments are supplied as a
    parenthesized list of variables separated by commas:
    <code><var>receiver</var>.<var>selector</var>(<var>arg<sub>0</sub></var>,…,<var>arg</var><sub>n</sub>)</code>.
    For example, to send the <code>String</code> <code>"haystack"</code> the
    <code>:include?</code> message with the argument <code>"needle"</code>:
    <code>"haystack".include?("needle")</code>.

    <p>If a message is sent with an unexpected argument list an
    <code>ArgumentError</code> is raised.

    <aside class=note> 
      <p>It is often the case that a message needs to be sent with multiple
      arguments, yet those arguments are stored in an <code>Enumerable</code>
      such as <code>Array</code>.  If the message is sent with just the
      <code>Enumerable</code> argument it will receive a single argument (a
      reference to the <code>Enumerable</code>) rather than the constituent
      elements thereof. The solution is to prefix the <code>Enumerable</code>
      argument with an asterisk (U+002A: <code>*</code>), which in this context
      is termed a <dfn id=splat-operator>splat operator</dfn>, thus expanding
      the <code>Enumerable</code> into its individual elements.

      <!-- TODO: Example -->
      <p>This technique works by sending <code>:to_a</code> to the prefixed
      object, so any object that responds to this message with an
      <code>Array</code> can be used in the same fashion.  
    </aside>

    <p>A message expression followed by a block literal causes the block to be
    sent along with the message. A block literal may be enclosed in curly
    braces (<code>{</code>…<code>}</code>) or a <code>do</code>…<code>end</code>
    construct. These forms are semantically equivalent, however it is
    conventional to use the former for short blocks that fit on a single line,
    and the latter for multi-line blocks.

    <aside class=note>
      <!-- FIXME: Reword in terms of messages -->
      <p>To pass a <code>Proc</code> object to a method expecting an anonymous
      block, prefix the object name with an ampersand ((U+0026:
      <code>&amp;</code>). If the message is sent with multiple arguments this
      <code>Proc</code> must be specified last.

      <p>This technique works by sending <code>:to_proc</code> to the object,
      and using the <code>Proc</code> returned as the block. By extension, any
      object that responds to <code>:to_proc</code> in this manner can be used
      in the same fashion.
      <!-- Point to Symbol#to_proc here? -->
    </aside>

    <h4>Dynamic Invocation with <code>Object#send</code></h4>
      
      <p>A message can also be sent to an object with <code>Object#send</code>,
      i.e. <code><var>receiver</var>.send(<var>selector</var>)</code>. This
      allows the message selector to be determined dynamically, at runtime, as
      opposed to the syntax described above which requires the selector to be a
      literal, embedded in the source. For example: <code>[1, 2,
        3].send(:first)</code> or <code>23.send(:to_s, 16)</code>.

      <figure id=object-send>
      <dt><code>Object#send</code> sends an object a message whose name can be determined at runtime.
      <dd>
        <pre><code>
          name = :size
          # Sends "wool" the :name message
          "wool".name #=&gt; NoMethodError: undefined method `name' for "wool":String
          # Sends "wool" the :size message
          "wool".send(name) #=&gt; 4
        </code></pre>  
      </dd>
      </figure>

      <p><code>Object#public_send</code> performs the same function, but
      raises a <code>NoMethodError</code> if the method is private or
      protected.
      
      <p><!-- __send__ -->
    <h4>Parentheses</h4>

      <p>Parentheses may be omitted from message expressions when doing so does
      not introduce syntactic ambiguity.

      <p>Parentheses are rarely used in message expressions that don't involve
      arguments. For example, <code>'briefcase'.upcase</code> is equivalent to
      <code>'briefcase'.upcase()</code>; the former is the recommended style.
      <!-- TODO: What about if doing so disambiguates the method from a
      variable?  -->

      <p>Parentheses may usually be omitted even when arguments are involved.
      This is mostly a matter of taste.

      <p>A common case when parentheses are <i>required</i> to disambiguate is
      nested message expressions where multiple arguments are involved, such as
      <code><var>a</var> <var>b</var> <var>c</var>, <var>d</var></code>, where
      <var>a</var> and <var>b</var> are selectors. To whom do the arguments,
      <var>c</var> and <var>d</var> belong? Does the programmer mean
      <code><var>a</var>(<var>b</var>(<var>c</var>, <var>d</var>))</code> or
      <code><var>a</var>(<var>b</var>(<var>c</var>), <var>d</var>)</code>? Ruby
      assumes the former. However, even if the programmer agrees with Ruby's
      interpretation, these forms of expressions are seldom as clear to others.
      Therefore, it is recommended to employ parentheses in such cases, even if
      unnecessary, as an aid to legibility.

      <p>When parentheses are used to enclose a message’s arguments, the opening
      parenthesis must immediately follow the selector like so:
      <code><var>selector</var>(<var>arg<sub>0</sub></var>,…,<var>arg<sub>n</sub></var>)</code>.
      Whitespace between <var>selector</var> and <code>(</code> will result in a
      <code>SyntaxError</code>. This is due to a quirk in Ruby’s syntax inasmuch
      as parentheses serve two distinct functions—grouping of expressions and
      associating an argument list with a message expression—so the above form
      represents an ambiguity.

    <h4>Element Reference</h4>

      <p>The <code>[<var>subscript</var>]</code> notation for referring to an
      element of an <code>Array</code> or <code>Hash</code> is called <dfn
        id=element-reference>element reference</dfn> syntax. It is a special
      case of the message expression syntax because it sends a selector named
      <code>:[]</code> to the receiver, passing in the contents of
      <code>[</code>…<code>]</code> as arguments. For example,
      <code>[1,2,3][0]</code> is equivalent to <code>[1,2,3].[](0)</code>.

      <p>Indeed, any object may respond to <code>:[]</code>, allowing it to be
      used in this fashion. 

      <!-- TODO: Example of a #[] method -->

      <p>Similarly, assignment to an element reference sends the
      <code>:[]=</code> selector. For example, where <code>fruit</code> is a
      <code>Hash</code>, <code>fruit[:apple] = :red</code> is equivalent to
      <code>fruit.[]=(:apple, :red)</code>.
    
    <h4>Attribute Accessors and Setters</h4>

    <!-- TODO: Note use of term 'unary' message --> 
    <p>A message without arguments that returns the value of the corresponding
    instance variable, or <dfn id=attribute>attribute</dfn>, in the receiver is
    sometimes referred to as an <dfn id=attribute-accessor>attribute
      accessor</dfn>. For example, <code>person.name</code> is said to return
    the <code>name</code> attribute of the <code>person</code> object.

      <!-- TODO: Link with discussion of _attr_ -->

      <p>There is not necessarily a correspondence between the accessor’s name
      and that of the corresponding instance variable. There is not, for that
      matter, necessarily a corresponding instance variable at all: the
      attribute value might have been computed dynamically, for example. 

      <p>An message with an argument whose selector comprises an
      attribute accessor’s name suffixed with an equals sign (<code>=</code>),
      is called an <dfn id=attribute-setter>attribute setter</dfn>. It sets the
      attribute to the value supplied.

    <!-- TODO: Lookup rules? -->

<h2>Methods</h2>

  <!-- Use Flan&Y's definition of method -->
  <p>A <dfn id=method>method</dfn> is a named block of code associated with an
  object. For now we will define <i>block of code</i> as a sequence of one or
  more statements. It constitutes a response to a message. The relationship
  between methods and messages was explained in the last chapter, so now it is
  suffice to say that sending a message to an object with a corresponding method
  defined is also known as <i>invoking</i> that method, and it is that
  terminology that we will use henceforth.

  <p>A method is invoked for the side-effect it causes, the
  value it returns, or a combination of these factors.  Note that this
  definition encompasses <i>accessor</i> and <i>mutator</i> methods; Ruby
  makes no such distinction.

  <!-- mapping messages to methods -->

    <!-- TODO: Move instructions for _creating_ these methods out of these
    sections -->

  <h3>Instance Methods</h3>

    <p>An instance method is a behaviour of an object. It is typically created
    with the <code>def</code> keyword in the context of a class.

    <aside> 
      It is conventional to employ the <code>Class#method</code> notation when referring to
      instance methods in documentation and prose. For example: <code>Integer#even?</code>.  
    </aside>

    <figure id=def-instance-method>
    <dt>Defining an instance method named <code>bark</code> for the <code>Dog</code> class
      with the <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def bark
              :woof
            end
          end
          Dog.new.bark #=&gt; :woof
        </code></pre>  
      </dd>
    </figure>

  <h3>Singleton Methods</h3>

    <p>A singleton method is bound only to a specific object, as opposed to an
    instance method which is bound to all instances of a class. Indeed, it is
    typically a <i>factory method</i>: a constructor of instances.

    <p>Singleton methods bound to a particular class are known as <i>class
      methods</i>. For instance, <code>File.absolute_path</code> is a class
    method defined on the <code>File</code> class.

    <p>However, a singleton method may be defined on any object. Whereas
    inheritance allows a class to be created that specializes a more
    general class, singleton methods allow creation of an object that
    specializes on a more general object. This is similar in concept to
    prototype-based programming. <!-- TODO: Expand -->

    <aside> 
      It is conventional to employ the
      <code><var>Class</var>.<var>method</var></code> notation when referring
      to singleton methods in documentation and prose. For example:
      <code>File.exists?</code>.  
    </aside>

    <!-- Link to Defining where singleton methods are explained -->

  <h3>Return Values</h3>

    <p>A method is a expression so always returns a value. This is <code>nil</code> if the method was
    defined without a body; the last statement executed otherwise. Multiple values can be returned by
    using an <code>Array</code> as the last statement. 

    <figure id=def-implicit-return>
      <dt>A method which returns the Symbol <code>:to_sender</code>
      <dd>
        <pre><code>
          def elvis
            :to_sender
          end
        </code></pre>
      </dd>
    </figure>

    <figure id=def-implicit-return-multiple>
    <dt>A method which returns multiple values as an <code>Array</code>.
      <dd>
        <pre><code>
          def elvis
            [:to_sender, :hound_dog]
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>A <code>return</code> statement causes <code>nil</code> to be immediately returned to the caller.
    <code>return</code> may be followed by an argument in which case its value is returned instead.  If
    multiple arguments are given they will be returned as an <code>Array</code>. 

    <figure id=def-explicit-return-multiple>
    <dt>A method which explicitly returns multiple values.
      <dd>
        <pre><code>
          def elvis
            return :to_sender, :hound_dog
            # Not reached
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>This gives rise to two conventions:
      <ul>
        <li>A method uses a <code>return</code> statement iff it may return before its last statement.
        <li>A method intended to return a value has that value as its last statement
      </ul>
    </p>

    <!-- TODO: Mention Object#tap -->

  <h3>Names</h3>

      <!-- TODO: Talk about "significant" names here? e.g. to_*,
      inspect, etc.? -->

    <p>Method names begin with a lowercase letter. If they consist of multiple words underscores
    (U+005F: <code>_</code>) are used to separate.

    <aside>
      It is legal for a method name to begin with an uppercase letter, but then they may be confused
      with constants or class names. In fact, several core classes have methods named this way for
      precisely this reason: they provide a syntactical shortcut for constructing instances. For
      example, <code>Array()</code> is a method of <code>Kernel</code> which coerces its argument into
      an <code>Array</code> object.  
    </aside>

      <!-- TODO: Unite this with section on attribute setters -->
    <h4>The <code>=</code> Suffix</h4>

      <p>Methods named with a <code>=</code> suffix can be used in assignment statements as
      <i>lvalues</i>. That is, a method defined as <code>name=(value)</code> on object <code>obj</code>
      can be invoked as <code>obj.name = value</code> or <code>obj.name=(value)</code>.     

      <aside class=warning>
        <p>The syntax <code>name = value</code> is therefore ambiguous. Is the intent
        to assign the value <code>value</code> to the local variable <code>name</code> or to invoke the
        method named <code>name=</code> with <code>value</code> as the argument?

        <p>The resolution is to always invoke a <code>=</code>-suffixed method with an explicit receiver,
        such as <code>self</code>. Alternatively, make it explicit that you are invoking a method with the
        <code>name=(value)</code> syntax.  
      </aside>

  <h3>Operator Methods</h3>

    <p>The operators of conventional programming languages are mostly implemented as methods in Ruby. An
    expression such as <code>3 + 2
      * 10</code>  is evaluated as <code>3.+(2.*(10))</code>, i.e.  <code>2</code> is sent the message
    <code>:*</code> with <code>10</code> as the argument, then <code>3</code> is sent the message
    <code>:+</code> with <code>20</code> as its argument.  Operators implemented in this way are termed
    <dfn id=operator-methods>operator methods</dfn> and are enumerated in the table below.

    <p>Classes can implement their own operator methods by defining a method with the corresponding
    name, which is listed in the <i>Method</i> column below. This name is generally the same as the
    operator symbol, e.g.  <code>+</code> implies a method named <code>:+</code>, but in the case of
    unary methods, e.g. the <code>-</code> in <code>-2</code>, the method name consists of the operator
    with an <code>@</code> suffix.

    <aside class=note>
    <p>The method names detailed in the table are the only examples of legal names which consist solely
    of punctuation. That <code>^</code> and <code>~</code>, for example, are legal characters, does not
    imply that a method named <code>^~</code> is also legal.
    <!-- TODO: Mention += and friends -->
    </aside>

    <table id=operator-methods>
      <tr> <th>Method</th> <th>Operator</th> <th>Description</th> </tr>

      <tr>
        <td><code>[]</code></td>
        <td><code>[</code>…<code>]</code></td>
        <td>Element reference, e.g. <code>[1,2,3][1]</code> subscripting</td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>[]=</code></td>
        <td><code>[</code>…<code>]=</code></td>
        <td>Element set, e.g. <code>{foo: :bar}[:glark] = :quark</code></td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>**</code></td>
        <td><code>**</code></td>
        <td>Exponentiation, e.g. <code>3 ** 2</code></td>
      </tr>

      <tr>
        <td><code>!</code></td>
        <td><code>!</code></td>
        <td>Not, e.g. <code>!pregnant</code></td>
      </tr>

      <tr>
        <td><code>~</code></td>
        <td><code>~</code></td>
        <td>Complement, e.g. <code>~23</code></td>
      </tr>

      <tr>
        <td><code>-@</code></td>
        <td><code>-</code></td>
        <td>Unary minus (negate), e.g. <code>-42</code></td>
      </tr>

      <tr>
        <td><code>+@</code></td>
        <td><code>+</code></td>
        <td>Unary plus, e.g. <code>+(10-20)</code></td>
      </tr>

      <tr>
        <td><code>*</code></td>
        <td><code>*</code></td>
        <td>Multiplication, e.g. <code>10 * 2</code></td>
      </tr>

      <tr>
        <td><code>/</code></td>
        <td><code>/</code></td>
        <td>Division, e.g. <code>20 / 10</code></td>
      </tr>

      <tr>
        <td><code>%</code></td>
        <td><code>%</code></td>
        <td>Modulo, e.g. <code>20.5 % 16</code></td>
      </tr>

      <tr>
        <td><code>+</code></td>
        <td><code>+</code></td>
        <td>Addition, e.g. <code>20.5 + 5.2</code></td>
      </tr>

      <tr>
        <td><code>-</code></td>
        <td><code>-</code></td>
        <td>Subtraction, e.g. <code>20.5 - 5.2</code></td>
      </tr>

      <tr>
        <td><code>&gt;&gt;</code></td>
        <td><code>&gt;&gt;</code></td>
        <td>Right shift, e.g. <code>16 &gt;&gt; 1</code></td>
      </tr>

      <tr>
        <td><code>&lt;&lt;</code></td>
        <td><code>&lt;&lt;</code></td>
        <td>Left shift, e.g. <code>16 &lt;&lt; 1</code></td>
      </tr>

      <tr>
        <td><code>&amp;</code></td>
        <td><code>&amp;</code></td>
        <td>Bitwise AND, e.g. <code>2 &amp; 1</code></td>
      </tr>

      <tr>
        <td><code>^</code></td>
        <td><code>^</code></td>
        <td>Bitwise XOR, e.g. <code>2 ^ 1</code></td>
      </tr>

      <tr>
        <td><code>|</code></td>
        <td><code>|</code></td>
        <td>Bitwise OR, e.g. <code>2 | 1</code></td>
      </tr>

      <!-- TODO: Link the following with Comparable explanation -->
      <tr>
        <td><code>&lt;=</code></td>
        <td><code>&lt;=</code></td>
        <td>Less than or equal to (≤), e.g. <code>10 &lt;= 12</code></td>
      </tr>

      <tr>
        <td><code>&lt;</code></td>
        <td><code>&lt;</code></td>
        <td>Less than, e.g. <code>10 &lt; 12</code></td>
      </tr>

      <tr>
        <td><code>=&gt;</code></td>
        <td><code>=&gt;</code></td>
        <td>Greater than or equal to (≥), e.g. <code>12 =&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&gt;</code></td>
        <td><code>&gt;</code></td>
        <td>Greater than, e.g. <code>12 &gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&lt;=&gt;</code></td>
        <td><code>&lt;=&gt;</code></td>
        <td><i>Spaceship</i> operator, e.g. <code>12 &lt;=&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>==</code></td>
        <td><code>==</code></td>
        <td>Equality, e.g. <code>"wool" == "wool"</code></td>
      </tr>

      <tr>
        <td><code>===</code></td>
        <td><code>===</code></td>
        <td>Case equality, e.g. <code>Array === [1]</code></td>
      </tr>

      <!-- TODO: Mention this inverts == unless defined explicitly -->
      <tr>
        <td><code>!=</code></td>
        <td><code>!=</code></td>
        <td>Not equal, e.g. <code>"bark! != "bite"</code></td>
      </tr>

      <tr>
        <td><code>=~</code></td>
        <td><code>=~</code></td>
        <td>Pattern match, e.g. <code>/\d/ =~ "99"</code></td>
      </tr>

      <!-- TODO: Mention this inverts =~ unless defined explicitly -->
      <tr>
        <td><code>!~</code></td>
        <td><code>!~</code></td>
        <td>Inverted pattern match, e.g. <code>/\d/ !~ "d"</code></td>
      </tr>
    </table>

  <h3>Arity</h3>
    <!-- TODO: Link with Method#arity, Proc#arity -->
    <h4>Classification by Arity</h4>
    <!-- TODO: binary, unary, etc. -->

  <h3>Defining</h3>
    
    <p>A method consists of a name, an optional parameter list, and a body. Names have already been
    discussed, the parameter list is explained in <i>Arguments</i> below. The <dfn
      id=method-body>body</dfn> is a sequence of statements terminated with the <code>end</code>
    keyword. <!-- TODO: Clarify here that due to method_missing method’s need not be defined before
    they are called? -->
    
    <figure id=def-syntax>
    <dt>The syntax of a method definition.
      <dd>
        <pre><code>
          def <var>name</var> (<var>parameters</var>)
            <var>body</var>
          end
        </code></pre>
      </dd>
    </figure>
    
    <!-- TODO: Returns value which is not a method object -->
    
    <p>A singleton method is defined by specifying a method name of the form
    <code><var>object</var>.<var>name</var></code>, where <var>object</var> is
    a reference to the object on which the method is being defined.

    <p>Therefore, <code>def self.<var>name</var></code> defines a class method
    for the current class. <code>def <var>Class</var>.<var>name</var></code>
    defines a method named <var>name</var> on the class named
    <var>Class</var>.

    <aside class=warn>
    Singleton methods cannot be defined on immediate values such as
    <code>Numeric</code>s and <code>Symbol</code>s. Attempting to do so raises
    a <code>TypeError</code>.
    </aside>
    
    <figure id=def-singleton-method>
    <dt>Defining a singleton method named <code>breed</code> for the <code>Dog</code> class with the
    <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def self.breed
              [new, new]
            end
          end
          Dog.breed #=&gt; [#<Dog:0x95cb530>, #<Dog:0x95cb508>]
        </code></pre>  
      </dd>
    </figure>

    <!-- Link with define_singleton_method -->

    <h4>Arguments</h4> 
    
      <p>A method may accept one or more arguments, variables passed in from the caller.

      <p>When a method is defined with the <code>def</code> keyword its name may be followed by a set of
      parentheses (<code>(</code>, <code>)</code>). The contents thereof (hereafter: <dfn
        id=parameter-list>the parameter list</dfn>) dictate the arguments the method will accept. (The
      parentheses are actually optional, but their omission doesn't enhance readability so their presence
      is recommended).

      <p>The parameter list specifies:
      <ul>
        <li>The local variable names (hereafter: <dfn id=parameters>parameters</dfn>) to which the
        corresponding argument will be aliased to inside the method.
        <li>Whether the arguments are required or optional.
        <li>Whether a fixed or variable number of arguments are allowed.
        <li>The default value, if any, of each parameter.
        <li>Whether an argument is expected to be a block.
      </ul>

      <p>Each parameter name must be unique in the parameter list.
      
      <h5>Pass By Reference</h5>

        <p>Arguments are passed to methods by reference instead of value.  If the method modifies an object
        it receives the caller’s copy is modified, too.

        <figure id=pass-by-reference>
          <dt>The effect of a method’s modification of an argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                llama #=&gt; 'arry'
              </code>
            </pre>
          </dd>
        </figure>

        <p>Methods may <i>dup</i> (<code>Object#dup</code>) their arguments to avoid this situation.    

        <figure id=pass-by-reference-dup>
        <dt>The effect of a method’s modification of a <code>dup</code>’d argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.dup.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                <mark>llama #=&gt; 'Larry'</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Required Arguments</h5>

        <p>A <dfn id=required-argument>required argument</dfn> <em>must</em> be supplied by the caller. A
        method which requires exactly 4 arguments must receive them all, otherwise it raises an
        <code>ArgumentError</code>.

        <aside class=note>
          <code>nil</code> and <code>false</code> are as valid an argument any other. If a method requires
          an argument and <code>nil</code> is supplied in its place, Ruby will not complain. Methods wishing
          to prohibit such values must do so themselves.
        </aside>

        <p>Required arguments are specified with a comma-separated list of parameter names. Each parameter
        represents a mandatory argument.

        <figure id=required-arguments>
        <dt>Defining a method which requires exactly two arguments.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def laugh(how, volume)
                    puts volume == :loudly ? how.upcase : how
                  end
                end
                Llama.new.laugh #=&gt; ArgumentError: wrong number of arguments (0 for 2)
                Llama.new.laugh(:snicker) #=&gt; ArgumentError: wrong number of arguments (1 for 2)
                Llama.new.laugh(:chortle,:softly) #=&gt; chortle
                Llama.new.laugh(:guffaw,:loudly) #=&gt; GUFFAW
                Llama.new.laugh(:ho, :ho, :ho) #=&gt; ArgumentError: wrong number of arguments (3 for 2)
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Optional Arguments and Default Values</h5>

        <p>An <dfn id=optional-argument>optional argument</dfn> <em>may</em> be supplied by the caller. If
        it is not, the corresponding parameter will be assigned the value given as its default.

        <p>Optional arguments are specified with a comma-separated list of
        <code><var>name</var>=<var>value</var></code> pairs, where <var>name</var> is a parameter name and
        <var>value</var> is its default value. The <var>value</var> may be any Ruby expression, and is
        permitted to refer to previous parameters. The default value is evaluated each time the method is
        invoked, so may, for example, instantiate an object on every invocation. 

        <figure id=optional-arguments>
        <dt>Defining a method which takes an optional argument.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def name(name='Larry')
                    name + ' the llama (beast of burden)'
                  end
                end
                Llama.new.name #=&gt; "Larry the llama (beast of burden)"
                Llama.new.name('Lyle Jr.') #=&gt; "Lyle Jr. the llama (beast of burden)"
                Llama.new.name('Lama', 'glama') #=&gt; ArgumentError: wrong number of arguments (2 for 1)
              </code>
            </pre>
          </dd>
        </figure>

        <p>Optional and required arguments can be specified alongside each other in a reasonably natural
        fashion. However, all optional arguments must be adjacent. For instance, it is a
        <code>SyntaxError</code> to both precede and follow a required argument with optional arguments.

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Variable-Length Argument Lists</h5>

        <!-- TODO: Standardise on terms: 'rest' or 'splat' -->

        <p>A <dfn id=rest-parameter>rest parameter</dfn> (or <dfn
          id=splat-parameter>splat parameter</dfn>) consumes every argument that follows it while still
        allowing subsequent required parameters to receive their corresponding arguments. Put simply: it
        takes an arbitrary number of arguments from its position onward. It is passed to the method as an
        <code>Array</code> containing one argument per element.

        <aside class=note>

        Rest parameters do not <em>require</em> any arguments, so a method whose parameter list consists
        solely of a rest parameter, for example, may be invoked with zero or more arguments.

        </aside>

        <p>A rest parameter is specified by preceding a parameter name with an asterisk (U+002A:
        <code>*</code>). Only one rest parameter may appear in a parameter list, and it any optional
        parameters must precede it.

        <figure id=rest-arguments>
        <dt>Defining a method which takes a variable number of arguments.</dt>
          <dd>
            <pre>
              <code>
              def zero_or_more(*rest)
                rest.join(', ')
              end
              zero_or_more #=&gt; ""
              zero_or_more(1) #=&gt; "1"
              zero_or_more(1,2,3) #=&gt; "1, 2, 3"
              </code>
            </pre>
          </dd>
        </figure>

        <!-- TODO: Cut this section? We now state above that any optional
        arguments must precede the _rest_ -->

        <aside class=note>
          The following syntax rules are complex, but do not be deterred.  They are unlikely to ever be
          relevant in practice.
        </aside>

        <!-- FIXME: Clarify this explanation; derive a general principle
        which better expresses the rule -->

        <p>A rest parameter must not be followed by an optional parameter because of the resulting
        ambiguity: if two or more arguments were supplied for the former, should the latter be assigned its
        default value or take one of the aforementioned? However, there is no ambiguity when optional
        parameters precede the rest parameter, so this arrangement is legal.

        <p>Conversely, a rest parameter may be either followed or preceded by one or more required
        parameters

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

        <p>A rest parameter may be supplied as a sole asterisk, omitting the corresponding parameter name.
        The effect is to consume the corresponding arguments as an ordinary rest parameter, without
        assigning them to a local variable. The arguments are ignored.  This allows methods to accept an
        arbitrary number of arguments, but discard, say, all but the last. 

        <p>Thomas et al. (<a href=#refTHOM09>[THOM09]</a>) suggest that this technique can used in
        conjunction with <code>super</code> to define a method which accepts an arbitrary number of
        arguments then passes them all to its superclass.

        <figure id=rest-parameter-with-super>
        <dt>A method which accepts a variable number of arguments then passes them to its superclass
        (<code>Parent</code>) with the implicit-argument form of <code>super</code>. (<a
          href=#refTHOM09>[THOM09]</a>).
          <dd>
            <pre>
              <code>
                class Child &lt; Parent
                  def do_something(*)
                    # our processing
                    super
                  end
                end
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Named Arguments</h5>

        <p>The parameter forms described above are positional in nature.  They depend on the argument’s
        location in the parameter list to marry it with the correct parameter. An alternative approach, that
        can aid the readability of otherwise ungainly parameter lists, is <dfn id=named-arguments>named
          arguments</dfn>. Named arguments allow the method to be invoked with a series of key-value pairs,
        arranged in an arbitrary order.

        <p>Ruby does not offer explicit support for this style of argument passing, but it can be ably
        approximated by defining methods that expect a <code>Hash</code> argument: the keys of which become
        the parameter names; and the values, the arguments.

        <!-- TODO: Mention that File/IO, String#encode use this technique -->

        <figure id=named-arguments>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments.
          <dd>
            <pre>
              <code>
                class Chair
                  def initialize(args)
                    @legs = args[:legs] or raise ArgumentError
                    @style = args[:style] || :victorian
                    @height = args[:height] || :average
                    @colour = args[:colour] || args[:color] || :brown
                  end
                end
              Chair.new legs: 4, height: :tall #=&gt; 
                #&lt;Chair:0x8249908 @legs=4, @style=:victorian,
                @height=:tall, @colour=:brown&gt;
              Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                #&lt;Chair:0x86958f4 @legs=7, @style=:victorian,
                @height=:average, @colour=:fuschia&gt;
              Chair.new(height: :childs, color: :fuschia) #=&gt;
              ArgumentError 
              </code>
            </pre>
          </dd>
        </figure>

        <p>If the <code>Hash</code> is the final argument, other than a block, that a method expects, the
        curly braces which delimit the <code>Hash</code> can be omitted. For example, <code>m({ key:
          :value })</code> can be written as <code>m key: :value</code>.

        <p>The advantages of this approach include:
          <ul>
            <li>Arguments can be specified in any order.
            <li>Arguments with default values can be omitted.
            <li>If <code>Symbol</code>s are used for the <code>Hash</code> keys the invocation is
            particularly readable.
            <li>Variable-length argument lists are supported.
          </ul>

        <figure id=named-arguments-with-defaults>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments with default
        values.
          <dd>
            <pre>
              <code>
                class Chair
                  DEFAULT_ARGS = {legs: 2, style: :victorian, height: :average, colour: :brown}
                  def initialize(args)
                    @attributes = DEFAULT_ARGS.merge args
                  end
                end
                Chair.new legs: 4, height: :tall #=&gt;
                  #&lt;Chair:0x9039af4 @attributes={
                  :legs=&gt;4,       :style=&gt;:victorian, 
                  :height=&gt;:tall, :colour=&gt;:brown
                  }&gt;
                Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                  #&gt;Chair:0x998a9dc @attributes={
                  :legs=&gt;7, :style=&gt;:victorian, 
                  :height=&gt;:average, :colour=&gt;:fuschia
                  }&gt;
              </code>
            </pre>
          </dd>
        </figure>

        <p>The primary shortcoming is that Ruby can not determine automatically whether an invalid number of
        arguments have been supplied; the programmer must validate the arguments instead. This is unlikely
        to be particularly significant, however, because a method expecting a variable number of arguments
        would otherwise use rest arguments, which would also render it unable to perform this validation.

      <h5>Block Arguments</h5>
        
        <p>Any method may be invoked with a block literal as an argument by specifying the block after the
        method invocation.

        <aside class=note>
        <a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
          130-131)</a> insist on <q>[using] the term iterator…to mean any method that uses the
          <code>yield</code> statement</q>, despite admitting that this doesn't make sense if the method
        doesn’t actually <i>iterate</i> over the block it has been given. We will not perpetuate this
        confusion: an <i>iterator method</i> iterates over the block it has been given; a method which
        expects a block but does not iterate over it is simply <i>a method that expects a block</i>.
        </aside>

        <figure id=method-invocation-with-block-literal>
        <dt>A method which receives, and ignores, a block specified with either of the block literal
        constructs.
          <dd>
            <pre>
              <code>
              def m
                :m
              end
              m { 1 + 2 }
              m do
                1 + 2
              end
              </code>
            </pre>
          </dd>
        </figure>
         
        <p>The method may determine whether it has received a block by using the <code>block_given?</code>
        predicate.

        <figure id=method-using-block_given>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block.
          <dd>
            <pre>
              <code>
              def m
                puts "Thanks" if block_given?
              end
              m { 1 + 2 } #=&gt; "Thanks"
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A block passed to a method in this way is not automatically called; the method must use the
        <code>yield</code> keyword to do so. An implication of this is that methods not expecting blocks
        will ignore them. The return value of <code>yield</code> is that of the block.

        <!-- TODO: Mention that yield takes arguments -->

        <figure id=method-using-block_given-yield>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block, and if so calls it.
          <dd>
            <pre>
              <code>
              def m
                puts "This block returns: #{yield}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A method needing a reference to the block it was given, perhaps to pass to another method, is
        defined with a final parameter whose name is prefixed with an ampersand (U+0026:
        <code>&amp;</code>).  For example: <code> def m(a,b,&amp;block)</code>. The method can access the
        block as a <code>Proc</code> object named after the parameter (sans ampersand). It may invoke the
        block via its <code>Proc#call</code> method, or <code>yield</code> to it. In either case, the method
        is invoked in precisely the same way as before.

        <!-- Example with instance_eval ? -->

        <figure id=method-using-block-argument>
        <dt>A method which uses a <code>&amp;block</code> parameter to refer to the block it is given.
          <dd>
            <pre>
              <code>
              def m(&amp;block)
                puts "This block returns: #{block.call}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <aside class=note>

        <p>The discussion above applies only to block literals; a method expecting a <em>reference</em> to a
        block, i.e. a <code>proc</code> or <code>lambda</code>, need not pay heed. Such a method employs
        precisely the same parameter list as in the previous sections.

        <figure id=method-receiving-block-ref>
        <dt>A method which expects a reference to a block uses the same parameter list as it would if
        expecting any other type of variable.
          <dd>
            <pre>
              <code>
              def m(b)
                b.call
              end
              m -&gt;{ "I am a \u{3bb}!" } #=&gt; "I am a λ!"
              </code>
            </pre>
          </dd>
        </figure>

        </aside>

    <h4>Dynamic Method Definition</h4>

      <p>An instance method can be defined dynamically with
      <code>Module#define_method(<var>name</var>, <var>body</var>)</code>, where <var>name</var> is the
        method’s name given as a <code>Symbol</code>, and <var>body</var> is its body given as a
        <code>Proc</code>, <code>Method</code>, <code>UnboundMethod</code>, or literal block. This
        allows methods to be defined at runtime, in contrast to <code>def</code> which requires the
        method name and body to appear literally in the source code.

      <figure id=define-method>
      <dt>Using <code>define_method</code> to dynamically create a method with a user-supplied
      name and body.
        <dd>
          <pre>
            <code>
            class Conjure
              def self.conjure(name, lamb)
                define_method(name, lamb)
              end
            end
            # Define a new instance method with a lambda as its body
            Conjure.conjure(:glark, -&gt;{ (3..5).to_a * 2 })
            Conjure.new.glark #=&gt; [3, 4, 5, 3, 4, 5]         
            </code>
          </pre>
        </dd>
      </figure>

      <p><code>Module#define_method</code> is a private method so must be called from within the class
      the method is being defined on. Alternatively, it can be invoked inside
      <code>class_eval</code> like so:
  
      <figure id=define-method-class-eval>
      <dt>Using <code>define_method</code> inside <code>class_eval</code> to dynamically create
      a method with a user-supplied name and body.
        <dd>
          <pre>
            <code>
            Array.class_eval do
              define_method(:second, -&gt;{ self.[](1) })
            end
            [3, 4, 5].second #=&gt; 4
            </code>
          </pre>
        </dd>
      </figure>
        
      <p><code>Object#define_singleton_method</code> is called with a class name as the receiver and
      the same arguments as <code>Module#define_method</code> for the obvious purpose. 

      <figure id=define-singleton-method>
      <dt>Using <code>define_singleton_method</code> to dynamically create a method.
        <dd>
          <pre>
            <code>
            File.define_singleton_method(:match) do |file, pattern|
              File.read(file).match(pattern)
            end
            File.match('/etc/passwd',/root/) #=&gt; #&lt;MatchData "root"&gt;
            </code>
          </pre>
        </dd>
      </figure>

  <h3>Undefining</h3>

    <!-- Distinguish between undefining and removing -->

    <p>The <code>undef</code> statement takes one or more <code>Symbol</code>s
    as arguments, then undefines the corresponding instance methods. It does
    not work with singleton methods.

    <figure id=undef-method>
    <dt>Undefining a method with <code>undef</code>.
      <dd>
        <pre><code>
        def boo!
          "(goose)"
        end
        boo! #=&gt; "(goose)"              
        undef :boo!
        boo! #=&gt; NoMethodError: undefined method `boo!' for main:Object 
        </code></pre>
      </dd>
    </figure>

    <p>Undefining a method defined in a superclass does not affect the
    superclass’s definition. For example, consider a <code>Rectangle</code>
    class which defines <code>:height</code> and <code>:width</code> methods.
    A <code>Square</code> class inherits from it, but it doesn't make sense
    for <code>Square</code> to have both <code>:height</code> <i>and</i>
    <code>:width</code> methods.  <code>Square</code> can <code>undef</code>
    <code>:height</code>, preventing <code>Square#height</code> from being
    called without affecting <code>Rectangle#height</code>.

  <h3>Visibility</h3>

    <p>An instance method is either <i>public</i>, <i>private</i>, or <i>protected</i>. It is declared
    as such with <code>Module#public</code>, <code>Module#private</code>, and
    <code>Module#protected</code> (hereafter: <i>visibility
      specifiers</i>), respectively.

    <p>A visibility specifier invoked without arguments affects every method subsequently defined in the
    same class definition until another visibility specifier is encountered.

    <figure id=visibility-specifiers>
      <dt>Declaring the visibility of methods with visibility specifiers
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          private
          # This method is private because it appears after the
          #'private' visibility specifier
          def pri
          end

          # This method is also private because the previous visibility
          # specifier has not been overridden
          def pri2
          end

          protected
          # This method is protected because it appears after the
          #'protected' visibility specifier
          def pro
          end
          
          public
          # This method is public because the protected visibility
          # specifier has been explicitly overridden. Typically this would
          # have been defined after 'pub', removing the need for a
          # visibility specifier
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <p>A visibility specifier with one or more method names (given as <code>Symbol</code>s or
    <code>String</code>s) affects only the named methods, which must have already been defined.

    <figure id=visibility-specifiers-args>
      <dt>Declaring the visibility of methods with visibility specifiers that take arguments
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          def pri
          end

          def pri2
          end

          # Both :pri and :pri2 are made private because their names are
          # given as arguments to the 'private' visibility specifier
          private :pri, :pri2

          def pro
          end
          # This method is made protected because its name is given to
          # the 'protected' visibility specifier
          protected 'pro'
          
          # This method is public because it hasn't been declared
          # otherwise; the previous 'protected' specifier only affects the
          # method it was called for
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <h4>Advisory Privacy</h4>

      <p>Method visibility is merely an advisory construct. Ruby does not <i>prohibit</i> the invocation
      of private methods; she ensures that they will not be called accidentally as follows:

      <ul>
        <li>Standard method invocation syntax (<code>obj.method</code>) raises a
        <code>NoMethodError</code>, signaling that the programmer's intent is ill-advised. The caviller
        programmer must use a technique such as <code>Object#send</code> to explicitly ignore the privacy
        advice.
        <li>The method introspection API (e.g.
        <code>Object#private_methods</code>,
        <code>Object#protected_methods</code>, and
        <code>Object#public_methods</code>) delineates methods by their visibility, allowing private and
        protected methods to be determined automatically.
        <li>RDoc/<code>ri</code> only displays public methods by default.
      </ul>

    <h4>Public Methods</h4>

      <p>A method is public unless explicitly declared otherwise, or declared outside of a class
      definition. The <code>initialize</code> method is private by default.

    <h4>Private Methods</h4>

      <p>A <dfn id=private-method>private method</dfn> cannot be invoked with an explicit receiver.
      Therefore it can only be called by other instance methods of the class in which defined,
      or a subclass thereof. 

      <p><code>self</code> is also regarded as an explicit receiver so a method invocation of the form
      <code>self.<var>private</var></code>, where <var>private</var> is a private instance method in the
      same class, is disallowed.

      <aside class=note>
      Methods created outside of a class or module definition, i.e. at the top level, are private by
      default The <code>:initialize</code> method is, too, because it is only intended to be invoked
      from the object’s <code>:new</code> method.
      </aside>

    <h4>Protected Methods</h4>

      <p>Protected methods can invoked only from the class in which they were defined or a subclass
      thereof, that is they behave the same as private methods. However, unlike private methods they can
      be explicitly invoked on any instance of their class.

      <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
        232)</a> suggest that <q>A protected method can be used, for example, to define an accessor that
        allows instances of a class to share internal state with each other, but does not allow users of
        the class to access that state.</q>

  <h3>Aliases</h3>

    <p>An <dfn id=method-alias>alias</dfn> of a method is an alternate name by which it can be referred.
    For a method, <var>m</var>, and its alias, <var>a</var>, invoking <var>m</var> is equivalent to
    invoking <var>a</var>.

    <p>The alias refers to a copy of the existing method’s body. If the existing method is redefined
    after being aliased, the alias will continue to refer to the method’s original definition.

    <p>Aliases are often used to provide synonyms for method names. For instance, <code>:size</code> may
    be aliased to <code>:length</code>.  This allows the programmer to use method names which “read”
    more naturally in a given context. <!-- TODO: example from FLAN09 about Range#include? ? -->

    <p>An alias is created with the <code>alias</code> keyword from inside the class of the existing
    method. The syntax is <code>alias <var>new_name</var>
      <var>current_name</var></code>, where both <var>new_name</var> and <var>current_name</var> are
    <code>Symbol</code>s or identifiers. A method named <var>current_name</var> must already be defined.
    If a method named <var>new_name</var> already exists it is overwritten.

    <!-- TODO: Mention alias_method_chain ? -->
    <!-- TODO: Mention alias_method ? -->

    <p>Aliasing is also used to create a method which wraps the method of the same name by performing
    its own computations then calling the original method. For example, in the example below we wrap
    <code>String#to_i</code> such that it raises an exception if the string doesn't contain digits.
    (Normally, <code>String#to_i</code> returns <code>0</code> for such strings).

    <figure id=alias-for-wraping>
    <dt>Using <code>alias</code> in order to wrap a method
      <dd>
        <pre><code>
        class String
          alias :old_to_i :to_i
          def to_i
            raise "No digits found" unless match(/\d/)
            old_to_i
          end
        end
        </code></pre>
      </dd>
    </figure>

    <!-- TODO: Link with example of using method objects to wrap methods
    (c.f.
    http://blog.jayfields.com/2006/12/ruby-alias-method-alternative.html);
    explain pros/cons -->

  <!-- TODO: Discuss method overloading? -->

  <!-- TODO: Algo. for determining a method's aliases -->
  <h3>Lookup Algorithm</h3>
  
    <p>Evaluating a message expression requires the corresponding method
    definition be located in the receiver. The steps below illustrate the
    lookup algorithm for a message with a selector of <var>selector</var>, where
    <var>class</var> is set to that of the receiver. When a method is found
    whose name is equal to <var>selector</var> the process terminates. It will
    always ultimately succeed because <code>BasicObject</code> defines a
    <code>:method_missing</code> method.

    <ol>
      <li>Search the singleton methods of <var>class</var>’s eigenclass.
      <li>Search the singleton methods of the superclass, and ancestors, of
      <var>class</var>’s eigenclass.
      <li>Search the instance methods of <var>class</var>.
      <li>Search the instance methods of modules included by <var>class</var>. (Modules
      are searched in reverse order of inclusion).
      <li>If <var>class</var> has a superclass, assign it to <var>class</var>
      then go to step three. (<code>BasicObject</code> doesn't have a superclass,
      so at that point this step will terminate).
      <li>Set <var>selector</var> to <code>:method_missing</code>, 
      <var>class</var> back to the receiver’s class, and go to step one.
    </ol>

    <p><a href=#refTHOM09 class=ref>Thomas et al.</a> describe this
    algorithm as <q>Ruby looks first in the immediate class of an object, then
      in the mixins included into that class, and then in superclasses and
      their mixins. If a class has multiple modules mixed in, the last one
      included is searched first.</q>

  <h3>Missing Methods</h3>

    <p>By default a <code>NoMethodError</code> is raised when an object
    receives a message for which a corresponding method is not defined.
    Beforehand the object tries to send itself a <code>:method_missing</code>
    message, with a <code>Symbol</code> of the original message selector as
    the first argument, followed by the original message’s arguments. So, by
    defining a method named <code>method_missing</code> an object is able to
    override the default behaviour, providing its own response to the message.

    <p>If the object does not define <code>method_missing</code> it is
    searched for along the usual search path. At the top of the class
    hierarchy, <code>BasicObject</code>, <code>method_missing</code> is
    defined to raise a <code>NoMethodError</code> for the original message.
    This terminates the search and provides the default behaviour.

    <figure id=basicobject-method_missing>
    <dt>A demonstration of <code>BasicObject#method_missing</code>
    <dd>
        <pre><code>
        class BasicObject
          public :method_missing
        end
        b = BasicObject.new
        b.method_missing :glark #=&gt; NoMethodError: undefined method `glark' for #<BasicObject:0x93ace0c>
        </code></pre>
      </dd>
    </figure>
    
    <p>Therefore, if <code>method_missing</code> is invoked with a message it
    does not wish to respond to, it should use the implicit-argument form of
    <code>super</code> to delegate to its parent. This gives the parent the
    option of responding to the message, or otherwise triggers the default
    behaviour. 

    <aside class=warn>
      Logic errors inside <code>method_missing</code> can easily lead to
      infinite loops, which can be troublesome to debug. The typical mistake
      is for a statement in the body of <code>method_missing</code> to send a
      non-existent message to the same object. The object does not respond to
      that message, so the <code>method_missing</code> method is invoked a
      second time, and so the loop continues.
    </aside>

    <!-- TODO: Mention "Dynamic Reception" idea of Fowler -->
    <!-- TODO: Link with #respond_to_missing? -->
    <!-- TODO: Mention NoMethodError#args and #name -->

  <h3><code>BasicObject#respond_to_missing?</code></h3>

  <p>A consequence of defining methods dynamically by means of
  <code>BasicObject#method_missing</code> is that an object may respond to a
  given message, yet return <code>false</code> for
  <code>Kernel#respond_to?(<var>selector</var>)</code>.

  <p>Before <code>Kernel#respond_to?</code> returns <code>false</code> it
  tries to send itself a message named <code>:respond_to_missing?</code> with
  the selector in question as the first argument. If
  <code>#respond_to_missing?</code> is defined and returns a true value,
  <code>#respond_to?</code> returns <code>true</code>; otherwise
  <code>#respond_to?</code> returns <code>false</code>. 

  <p>By default <code>#respond_to_missing?</code> excludes private methods
  from its search. If sent with a second argument of <code>true</code>,
  private methods should be considered. 

  <p>Therefore, <code>#respond_to?</code> can be made to work with methods
  defined with <code>method_missing</code> by defining a
  <code>#respond_to_missing?</code> method which returns <code>true</code>
  when passed the name of such a method.

  <h3><code>Method</code> Objects</h3>

  <p>An instance of the <code>Method</code> class represents a method bound to an object. This <dfn
      id=method-object>method
      object</dfn> enables you to store a reference to a method in a variable, as you would any other
    object, query the method’s metadata, and manipulate it. This is quite distinct from capturing the
    return value of a method. <!-- TODO: Note that unlike procs, method objects aren't closures -->

    <p>Method objects can be created with <code>Kernel#method</code>:
    <code><var>receiver</var>.method(<var>name</var>)</code>, where <var>name</var> is the method
    name as a <code>Symbol</code> or <code>String</code>. For example, <code>method(:eval)</code>
    returns a <code>Method</code> object for <code>Kernel#eval</code>. If the object does not
    <code>respond_to?</code> the given method a <code>NameError</code> will be raised. (Therefore,
    if the object’s <code>respond_to_missing?</code> method returns <code>true</code> for the method
    in question the method object will be created successfully).

    <p><code>Kernel#public_method</code> works in the same way, but raises a <code>NameError</code>
    if the given method is private or protected.

    <h4>Arity</h4>

      <p><code>Method#arity</code> returns an <code>Integer</code> corresponding to the method’s arity. If
      the method expects a fixed number of arguments, the number of arguments it expects will be returned.
      If the method expects a variable number of arguments, the additive inverse of its parameter count
      will be returned. Methods implemented in C, i.e.  most core methods, have an arity of
      <code>-1</code> if they accept a variable number of parameters. It follows, then, that a return
      value ≥ 0 indicates a fixed number of parameters; a negative value, a variable number. 

    <h4>Calling</h4>

      <p>The method represented by a <code>Method</code> object can be invoked with
      <code>Method#call</code> or its alias <code>Method#[]</code>. The semantics are the same as
      for standard method invocation. <a href=#refFLAN08>Flanagan &amp; Matsumoto</a> caution,
      however: <q>…invoking a method through a <code>Method</code> object is less efficient than
        invoking it directly.</q>

    <h4>Converting to a <code>Proc</code></h4>
      
      <p>A method object can be converted to a <code>Proc</code> by prefixing it with an ampersand
      (<code>&amp;</code>). Therefore it can be passed to a method expecting a block. <!-- TODO: Note
      availability of Symbol:to_proc; use with define_method -->
    
    <h4>Equality</h4>

      <!-- Bug: #1898 -->
      <p><code>Method#==</code> returns true if both methods are bound to the same object and have
      the same body. The first requirement means that the objects must be identical in the sense of
      <code>Object.equal?</code>. The second encompasses methods defined with
      <code>Object#define_method</code> using the same <code>Proc</code>/block, aliases created
      with <code>alias</code>, and core method aliases. <!-- TODO: clarify situation with
      #respond_to_missing? -->

    <h4>Source Location</h4>

      <p>The filename and line number where a method was defined is returned as an <code>Array</code>
      by <code>Method#source_location</code>. If the method is core, i.e. implemented in C, it returns
      <code>nil</code>. This is primarily useful for extracting a method’s signature and any preceding
      documentation.

    <h4>Parameters</h4>

      <!-- [ruby-core:19759] Proposal: Method#get_args -->   
        
      <p><code>Method#parameters</code> returns an <code>Array</code>, each element of which is a
      sub-<code>Array</code> of <code>Symbol</code>s that describe the corresponding parameter
      expected by the method. The first <code>Symbol</code> is <code>:req</code> for a required
      parameter, <code>:opt</code> if it is optional, <code>:rest</code> if its of variable length,
      or <code>:block</code> if it corresponds to a block. The last <code>Symbol</code> is the name
      of the parameter. An empty <code>Array</code> is returned for method’s expecting no arguments.

  <h3><code>UnboundMethod</code> Objects</h3>

    <p>An <code>UnboundMethod</code> object is a <code>Method</code> object disassociated from the
    object on which it was defined.     
     
    <p>A <code>Method</code> object may converted to an
    <code>UnboundMethod</code> object with <code>Method#unbind</code>.
    Alternatively, they can be created with
    <code>Module#instance_method</code>. For example,
    <code>String.instance_method(:downcase)</code> creates an
    <code>UnboundMethod</code> object for <code>String#downcase</code>.
    <code>Module#public_instance_method</code> works in the same way, but
    raises a <code>NameError</code> if the given method is private or
    protected. 
      
    <p>Before an <code>UnboundMethod</code> is invoked it must be re-associated with, or <dfn
      id=method-bind>bound</a> to, to an object which is a <code>Object#kind_of?</code> its original
    class. This is achieved by passing an object reference to <code>UnboundMethod#bind</code>.

    <p>With the exception of <code>#call</code>, for the reason described above,
    <code>UnboundMethod</code> objects support the same method’s as <code>Method</code> objects.

    <p><a href=#refBLACK09>Black</a> (pp. 418-420) provides the following example (with minor
    adjustments for formating) of using <code>UnboundMethod</code> objects:
      
    <blockquote>
        
      <p>The following question comes up periodically in Ruby forums:
        
      <blockquote>
        <p>Suppose I’ve got a class hierarchy where a method gets redefined:
          
        <pre><code>
         class A
          def a_method
            puts "Definition in class A"
          end
         end
         class B &lt; A
          def a_method
            puts "Definition in class B (subclass of A)"
          end
         end
         class C &lt; B
         end
         </code></pre>
          
        <p>And I’ve got an instance of the subclass (<code>c = C.new</code>). Is there any way to
        get that instance of the lowest class to respond to the message (<code>a_method</code>) by
        executing the version of the method in the class two classes up the chain?
        
      </blockquote>
        
      <p>By default, of course, the instance doesn’t do that; it executes the first matching method
      it finds as it traverses the method search path: <code>c.a_method</code>. The output is
      <samp>Definition in class B (subclass of A)</samp>. But you can force the issue through an
      unbind and bind operation: <code>A.instance_method(:a_method).bind(c).call</code>. Here the
      output is <samp>Definition in class A</samp>.
      
    </blockquote>

<h2>Objects</h2>
  <!-- Discuss immediate values: objects can be constructed via message
  sending (constructors), which may be instance or singleton methods, or via
  literals -->

  <p>An <dfn id=object>object</dfn> is a compilation of data (attributes) and behaviour (methods)
  which encapsulate a specific <i>instance</i> of a <i>class</i>. The String <code>"hello"</code> and
  the Integer <code>3</code> are both examples of objects, and instances of the <i>String</i> and
  <i>Integer</i> classes, respectively. They constitute data (<q>hello</q> and <q>3</q>, respectively)
  and behaviour relevant to that data.

  <h3>Instantiation</h3>
    <h4>Literals</h4>
      <h5>Immediates</h5>
    <h4>Constructors</h4>
      <h5><code>.new</code></h5>
        <!-- Relationship between initialize and new; pseudo code showing that
        the return value of initialize is ignored -->
    <!-- Pickaxe pp. 427: Hook for object creation -->
    <h4>Allocation</h4>

  <h3>Identity</h3>      
    <ol>
      <li>object_id
      <li>ObjectSpace._id2ref
      <li>hash
      <li>Hash#compare_by_identity
    </ol>

  <h3>Equality</h3>      
    <ol>
      <li>==
      <li>===
      <li>eql?
      <li>equal?
    </ol>

  <h3>Comparison</h3>
    <ol>
      <li>&lt;=&gt;
      <li>Comparable
    </ol>

  <h3>Type</h3> <!-- Does this belong in Class section -->
    <ol>
      <li>Classes are not types
      <li>is_a?
      <li>kind_of?
      <li>Duck typing
    </ol>

  <h3>Instance Variables</h3>
    <ol>
      <li>Scope
      <li>#instance_variables
      <li>#instance_variable_get
      <li>#instance_variable_set
    </ol>

  <h3>References / Garbage Collection</h3>
  
  <h3>BasicObject</h3>

  <h3>Attributes</h3>
    <ol>
      <li>attr
      <li>attr_writer
      <li>attr_reader
    </ol>

  <h3>Copying</h3>
    <ol>
      <li>Object#dup
      <li>initialize_copy
    </ol>

  <h3>Cloning</h3>
    <!-- Object#clone -->

  <h3>Freezing / Mutability</h3>
    <ol>
      <li>No 'thaw'
      <li>Acts on objects; not variables
    </ol>

  <h3>Marshaling</h3>
    <h4>marshal_dump</h4>
    <h4>marshal_load</h4>

  <h3>Tainting</h3>
  
  <h3>Trusting</h3>

  <h3>Defining Methods On</h3>

  <h3>Listing Methods</h3>

  <h3><code>instance_eval</code>/<code>instance_exec</code></h3>

  <h3>Extending</h3>

  <h3>ObjectSpace</h3>
  <!-- [ruby-core:19600] -->
  ObjectSpace.each_object(o) do
   if o.is_a?(IO)
     o.close rescue nil
   end
  end

  <h3>Context</h3>
  <ol>
    <li>Instance eval/exec
    <li>Class eval/exec
    <li>Module eval/exec
  </ol>
  <!-- Or should the last two be dealt with in Classes and Modules? -->

  <h3>Conversion Protocols</h3>

  <p>Selectors whose names begin with <i>to_</i> are expected to return
  the receiver converted to an object of the indicated class. A conversion
  is either <i>implicit</i> or <i>explicit</i>, as explained below:
 
  <section>
    <h4>Implicit Conversion</h4>
    
    <p>A method may expect an argument of a particular class. If it
    receives an object of another class it wishes to automatically
    convert that object into one of the desired class. 
    
    <p>For example, <code>Array.new</code> may be called with an Array as
    an argument, which is copied to produce a new Array. If the argument
    is not of class <code>Array</code>, <code>Array.new</code> sends
    <code>:to_ary</code> to the argument, implicitly converting it to an
    <code>Array</code>.

    <p><code>Array.new</code> sent <code>:to_ary</code> because it is part
    of the implicit conversion protocol. By responding to this message
    with an <code>Array</code>  objects are declaring that they may be
    used in place of an <code>Array</code>. 
     
    <p>If the argument responds to <code>:to_a</code> it can also be
    automatically converted to an <code>Array</code>. However,
    <code>Array.new</code> does not send this message for it is part of
    the <i>explicit</i> conversion protocol; the sender of the message
    must send the argument <code>:to_a</code> himself if he requires the
    conversion.

    <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto</a> (pp. 80)
    suggest that objects should implement an implicit conversion protocol
    if they have <q>strong characteristics</q> of the target class. 

    <section>
      <h5><code>try_convert</code></h5>

      <p><code>Array</code>, <code>Hash</code>, <code>IO</code>,
      <code>Regexp</code>, and <code>String</code> define a class method named
      <code>try_convert</code> which uses the appropriate implicit conversion
      protocol to convert the argument to the receiver’s class. If the
      argument does not respond to the appropriate implicit conversion
      message, <code>.try_convert</code> returns <code>nil</code>.

      <p>For example, <code>String.try_convert(<var>object</var>)</code> returns
      <code><var>object</var>.to_str</code> if <var>object</var> responds to
      <code>:to_str</code>; <code>nil</code> otherwise.
    </section>

    <p>From the discussion above we can derive the following rules:

    <ol>
      <li>A method may send implicit conversion messages to its
      arguments. 
      <li>Objects responding to such messages are declaring that they may
      be used in this way.
      <li>A method must not send explicit conversion messages to its
      arguments.
    </ol>
  </section>

  <section>
    <h4>Explicit Conversion</h4>
    
    <p>An object which can be represented as an object of another class
    may implement the relevant explicit conversion protocol. It is
    explicit because the user must explicitly send the conversion message
    to the object to effect the conversion; the message should never be
    sent automatically by another method.

    <p>If an object implements an implicit conversion protocol that
    corresponds with an explicit conversion protocol, it should implement
    the explicit protocol, too. The implicit protocol is a superset of the
    explicit protocol, so there will not exist a scenario where an object
    would need to implement the former without the latter. This can be easily
    achieved by aliasing the implicit method to the explicit method. For
    example, if an object responds to <code>:to_ary</code> but not to
    <code>:to_a</code> it should alias <code>:to_a</code> to
    <code>:to_ary</code>.

    <p>From the discussion above we can derive the following rules:

    <ol>
      <li>A method should not send explicit conversion messages to its
      arguments. 
      <li>Objects responding to implicit conversion messages that have
      explicit counterparts should respond to the latter, too. 
    </ol>
  </section>

  <p>The conversion protocol is summarised in the table below. The
  <i>Target Class</i> column indicates the class of the object the
  conversion method should return. The <i>Implicit</i> column specifies
  the message, if any, that is part of the implicit conversion protocol
  for the target class. Likewise, the <i>Explicit</i> column specifies
  the message, if any, that is part of the explicit conversion protocol
  for the target class. If a protocol is not defined for a class, it has a
  value of <i>N/A</i> is given. 
  
  <p>Note that the absence of an implicit protocol for a class implies
  that it should not be converted implicitly. Methods expecting arguments
  of a non-convertible class should raise a <code>TypeError</code> if they
  receive arguments of an unsuitable type.

  <!-- Use spanning cell when an implicit message is given without an explicit
  counterpart? -->
  <table>
    <tr>
      <th>Target Class</th> 
      <th>Implicit</th> 
      <th>Explicit</th>
      <th>Note</th>
    </tr>
    <tr>
      <td><code>Array</code></td> 
      <td><code>:to_ary</code></td>
      <td><code>:to_a</code></td>
    </tr>
    <tr>
      <td><code>Complex</code></td> 
      <td><code>:to_c</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>Enumerator</code></td> 
      <td>N/A</td>
      <td><code>:to_enum</code></td>
    </tr>
    <tr>
      <td><code>Float</code></td> 
      <td><code>:to_f</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>Hash</code></td> 
      <td><code>:to_hash</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>Integer</code></td> 
      <td><code>:to_int</code></td>
      <td><code>:to_i</code></td>
    </tr>
    <tr>
      <td><code>IO</code></td> 
      <td><code>:to_open</code></td>
      <td>N/A</td>
      <td>Sent by <code>Kernel#open</code> to its first argument</td>
    </tr>
    <tr>
      <td><code>Proc</code></td> 
      <td><code>:to_proc</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>Rational</code></td> 
      <td><code>:to_r</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>Regexp</code></td> 
      <td><code>:to_regexp</code></td>
      <td>N/A</td>
      <td>Sent by <code>Regexp.try_convert</code></td>
    </tr>
    <tr>
      <td><code>String</code></td> 
      <td><code>:to_str</code></td>
      <td><code>:to_s</code></td>
    </tr>
    <tr>
      <td><code>String</code></td> 
      <td><code>:to_path</code></td>
      <td>N/A</td>
      <td>Sent by methods expecting a file path as an argument, such as
        the class methods of <code>File</code></td>
    </tr>
    <tr>
      <td><code>Symbol</code></td> 
      <td><code>:to_sym</code></td>
      <td>N/A</td>
    </tr>
  </table> 

  <h3>Converting to “Boolean”</h3>

  <p>It is rarely necessary to convert an object to a “Boolean” because Ruby
  automatically treats <code>false</code> and <code>nil</code> as false, and
  any other value as true. However, if a method wishes to return either
  <code>true</code> or <code>false</code> it may use the
  <code>!!<var>object</var></code> idiom. This returns <code>false</code> if
  <var>object</var> is <code>false</code> or <code>nil</code>;
  <code>true</code> otherwise.

  <!-- Describe how #method_defined? differs from #respond_to? -->
  
  <!-- Explain numeric coercion -->

<h2>Classes</h2>

  <p>We have introduced classes as templates from which objects can be
  created. A class is typically created with the <code>class</code>
  keyword followed by the class name.

  <p>A <dfn id=class>class</dfn> is a <i>classification</i> of objects. It constitutes a template from
  which such objects can be constructed. Hence <code>3</code> and <code>198705</code> are both
  instances of the <code>Integer</code> class. Their data (i.e. their numerical value) differs but
  they behave as any other instance of their class. That is, by their nature as integers both objects
  can be multiplied by another integer, and both are either odd or even, etc.

  <aside>The term <i>class</i> is roughly analogous to its biological definition where it denotes a
  taxonomic rank, however this analogy does not extend to subclasses. That is, a subclass of a class
  is termed a <i>subclass</i>; not an <i>order</i>.</aside>

  <figure id=class-keyword>
  <dt>Usage of the <code>class</code> keyword to <i>open</i> a class named
  <code>Dog</code></dt>
  <dd>
    <pre><code>
    class Dog
    end
    </code></pre>
  </dd>
  </figure>

  <p>The <code>Class.new</code> constructor may be used to the same effect
  if it is assigned to a constant.

  <figure id=class-new>
  <dt>Usage of the <code>Class.new</code> constructor to create a class
  named <code>Dog</code></dt>
  <dd>
    <pre><code>
    Dog = Class.new
    </code></pre>
  </dd>
  </figure>

  <!-- Superclass can't be changed once set. (The old class can be deleted and
  redefined, of course) -->
  <h3>Names</h3>

  <h4>Rules</h4>

  <p>The name of class must: 
    <ul>
      <li>Begin with an uppercase ASCII letter (A-Z) (U+0041..U+005A).
      <li>Not contain a colon (U+003A).
      <li>Not contain an ASCII space character (U+0020)
    </ul>
    <!-- FIXME: Derive and enumerate rules -->

  <p>More generally, a class name consists of an uppercase ASCII character, optionally followed by a
  sequence of other alphanumeric characters

  <aside class=warning>
    Class names containing non-ASCII characters cannot be referred to from source files using a
    different encoding. For example, a class name containing character U+03BB (<i>GREEK SMALL LETTER
      LAMDA</i>) can only be referenced from source files using the UTF-8 source encoding. <!-- FIXME:
    What about other Unicode character sets? -->
   </aside>

  <h4>Conventions</h4>

  <p>Conventionally class names use camel-case capitalization: The initial letter of each word is
  capitalized, and spaces between the words are removed. For example:
  <code>RubyProgrammingLanguage</code> or <code>NutsAndBolts</code>.</p>

  <p>A class name is a constant. The use of camel-case for class names and uppercase for constant
  names ensures that the two don't clash.

  <h3>Reopening Classes</h3>

  <p>If <code>class</code> is used with the name of a pre-existing class that class is
  <i>re-opened</i>. If a method is defined in a re-opened class with the same name as a pre-existing
  method in the same class the old method is overwritten with the new.

  <figure id=reopened-class>
    <dt>Re-defining a method in an existing class</dt>
    <dd>
      <pre><code>
        'hello'.size #=&gt; 5
        class String
          def size
            'How long is a piece of string?'
          end
        end
        'hello'.size #=&gt; 'How long is a piece of string?'
      </code></pre>
    </dd>
  </figure>  

  <h3>Anonymous Classes</h3>

  <p>When a constant is used as a class name it has global scope. This gives rise to the
  characteristic described above in <i>Reopening
    Classes</i>. If this behaviour is not desirable, a class can be made anonymous by assigning the
  value of <code>Class.new</code> to a local variable, thus restricting the class to the local scope.

  <figure id=anonymous-class>
  <dt>Creating an anonymous class with <code>Class.new</code></dt>
    <dd>
      <pre><code>
        dog = Class.new
        dog.class_eval do
          def bark
            :woof
          end
        end
        dog.new.bark #=&gt; :woof
      </code></pre>
    </dd>
  </figure>

<h2>References</h2>
  <dl>
  <dt id=refBLACK09>[BLACK09]</dt>
  <dd><cite><a href=//www.manning.com/black2/>The Well-Grounded Rubyist</a></cite>, D. A. Black,
  Manning, 2009.</dd>
  <dt id=refBROWN09>[BROWN09]</dt>
  <dd><cite><a href=//rubybestpractices.com/>Ruby Best Practices</a></cite>, G. Brown, O'Reilly Media,
  2009.</dd>
  <dt id=refBUDD87>[BUDD87]</dt>
  <dd><cite>A Little Smalltalk</a></cite>, T. Budd, Addison-Wesley, 1987.</dd>
  <dt id=refFLAN08>[FLAN08]</dt>
  <dd><cite><a href=//oreilly.com/catalog/9780596516178>The Ruby Programming Language</a></cite>, D.
  Flanagan &amp; Y. Matsumoto, O'Reilly Media, 2008.</dd>
  <dt id=refTHOM09>[THOM09]</dt>
  <dd><cite><a href=//books.pragprog.com/titles/ruby3/programming-ruby-1-9>Programming Ruby 1.9: The
      Pragmatic Programmers’ Guide</a></cite>, D. Thomas, et al., The Pragmatic Bookshelf, 2009.</dd>
  <dt id=refLIU99>[LIU99]</dt>
  <dd><cite>Smalltalk, Objects, and Design</cite>, C. Liu, ToExcel, 1999.</dd>
  <dt id=refMITCHELL04>[MITCHELL04]</dt>
  <dd><cite>Concepts in Programming Languages</cite>, J. C. Mitchell, Cambridge University Press, 2004.</dd>
  <dt id=refKLAS95>[KLAS95]</dt>
  <dd><cite>Metaclasses and Their Application</cite>, W. Klass &amp; M. Schrefl,
  Springer-Verlag Berlin Heidelberg, 1995.</dl>
<body>
</html>

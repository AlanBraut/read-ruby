<!DOCTYPE html>
<!-- vim: set fdm=indent tw=100: --> 
<html>
  <head>
    <title>Ruby</title>
    <meta charset="utf-8"/>
  </head>
  <body>
<h1>Ruby</h1>

<h2>Objects</h2>
  <p>Ruby embodies the object-orientated paradigm. She holds as fundamental that <q>everything is an
    object</q>. <!-- Note that this is untrue? -->

  <p>An <dfn id=object>object</dfn> is a compilation of data (attributes) and behaviour (methods)
  which encapsulate a specific <i>instance</i> of a <i>class</i>. The String <code>"hello"</code> and
  the Integer <code>3</code> are both examples of objects, and instances of the <i>String</i> and
  <i>Integer</i> classes, respectively. They constitute data (<q>hello</q> and <q>3</q>, respectively)
  and behaviour relevant to that data.

  <p>A <dfn id=class>class</dfn> is a <i>classification</i> of objects. It constitutes a template from
  which such objects can be constructed. Hence <code>3</code> and <code>198705</code> are both
  instances of the <code>Integer</code> class. Their data (i.e. their numerical value) differs but
  they behave as any other instance of their class. That is, by their nature as integers both objects
  can be multiplied by another integer, and both are either odd or even, etc.

  <aside>The term <i>class</i> is roughly analogous to its biological definition where it denotes a
  taxonomic rank, however this analogy does not extend to subclasses. That is, a subclass of a class
  is termed a <i>subclass</i>; not an <i>order</i>.</aside>

<h2>Methods</h2>

  <p>A <dfn id=method>method</dfn> is a named block of code associated with an object. For now we will
  define <i>block of code</i> as a sequence of one or more statements.

  <p>A message may be accompanied by a series of variables, or <dfn
    id=method-arguments>arguments</dfn>, to be understood in the context of the message.  <p>A method
  is invoked for the side-effect it causes, the value it returns, or a combination of these factors.
  Note that this definition encompasses <i>accessor</i> and <i>mutator</i> methods; Ruby makes no such
  distinction.

  <h3>Communication Through Message Sending</h3>

    <p>An object communicates with another by sending it a <dfn
      id=message>message</dfn>. The simplest message is a <code>Symbol</code>. Upon receiving such a
    message the recipient object attempts to invoke a method of the same name on itself. For example,
    sending a <code>String</code> object a message of <code>:size</code> causes that object to invoke
    the <code>String#size</code> method.

    <!-- TODO: Mention telegram idea -->

    <p>At this stage we will assume a 1∶1 mapping between messages and methods.  That is, for a given
    object, we will consider as analogous the sending of a message, <var>m</var>, and the invoking of a
    method, <var>m</var>. Therefore the phrases <q>sending a message</q> and <q>invoking a method</q>
    are equivalent.
    <!-- TODO: Connect with explanation of method_missing -->

    <figure id=sending-a-message>
    <dt>Sending the message <code>:size</code> to a <code>String</code> object. The first example uses
    the standard method calling syntax; the second uses <code>Object#send</code>.
      <dd>
        <pre><code>
          "wool".size #=&gt; 4
          "wool".send(:size) #=&gt; 4
        </code></pre>  
      </dd>
    </figure>

    <!-- TODO: Move instructions for _creating_ these methods out of these
    sections -->

  <h3>Instance Methods</h3>

    <p>An instance method is a behaviour of an object. It is typically created with the <code>def</code>
    keyword in the context of a class.

    <aside> It is conventional to employ the <code>Class#method</code> notation when referring to
    instance methods in documentation and prose. For example: <code>Integer#even?</code>.  </aside>

    <figure id=def-instance-method>
    <dt>Defining an instance method named <code>bark</code> for the <code>Dog</code> class
      with the <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def bark
              :woof
            end
          end
          Dog.new.bark #=&gt; :woof
        </code></pre>  
      </dd>
    </figure>

  <h3>Singleton Methods</h3>

    <p>A singleton method is associated with a class as opposed to its instances. Indeed, it is
    typically a <i>factory method</i>: a constructor of instances. They are also created with the
    <code>def</code> keyword, but their names are prefixed with <code>self.</code> to denote their
    singleton status.

    <figure id=def-singleton-method>
    <dt>Defining a singleton method named <code>breed</code> for the <code>Dog</code> class with the
    <code>def</code> keyword.
      <dd>
        <pre><code>
          class Dog
            def self.breed
              [new, new]
            end
          end
          Dog.breed #=&gt; [#<Dog:0x95cb530>, #<Dog:0x95cb508>]
        </code></pre>  
      </dd>
    </figure>

    <aside> It is conventional to employ the <code><var>Class</var>.<var>method</var></code> notation
    when referring to singleton methods in documentation and prose. For example:
    <code>File.exists?</code>.  </aside>

  <h3>Method Invocation</h3>

    <p>To send a message, <var>m</var>, to an object, <var>o</var>, is to <dfn
      id=invoke-method>invoke</dfn> <var>m</var> on <var>o</var>.

    <p>The simplest expression for invoking a method consists of only the method’s name:
    <code><var>m</var></code> invokes method <var>m</var>. Omitting the name of the object on which
    <var>m</var> should be invoked causes an implicit receiver of <code>self</code> to be assumed.
    <code>self</code> is a special variable which evaluates to the current object. <!-- TODO: Where to
    describe this in more detail? --> Its value is initially <code>Object</code> so a method invoked
    without an explicit receiver outside of a class definition is actually invoked on
    <code>Object</code>. <!-- TODO: Explain how 'puts "glark"' works in this context? -->

    <aside class=note>
      The style of invocation explained above is potentially ambiguous. If Ruby sees a bare identifier,
      e.g. <code>glark</code>, is that a reference to a local variable or the invocation of a method? If
      Ruby has previously seen the identifier being assigned to, e.g. <code>glark = 2</code>, it is
      treated as a variable reference; otherwise it is a method to be invoked on <code>self</code>
      </aside>

    <p>The receiver can be specified explicitly with the
    <code><var>receiver</var>.<var>method</var></code> syntax, i.e. the method name is prefixed with the
    receiver name followed by a period (U+002E: <code>.</code>). <var>receiver</var> is an expression
    which evaluates to an object. For example, <code>"esrever".reverse</code> invokes the method
    <code>:reverse</code> on the <code>String</code> <code>"esrever"</code>. <code>(1 + 2).odd?</code>
    invokes <code>:odd?</code> on the <code>Fixnum</code> <code>3</code>.

    <aside class=note>
      An alternative to the <code><var>receiver</var>.<var>method</var></code> syntax is
      <code><var>receiver</var>::<var>method</var></code>, where the period (<code>.</code>) is replaced
      with a double colon (<code>::</code>). However, the latter syntax has fallen out of favour due to
      the confusion it creates between method invocations and constant reference expressions. It is not
      recommended for use in new code.  </aside>

    <p>In either case a <code>NoMethodError</code> is raised if the named method does not exist.

    <p>A message may be accompanied by one or more <dfn
      id=method-arguments>arguments</var>: variables to be used in the method’s computations. Arguments
    are supplied as a parenthesized list of variables separated by commas:
    <code><var>receiver</var>.<var>message</var>(<var>arg<sub>0</sub></var>,…,<var>arg</var><sub>n</sub>)</code>.
      For example, to send the <code>String</code> <code>"haystack"</code> the <code>:include?</code>
      message with the argument <code>"needle"</code>: <code>"haystack".include?("needle")</code>.

    <p>If a method is invoked with a parameter list other than what it expects it raises an
    <code>ArgumentError</code>.

    <aside class=note> 
      <p>It is often the case that a method needs to be invoked with multiple
      arguments, yet those arguments are stored in an <code>Enumerable</code> such as <code>Array</code>.
      If the method is invoked with just the <code>Enumerable</code> it will receive a single argument (a
      reference to the <code>Enumerable</code>) rather than the constituent elements thereof. The solution
      is to prefix the <code>Enumerable</code> argument with an asterisk (U+002A: <code>*</code>), which
      in this context is termed a <dfn
        id=splat-operator>splat operator</dfn>, thus expanding the <code>Enumerable</code> into its
      individual elements.

      <!-- TODO: Example -->
      <p>This technique works by invoking the <code>:to_a</code> method on the prefixed object, so any
      object that has a method by this name which returns an <code>Array</code> can be used in the same
      fashion.  
    </aside>

    <p>A method invocation followed by a block literal causes the block to be passed to the method. A
    block literal may be enclosed in curly braces (<code>{</code>…<code>}</code>) or a
    <code>do</code>…<code>end</code> construct. These forms are semantically equivalent, however it is
    conventional to use the former for short blocks that fit on a single line, and the latter for
    multi-line blocks.

    <aside class=note>
      <p>To pass a <code>Proc</code> object to a method expecting an anonymous block,
      prefix the object name with an ampersand ((U+0026: <code>&amp;</code>). If the method is invoked
      with multiple arguments this <code>Proc</code> must be specified last.

      <p>This technique works by calling the object’s <code>:to_proc</code> method, and using the
      <code>Proc</code> it returns for the block. By extension, any object that defines a
      <code>:to_proc</code> method which behaves in this manner can be used in the same fashion.
      <!-- Point to Symbol#to_proc here? -->
    </aside>

    <h4>Parentheses</h4>

      <p>Parentheses may be omitted from method invocations when doing so does not introduce syntactic
      ambiguity.

      <p>Methods expecting no arguments are nearly always invoked without parentheses. For example,
      <code>'briefcase'.upcase</code> is equivalent to <code>'briefcase'.upcase()</code>; the former is
      the recommended style. <!-- TODO: What about if doing so disambiguates the method from a variable?
      -->

      <p>Methods expecting multiple arguments may omit parentheses. This is mostly a matter of style.

      <p>A common case when parentheses are <i>required</i> to disambiguate is nested method invocations
      where multiple arguments are involved, such as <code><var>a</var> <var>b</var> <var>c</var>,
          <var>d</var></code>,
        where <var>a</var> and <var>b</var> are methods. To whom do the arguments, <var>c</var> and
        <var>d</var> belong? Does the programmer mean <code><var>a</var>(<var>b</var>(<var>c</var>,
          <var>d</var>))</code> or <code><var>a</var>(<var>b</var>(<var>c</var>), <var>d</var>)</code>?
        Ruby assumes the former. However, even if the programmer agrees with Ruby's interpretation these
        forms of invocation are seldom as clear to others. Therefore, it is recommended to employ
        parentheses in such cases, even if unnecessary, as an aid to legibility.

      <p>When parentheses are used to enclose a method’s arguments, the opening parenthesis must
      immediately follow the method’s name like so:
      <code><var>method</var>(<var>arg<sub>0</sub></var>,…,<var>arg<sub>n</sub></var>)</code>.  Whitespace
      between <var>method</var> and <code>(</code> will result in a <code>SyntaxError</code>. This is due
      to a quirk in Ruby’s syntax inasmuch as parentheses serve two distinct functions—grouping of
      expressions and associating an argument list with a method invocation—so the above form represents
      an ambiguity.

    <h4>Element Reference</h4>

      <p>The <code>[<var>subscript</var>]</code> notation for referring to an element of an
      <code>Array</code> or <code>Hash</code> is called <dfn id=element-reference>element reference</dfn>
      syntax. It is a special case of the method invocation syntax because it invokes a method named
      <code>:[]</code> on the receiver, passing in the contents of <code>[</code>…<code>]</code> as
      arguments. For example, <code>[1,2,3][0]</code> is equivalent to <code>[1,2,3].[](0)</code>.

      <p>Indeed, any object may define a method named <code>:[]</code>, allowing it to be used in this
      fashion. 

      <!-- TODO: Example of a #[] method -->

      <p>Similarly, assignment to an element reference invokes a method named <code>:[]=</code>. For
      example, where <code>fruit</code> is a <code>Hash</code>, <code>fruit[:apple] = :red</code> is
      equivalent to <code>fruit.[]=(:apple, :red)</code>.
    
    <h4>Attribute Accessors and Setters</h4>

      <p>A method which accepts no arguments and returns the value of the corresponding instance variable,
      or <dfn id=attribute>attribute</dfn>, in the receiver is sometimes referred to as an <dfn
        id=attribute-accessor>attribute accessor</dfn> method. For example, <code>person.name</code> is
      said to return the <code>name</code> attribute of the <code>person</code> object.

      <!-- TODO: Link with discussion of _attr_ -->

      <p>There is not necessarily a correspondence between the accessor’s name and that of the
      corresponding instance variable. There is not, for that matter, necessarily a corresponding instance
      variable at all: the attribute value might have been computed dynamically, for example. 

      <p>An instance method whose name is that of an attribute accessor but suffixed with an equals sign
      (<code>=</code>) and accepts an argument, is called an <dfn id=attribute-setter>attribute
        setter</dfn>. It sets the attribute to the value supplied.

    <!-- TODO: Lookup rules? -->

  <h3>Return Values</h3>

    <p>A method is a expression so always returns a value. This is <code>nil</code> if the method was
    defined without a body; the last statement executed otherwise. Multiple values can be returned by
    using an <code>Array</code> as the last statement. 

    <figure id=def-implicit-return>
      <dt>A method which returns the Symbol <code>:to_sender</code>
      <dd>
        <pre><code>
          def elvis
            :to_sender
          end
        </code></pre>
      </dd>
    </figure>

    <figure id=def-implicit-return-multiple>
    <dt>A method which returns multiple values as an <code>Array</code>.
      <dd>
        <pre><code>
          def elvis
            [:to_sender, :hound_dog]
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>A <code>return</code> statement causes <code>nil</code> to be immediately returned to the caller.
    <code>return</code> may be followed by an argument in which case its value is returned instead.  If
    multiple arguments are given they will be returned as an <code>Array</code>. 

    <figure id=def-explicit-return-multiple>
    <dt>A method which explicitly returns multiple values.
      <dd>
        <pre><code>
          def elvis
            return :to_sender, :hound_dog
            # Not reached
          end
          elvis #=&gt; [:to_sender, :hound_dog]
        </code></pre>
      </dd>
    </figure>

    <p>This gives rise to two conventions:
      <ul>
        <li>A method uses a <code>return</code> statement iff it may return before its last statement.
        <li>A method intended to return a value has that value as its last statement
      </ul>
    </p>

    <!-- TODO: Mention Object#tap -->

  <h3>Names</h3>

      <!-- TODO: Talk about "significant" names here? e.g. to_*,
      inspect, etc.? -->

    <h4>Conventions</h4>

      <p>Method names begin with a lowercase letter. If they consist of multiple words underscores
      (U+005F: <code>_</code>) are used to separate.

      <aside>
        It is legal for a method name to begin with an uppercase letter, but then they may be confused
        with constants or class names. In fact, several core classes have methods named this way for
        precisely this reason: they provide a syntactical shortcut for constructing instances. For
        example, <code>Array()</code> is a method of <code>Kernel</code> which coerces its argument into
        an <code>Array</code> object.  </aside>

      <p><i>Predicate</i> methods (those which return either <code>true</code> or <code>false</code>)
      typically use a <code>?</code> suffix. For example: <code>Integer#even?</code>. A method with a
      <code>?</code> suffix is not necessarily a predicate, however; <code>Float#infinite?</code>, for
      example, returns <code>nil</code> for finite numbers, <code>-1</code> for negative infinity, or
      <code>+1</code> for positive infinity. <!-- TODO: Use infinity symbols -->

      <p>The <code>!</code> suffix (colloquially called a <i>bang</i>) is used <q>…to mark a method as
        special. It doesn’t necessarily
        mean that it will be destructive or dangerous, but it means that it will require more attention
        than its alternative.</q> <a class=ref href=#refBROWN09>[Brown, 2009, pp. 52]</a>. <q>Usually, the
        method without the exclamation mark returns a modified copy of the object it is invoked on, and
        the one with the exclamation mark is a mutator method that alters the object in place.</q> <a
        class=ref href=#refFLAN08>[Flanagan &amp; Matsumoto, 2008, pp. 7]</a> 

      <!-- TODO: Unite this with section on attribute setters -->
    <h4>The <code>=</code> Suffix</h4>

      <p>Methods named with a <code>=</code> suffix can be used in assignment statements as
      <i>lvalues</i>. That is, a method defined as <code>name=(value)</code> on object <code>obj</code>
      can be invoked as <code>obj.name = value</code> or <code>obj.name=(value)</code>.     

      <aside class=warning>

      <p>The syntax <code>name = value</code> is therefore ambiguous. Is the intent
      to assign the value <code>value</code> to the local variable <code>name</code> or to invoke the
      method named <code>name=</code> with <code>value</code> as the argument?

      <p>The resolution is to always invoke a <code>=</code>-suffixed method with an explicit receiver,
      such as <code>self</code>. Alternatively, make it explicit that you are invoking a method with the
      <code>name=(value)</code> syntax.  

      </aside>

  <h3>Operator Methods</h3>

    <p>The operators of conventional programming languages are mostly implemented as methods in Ruby. An
    expression such as <code>3 + 2
      * 10</code>  is evaluated as <code>3.+(2.*(10))</code>, i.e.  <code>2</code> is sent the message
    <code>:*</code> with <code>10</code> as the argument, then <code>3</code> is sent the message
    <code>:+</code> with <code>20</code> as its argument.  Operators implemented in this way are termed
    <dfn id=operator-methods>operator methods</dfn> and are enumerated in the table below.

    <p>Classes can implement their own operator methods by defining a method with the corresponding
    name, which is listed in the <i>Method</i> column below. This name is generally the same as the
    operator symbol, e.g.  <code>+</code> implies a method named <code>:+</code>, but in the case of
    unary methods, e.g. the <code>-</code> in <code>-2</code>, the method name consists of the operator
    with an <code>@</code> suffix.

    <aside class=note>
    <p>The method names detailed in the table are the only examples of legal names which consist solely
    of punctuation. That <code>^</code> and <code>~</code>, for example, are legal characters, does not
    imply that a method named <code>^~</code> is also legal.
    <!-- TODO: Mention += and friends -->
    </aside>

    <table id=operator-methods>
      <tr> <th>Method</th> <th>Operator</th> <th>Description</th> </tr>

      <tr>
        <td><code>[]</code></td>
        <td><code>[</code>…<code>]</code></td>
        <td>Element reference, e.g. <code>[1,2,3][1]</code> subscripting</td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>[]=</code></td>
        <td><code>[</code>…<code>]=</code></td>
        <td>Element set, e.g. <code>{foo: :bar}[:glark] = :quark</code></td>
        <!-- TODO: Link with element reference writeup -->
      </tr>

      <tr>
        <td><code>**</code></td>
        <td><code>**</code></td>
        <td>Exponentiation, e.g. <code>3 ** 2</code></td>
      </tr>

      <tr>
        <td><code>!</code></td>
        <td><code>!</code></td>
        <td>Not, e.g. <code>!pregnant</code></td>
      </tr>

      <tr>
        <td><code>~</code></td>
        <td><code>~</code></td>
        <td>Complement, e.g. <code>~23</code></td>
      </tr>

      <tr>
        <td><code>-@</code></td>
        <td><code>-</code></td>
        <td>Unary minus (negate), e.g. <code>-42</code></td>
      </tr>

      <tr>
        <td><code>+@</code></td>
        <td><code>+</code></td>
        <td>Unary plus, e.g. <code>+(10-20)</code></td>
      </tr>

      <tr>
        <td><code>*</code></td>
        <td><code>*</code></td>
        <td>Multiplication, e.g. <code>10 * 2</code></td>
      </tr>

      <tr>
        <td><code>/</code></td>
        <td><code>/</code></td>
        <td>Division, e.g. <code>20 / 10</code></td>
      </tr>

      <tr>
        <td><code>%</code></td>
        <td><code>%</code></td>
        <td>Modulo, e.g. <code>20.5 % 16</code></td>
      </tr>

      <tr>
        <td><code>+</code></td>
        <td><code>+</code></td>
        <td>Addition, e.g. <code>20.5 + 5.2</code></td>
      </tr>

      <tr>
        <td><code>-</code></td>
        <td><code>-</code></td>
        <td>Subtraction, e.g. <code>20.5 - 5.2</code></td>
      </tr>

      <tr>
        <td><code>&gt;&gt;</code></td>
        <td><code>&gt;&gt;</code></td>
        <td>Right shift, e.g. <code>16 &gt;&gt; 1</code></td>
      </tr>

      <tr>
        <td><code>&lt;&lt;</code></td>
        <td><code>&lt;&lt;</code></td>
        <td>Left shift, e.g. <code>16 &lt;&lt; 1</code></td>
      </tr>

      <tr>
        <td><code>&amp;</code></td>
        <td><code>&amp;</code></td>
        <td>Bitwise AND, e.g. <code>2 &amp; 1</code></td>
      </tr>

      <tr>
        <td><code>^</code></td>
        <td><code>^</code></td>
        <td>Bitwise XOR, e.g. <code>2 ^ 1</code></td>
      </tr>

      <tr>
        <td><code>|</code></td>
        <td><code>|</code></td>
        <td>Bitwise OR, e.g. <code>2 | 1</code></td>
      </tr>

      <!-- TODO: Link the following with Comparable explanation -->
      <tr>
        <td><code>&lt;=</code></td>
        <td><code>&lt;=</code></td>
        <td>Less than or equal to (≤), e.g. <code>10 &lt;= 12</code></td>
      </tr>

      <tr>
        <td><code>&lt;</code></td>
        <td><code>&lt;</code></td>
        <td>Less than, e.g. <code>10 &lt; 12</code></td>
      </tr>

      <tr>
        <td><code>=&gt;</code></td>
        <td><code>=&gt;</code></td>
        <td>Greater than or equal to (≥), e.g. <code>12 =&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&gt;</code></td>
        <td><code>&gt;</code></td>
        <td>Greater than, e.g. <code>12 &gt; 10</code></td>
      </tr>

      <tr>
        <td><code>&lt;=&gt;</code></td>
        <td><code>&lt;=&gt;</code></td>
        <td><i>Spaceship</i> operator, e.g. <code>12 &lt;=&gt; 10</code></td>
      </tr>

      <tr>
        <td><code>==</code></td>
        <td><code>==</code></td>
        <td>Equality, e.g. <code>"wool" == "wool"</code></td>
      </tr>

      <tr>
        <td><code>===</code></td>
        <td><code>===</code></td>
        <td>Case equality, e.g. <code>Array === [1]</code></td>
      </tr>

      <!-- TODO: Mention this inverts == unless defined explicitly -->
      <tr>
        <td><code>!=</code></td>
        <td><code>!=</code></td>
        <td>Not equal, e.g. <code>"bark! != "bite"</code></td>
      </tr>

      <tr>
        <td><code>=~</code></td>
        <td><code>=~</code></td>
        <td>Pattern match, e.g. <code>/\d/ =~ "99"</code></td>
      </tr>

      <!-- TODO: Mention this inverts =~ unless defined explicitly -->
      <tr>
        <td><code>!~</code></td>
        <td><code>!~</code></td>
        <td>Inverted pattern match, e.g. <code>/\d/ !~ "d"</code></td>
      </tr>
    </table>

  <h3>Arity</h3>
    <!-- TODO: Link with Method#arity, Proc#arity -->
    <h4>Classification by Arity</h4>
    <!-- TODO: binary, unary, etc. -->

  <h3>Defining</h3>
    
    <p>A method consists of a name, an optional parameter list, and a body. Names have already been
    discussed, the parameter list is explained in <i>Arguments</i> below. The <dfn
      id=method-body>body</dfn> is a sequence of statements terminated with the <code>end</code>
    keyword.
    
    <figure id=def-syntax>
    <dt>The syntax of a method definition.
      <dd>
        <pre><code>
          def <var>name</var> (<var>parameters</var>)
            <var>body</var>
          end
        </code></pre>
      </dd>
    </figure>
    
    <!-- TODO: Returns value which is not a method object -->
    
    <!-- TODO: Distinguish between defining instance and singleton
    methods -->
    The methods we’ve defined so far are all global methods. If we place a def statement
    like the ones shown earlier inside a class statement, then the methods that are defined
    are instance methods of the class; these methods are defined on all objects that are
    instances of the class. (Classes and instance methods are explained in Chapter 7.)
    It is also possible, however, to use the def statement to define a method on a single
    specified object. Simply follow the def keyword with an expression that evaluates to
    an object. This expression should be followed by a period and the name of the method
    to be defined. The resulting method is known as a singleton method because it is
    available only on a single object:
    o = "message"    # A string is an object
    def o.printme    # Define a singleton method for this object
    puts self
    end
    o.printme        # Invoke the singleton
    Class methods (covered in Chapter 7) such as Math.sin and File.delete are actually
    singleton methods. Math is a constant that refers to a Module object, and File is a constant
    that refers to a Class object. These two objects have singleton methods named sin and
    delete, respectively.
    
    Ruby implementations typically treat Fixnum and Symbol values as immediate values
    rather than as true object references. (See §3.8.1.1.) For this reason, singleton methods
    may not be defined on Fixnum and Symbol objects. For consistency, singletons are also
    prohibited on other Numeric objects.
    
    <h4>Arguments</h4> 
    
      <p>A method may accept one or more arguments, variables passed in from the caller.

      <p>When a method is defined with the <code>def</code> keyword its name may be followed by a set of
      parentheses (<code>(</code>, <code>)</code>). The contents thereof (hereafter: <dfn
        id=parameter-list>the parameter list</dfn>) dictate the arguments the method will accept. (The
      parentheses are actually optional, but their omission doesn't enhance readability so their presence
      is recommended).

      <p>The parameter list specifies:
      <ul>
        <li>The local variable names (hereafter: <dfn id=parameters>parameters</dfn>) to which the
        corresponding argument will be aliased to inside the method.
        <li>Whether the arguments are required or optional.
        <li>Whether a fixed or variable number of arguments are allowed.
        <li>The default value, if any, of each parameter.
        <li>Whether an argument is expected to be a block.
      </ul>

      <p>Each parameter name must be unique in the parameter list.
      
      <h5>Pass By Reference</h5>

        <p>Arguments are passed to methods by reference instead of value.  If the method modifies an object
        it receives the caller’s copy is modified, too.

        <figure id=pass-by-reference>
          <dt>The effect of a method’s modification of an argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                llama #=&gt; 'arry'
              </code>
            </pre>
          </dd>
        </figure>

        <p>Methods may <i>dup</i> (<code>Object#dup</code>) their arguments to avoid this situation.    

        <figure id=pass-by-reference-dup>
        <dt>The effect of a method’s modification of a <code>dup</code>’d argument on its caller</dt>
          <dd>
            <pre>
              <code>
                def llama_sans_l(llama)
                  llama.dup.gsub!(/l/i,'')
                end
                llama = 'Larry'
                llama_sans_l(llama) #=&amp; 'arry'
                <mark>llama #=&gt; 'Larry'</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Required Arguments</h5>

        <p>A <dfn id=required-argument>required argument</dfn> <em>must</em> be supplied by the caller. A
        method which requires exactly 4 arguments must receive them all, otherwise it raises an
        <code>ArgumentError</code>.

        <aside class=note>
          <code>nil</code> and <code>false</code> are as valid an argument any other. If a method requires
          an argument and <code>nil</code> is supplied in its place, Ruby will not complain. Methods wishing
          to prohibit such values must do so themselves.
        </aside>

        <p>Required arguments are specified with a comma-separated list of parameter names. Each parameter
        represents a mandatory argument.

        <figure id=required-arguments>
        <dt>Defining a method which requires exactly two arguments.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def laugh(how, volume)
                    puts volume == :loudly ? how.upcase : how
                  end
                end
                Llama.new.laugh #=&gt; ArgumentError: wrong number of arguments (0 for 2)
                Llama.new.laugh(:snicker) #=&gt; ArgumentError: wrong number of arguments (1 for 2)
                Llama.new.laugh(:chortle,:softly) #=&gt; chortle
                Llama.new.laugh(:guffaw,:loudly) #=&gt; GUFFAW
                Llama.new.laugh(:ho, :ho, :ho) #=&gt; ArgumentError: wrong number of arguments (3 for 2)
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Optional Arguments and Default Values</h5>

        <p>An <dfn id=optional-argument>optional argument</dfn> <em>may</em> be supplied by the caller. If
        it is not, the corresponding parameter will be assigned the value given as its default.

        <p>Optional arguments are specified with a comma-separated list of
        <code><var>name</var>=<var>value</var></code> pairs, where <var>name</var> is a parameter name and
        <var>value</var> is its default value. The <var>value</var> may be any Ruby expression, and is
        permitted to refer to previous parameters. The default value is evaluated each time the method is
        invoked, so may, for example, instantiate an object on every invocation. 

        <figure id=optional-arguments>
        <dt>Defining a method which takes an optional argument.</dt>
          <dd>
            <pre>
              <code>
                class Llama
                  def name(name='Larry')
                    name + ' the llama (beast of burden)'
                  end
                end
                Llama.new.name #=&gt; "Larry the llama (beast of burden)"
                Llama.new.name('Lyle Jr.') #=&gt; "Lyle Jr. the llama (beast of burden)"
                Llama.new.name('Lama', 'glama') #=&gt; ArgumentError: wrong number of arguments (2 for 1)
              </code>
            </pre>
          </dd>
        </figure>

        <p>Optional and required arguments can be specified alongside each other in a reasonably natural
        fashion. However, all optional arguments must be adjacent. For instance, it is a
        <code>SyntaxError</code> to both precede and follow a required argument with optional arguments.

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Variable-Length Argument Lists</h5>

        <!-- TODO: Standardise on terms: 'rest' or 'splat' -->

        <p>A <dfn id=rest-parameter>rest parameter</dfn> (or <dfn
          id=splat-parameter>splat parameter</dfn>) consumes every argument that follows it while still
        allowing subsequent required parameters to receive their corresponding arguments. Put simply: it
        takes an arbitrary number of arguments from its position onward. It is passed to the method as an
        <code>Array</code> containing one argument per element.

        <aside class=note>

        Rest parameters do not <em>require</em> any arguments, so a method whose parameter list consists
        solely of a rest parameter, for example, may be invoked with zero or more arguments.

        </aside>

        <p>A rest parameter is specified by preceding a parameter name with an asterisk (U+002A:
        <code>*</code>). Only one rest parameter may appear in a parameter list, and it any optional
        parameters must precede it.

        <figure id=rest-arguments>
        <dt>Defining a method which takes a variable number of arguments.</dt>
          <dd>
            <pre>
              <code>
              def zero_or_more(*rest)
                rest.join(', ')
              end
              zero_or_more #=&gt; ""
              zero_or_more(1) #=&gt; "1"
              zero_or_more(1,2,3) #=&gt; "1, 2, 3"
              </code>
            </pre>
          </dd>
        </figure>

        <!-- TODO: Cut this section? We now state above that any optional
        arguments must precede the _rest_ -->

        <aside class=note>
          The following syntax rules are complex, but do not be deterred.  They are unlikely to ever be
          relevant in practice.
        </aside>

        <!-- FIXME: Clarify this explanation; derive a general principle
        which better expresses the rule -->

        <p>A rest parameter must not be followed by an optional parameter because of the resulting
        ambiguity: if two or more arguments were supplied for the former, should the latter be assigned its
        default value or take one of the aforementioned? However, there is no ambiguity when optional
        parameters precede the rest parameter, so this arrangement is legal.

        <p>Conversely, a rest parameter may be either followed or preceded by one or more required
        parameters

        <figure id=required-arguments-with-optional-arguments>
        <dt>Defining a method which takes both optional and required arguments.</dt>
          <dd>
            <pre>
              <code>
                def required_optional(a,b=1) end
                def required_required_optional(a,b,c=1) end
                def optional_required(a=1,b) end
                def optional_optional_required(a=1,b=2,c) end
                <mark>def optional_required_optional(a=1,b,c=2) end #=&gt;
                SyntaxError</mark>
              </code>
            </pre>
          </dd>
        </figure>

        <p>A rest parameter may be supplied as a sole asterisk, omitting the corresponding parameter name.
        The effect is to consume the corresponding arguments as an ordinary rest parameter, without
        assigning them to a local variable. The arguments are ignored.  This allows methods to accept an
        arbitrary number of arguments, but discard, say, all but the last. 

        <p>Thomas et al. (<a href=#refTHOM09>[THOM09]</a>) suggest that this technique can used in
        conjunction with <code>super</code> to define a method which accepts an arbitrary number of
        arguments then passes them all to its superclass.

        <figure id=rest-parameter-with-super>
        <dt>A method which accepts a variable number of arguments then passes them to its superclass
        (<code>Parent</code>) with the implicit-argument form of <code>super</code>. (<a
          href=#refTHOM09>[THOM09]</a>).
          <dd>
            <pre>
              <code>
                class Child &lt; Parent
                  def do_something(*)
                    # our processing
                    super
                  end
                end
              </code>
            </pre>
          </dd>
        </figure>

      <h5>Named Arguments</h5>

        <p>The parameter forms described above are positional in nature.  They depend on the argument’s
        location in the parameter list to marry it with the correct parameter. An alternative approach, that
        can aid the readability of otherwise ungainly parameter lists, is <dfn id=named-arguments>named
          arguments</dfn>. Named arguments allow the method to be invoked with a series of key-value pairs,
        arranged in an arbitrary order.

        <p>Ruby does not offer explicit support for this style of argument passing, but it can be ably
        approximated by defining methods that expect a <code>Hash</code> argument: the keys of which become
        the parameter names; and the values, the arguments.

        <!-- TODO: Mention that File/IO, String#encode use this technique -->

        <figure id=named-arguments>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments.
          <dd>
            <pre>
              <code>
                class Chair
                  def initialize(args)
                    @legs = args[:legs] or raise ArgumentError
                    @style = args[:style] || :victorian
                    @height = args[:height] || :average
                    @colour = args[:colour] || args[:color] || :brown
                  end
                end
              Chair.new legs: 4, height: :tall #=&gt; 
                #&lt;Chair:0x8249908 @legs=4, @style=:victorian,
                @height=:tall, @colour=:brown&gt;
              Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                #&lt;Chair:0x86958f4 @legs=7, @style=:victorian,
                @height=:average, @colour=:fuschia&gt;
              Chair.new(height: :childs, color: :fuschia) #=&gt;
              ArgumentError 
              </code>
            </pre>
          </dd>
        </figure>

        <p>If the <code>Hash</code> is the final argument, other than a block, that a method expects, the
        curly braces which delimit the <code>Hash</code> can be omitted. For example, <code>m({ key:
          :value })</code> can be written as <code>m key: :value</code>.

        <p>The advantages of this approach include:
          <ul>
            <li>Arguments can be specified in any order.
            <li>Arguments with default values can be omitted.
            <li>If <code>Symbol</code>s are used for the <code>Hash</code> keys the invocation is
            particularly readable.
            <li>Variable-length argument lists are supported.
          </ul>

        <figure id=named-arguments-with-defaults>
        <dt>A method which uses a <code>Hash</code> argument to simulate named arguments with default
        values.
          <dd>
            <pre>
              <code>
                class Chair
                  DEFAULT_ARGS = {legs: 2, style: :victorian, height: :average, colour: :brown}
                  def initialize(args)
                    @attributes = DEFAULT_ARGS.merge args
                  end
                end
                Chair.new legs: 4, height: :tall #=&gt;
                  #&lt;Chair:0x9039af4 @attributes={
                  :legs=&gt;4,       :style=&gt;:victorian, 
                  :height=&gt;:tall, :colour=&gt;:brown
                  }&gt;
                Chair.new(:color =&gt; :fuschia, :legs =&gt; 7) #=&gt;
                  #&gt;Chair:0x998a9dc @attributes={
                  :legs=&gt;7, :style=&gt;:victorian, 
                  :height=&gt;:average, :colour=&gt;:fuschia
                  }&gt;
              </code>
            </pre>
          </dd>
        </figure>

        <p>The primary shortcoming is that Ruby can not determine automatically whether an invalid number of
        arguments have been supplied; the programmer must validate the arguments instead. This is unlikely
        to be particularly significant, however, because a method expecting a variable number of arguments
        would otherwise use rest arguments, which would also render it unable to perform this validation.

      <h5>Block Arguments</h5>
        
        <p>Any method may be invoked with a block literal as an argument by specifying the block after the
        method invocation.

        <aside class=note>
        <a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
          130-131)</a> insist on <q>[using] the term iterator…to mean any method that uses the
          <code>yield</code> statement</q>, despite admitting that this doesn't make sense if the method
        doesn’t actually <i>iterate</i> over the block it has been given. We will not perpetuate this
        confusion: an <i>iterator method</i> iterates over the block it has been given; a method which
        expects a block but does not iterate over it is simply <i>a method that expects a block</i>.
        </aside>

        <figure id=method-invocation-with-block-literal>
        <dt>A method which receives, and ignores, a block specified with either of the block literal
        constructs.
          <dd>
            <pre>
              <code>
              def m
                :m
              end
              m { 1 + 2 }
              m do
                1 + 2
              end
              </code>
            </pre>
          </dd>
        </figure>
         
        <p>The method may determine whether it has received a block by using the <code>block_given?</code>
        predicate.

        <figure id=method-using-block_given>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block.
          <dd>
            <pre>
              <code>
              def m
                puts "Thanks" if block_given?
              end
              m { 1 + 2 } #=&gt; "Thanks"
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A block passed to a method in this way is not automatically called; the method must use the
        <code>yield</code> keyword to do so. An implication of this is that methods not expecting blocks
        will ignore them. The return value of <code>yield</code> is that of the block.

        <!-- TODO: Mention that yield takes arguments -->

        <figure id=method-using-block_given-yield>
        <dt>A method which uses the <code>block_given?</code> predicate to determine whether it has been
        passed a block, and if so calls it.
          <dd>
            <pre>
              <code>
              def m
                puts "This block returns: #{yield}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <p>A method needing a reference to the block it was given, perhaps to pass to another method, is
        defined with a final parameter whose name is prefixed with an ampersand (U+0026:
        <code>&amp;</code>).  For example: <code> def m(a,b,&amp;block)</code>. The method can access the
        block as a <code>Proc</code> object named after the parameter (sans ampersand). It may invoke the
        block via its <code>Proc#call</code> method, or <code>yield</code> to it. In either case, the method
        is invoked in precisely the same way as before.

        <!-- Example with instance_eval ? -->

        <figure id=method-using-block-argument>
        <dt>A method which uses a <code>&amp;block</code> parameter to refer to the block it is given.
          <dd>
            <pre>
              <code>
              def m(&amp;block)
                puts "This block returns: #{block.call}" if block_given?
              end
              m { 1 + 2 } #=&gt; This block returns: 3
              m #=&gt; nil
              </code>
            </pre>
          </dd>
        </figure>

        <aside class=note>

        <p>The discussion above applies only to block literals; a method expecting a <em>reference</em> to a
        block, i.e. a <code>proc</code> or <code>lambda</code>, need not pay heed. Such a method employs
        precisely the same parameter list as in the previous sections.

        <figure id=method-receiving-block-ref>
        <dt>A method which expects a reference to a block uses the same parameter list as it would if
        expecting any other type of variable.
          <dd>
            <pre>
              <code>
              def m(b)
                b.call
              end
              m -&gt;{ "I am a \u{3bb}!" } #=&gt; "I am a λ!"
              </code>
            </pre>
          </dd>
        </figure>

        </aside>

  <h3>Undefining</h3>

    <p>The <code>undef</code> statement takes one or more <code>Symbol</code>s as arguments, then
    undefines the corresponding instance methods. It does not work with singleton methods.

    <figure id=undef-method>
    <dt>Undefining a method with <code>undef</code>.
      <dd>
        <pre><code>
        def boo!
          "(goose)"
        end
        boo! #=&gt; "(goose)"              
        undef :boo!
        boo! #=&gt; NoMethodError: undefined method `boo!' for main:Object 
        </code></pre>
      </dd>
    </figure>

    <p>Undefining a method defined in a superclass does not affect the superclass’s definition. For
    example, consider a <code>Rectangle</code> class which defines <code>:height</code> and
    <code>:width</code> methods. A <code>Square</code> class inherits from it, but it doesn't make sense
    for <code>Square</code> to have both <code>:height</code> <i>and</i> <code>:width</code> methods.
    <code>Square</code> can <code>undef</code> <code>:height</code>, preventing
    <code>Square#height</code> from being called without affecting <code>Rectangle#height</code>.

  <h3>Visibility</h3>

    <p>An instance method is either <i>public</i>, <i>private</i>, or <i>protected</i>. It is declared
    as such with <code>Module#public</code>, <code>Module#private</code>, and
    <code>Module#protected</code> (hereafter: <i>visibility
      specifiers</i>), respectively.

    <p>A visibility specifier invoked without arguments affects every method subsequently defined in the
    same class definition until another visibility specifier is encountered.

    <figure id=visibility-specifiers>
      <dt>Declaring the visibility of methods with visibility specifiers
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          private
          # This method is private because it appears after the
          #'private' visibility specifier
          def pri
          end

          # This method is also private because the previous visibility
          # specifier has not been overridden
          def pri2
          end

          protected
          # This method is protected because it appears after the
          #'protected' visibility specifier
          def pro
          end
          
          public
          # This method is public because the protected visibility
          # specifier has been explicitly overridden. Typically this would
          # have been defined after 'pub', removing the need for a
          # visibility specifier
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <p>A visibility specifier with one or more method names (given as <code>Symbol</code>s or
    <code>String</code>s) affects only the named methods, which must have already been defined.

    <figure id=visibility-specifiers-args>
      <dt>Declaring the visibility of methods with visibility specifiers that take arguments
      <dd>
        <pre><code>
        class C                
          # This method is public because it hasn't been specified
          # otherwise
          def pub
          end
          
          def pri
          end

          def pri2
          end

          # Both :pri and :pri2 are made private because their names are
          # given as arguments to the 'private' visibility specifier
          private :pri, :pri2

          def pro
          end
          # This method is made protected because its name is given to
          # the 'protected' visibility specifier
          protected 'pro'
          
          # This method is public because it hasn't been declared
          # otherwise; the previous 'protected' specifier only affects the
          # method it was called for
          def pub2
          end  
        end  
        </code></pre>
      </dd>
    </figure>

    <h4>Advisory Privacy</h4>

      <p>Method visibility is merely an advisory construct. Ruby does not <i>prohibit</i> the invocation
      of private methods; she ensures that they will not be called accidentally as follows:

      <ul>
        <li>Standard method invocation syntax (<code>obj.method</code>) raises a
        <code>NoMethodError</code>, signaling that the programmer's intent is ill-advised. The caviller
        programmer must use a technique such as <code>Object#send</code> to explicitly ignore the privacy
        advice.
        <li>The method introspection API (e.g.
        <code>Object#private_methods</code>,
        <code>Object#protected_methods</code>, and
        <code>Object#public_methods</code>) delineates methods by their visibility, allowing private and
        protected methods to be determined automatically.
        <li>RDoc/<code>ri</code> only displays public methods by default.
      </ul>

    <h4>Public Methods</h4>

      <p>A method is public unless explicitly declared otherwise, or declared outside of a class
      definition. The <code>initialize</code> method is private by default.

    <h4>Private Methods</h4>

      <p>A <dfn id=private-method>private method</dfn> cannot be invoked with an explicit receiver.
      Therefore it can only be called by other instance methods of the class in which defined,
      or a subclass thereof. 

      <p><code>self</code> is also regarded as an explicit receiver so a method invocation of the form
      <code>self.<var>private</var></code>, where <var>private</var> is a private instance method in the
      same class, is disallowed.

      <aside class=note>
      Methods created outside of a class or module definition, i.e. at the top level, are private by
      default The <code>:initialize</code> method is, too, because it is only intended to be invoked
      from the object’s <code>:new</code> method.
      </aside>

    <h4>Protected Methods</h4>

      <p>Protected methods can invoked only from the class in which they were defined or a subclass
      thereof, that is they behave the same as private methods. However, unlike private methods they can
      be explicitly invoked on any instance of their class.

      <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
        232)</a> suggest that <q>A protected method can be used, for example, to define an accessor that
        allows instances of a class to share internal state with each other, but does not allow users of
        the class to access that state.</q>

  <h3>Aliases</h3>

    <p>An <dfn id=method-alias>alias</dfn> of a method is an alternate name by which it can be referred.
    For a method, <var>m</var>, and its alias, <var>a</var>, invoking <var>m</var> is equivalent to
    invoking <var>a</var>.

    <p>The alias refers to a copy of the existing method’s body. If the existing method is redefined
    prior to being aliased, the alias will continue to refer to the method’s original definition.

    <p>Aliases are often used to provide synonyms for method names. For instance, <code>:size</code> may
    be aliased to <code>:length</code>.  This allows the programmer to use method names which “read”
    more naturally in a given context. <!-- TODO: example from FLAN09 about Range#include? ? -->

    <p>An alias is created with the <code>alias</code> keyword from inside the class of the existing
    method. The syntax is <code>alias <var>new_name</var>
      <var>current_name</var></code>, where both <var>new_name</var> and <var>current_name</var> are
    <code>Symbol</code>s or identifiers. A method named <var>current_name</var> must already be defined.
    If a method named <var>new_name</var> already exists it is overwritten.

    <!-- TODO: Mention alias_method_chain ? -->

    <p>Aliasing is also used to create a method which wraps the method of the same name by performing
    its own computations then calling the original method. For example, in the example below we wrap
    <code>String#to_i</code> such that it raises an exception if the string doesn't contain digits.
    (Normally, <code>String#to_i</code> returns <code>0</code> for such strings).

    <figure id=alias-for-wraping>
    <dt>Using <code>alias</code> in order to wrap a method
      <dd>
        <pre><code>
        class String
          alias :old_to_i :to_i
          def to_i
            raise "No digits found" unless match(/\d/)
            old_to_i
          end
        end
        </code></pre>
      </dd>
    </figure>

    <!-- TODO: Link with example of using method objects to wrap methods
    (c.f.
    http://blog.jayfields.com/2006/12/ruby-alias-method-alternative.html);
    explain pros/cons -->

  <!-- TODO: Discuss method overloading? -->

  <h3><code>Object#send</code></h3>

    <figure id=object-send>
    <dt><code>Object#send</code> sends an object a message whose name can be determined at runtime.
    <dd>
      <pre><code>
        name = :size
        # Sends "wool" the :name message
        "wool".name #=&gt; NoMethodError: undefined method `name' for "wool":String
        # Sends "wool" the :size message
        "wool".send(name) #=&gt; 4
      </code></pre>  
    </dd>
    </figure>

  <!-- TODO: define_method -->
  <h3><code>Method</code> Objects</h3>

  <p>An instance of the <code>Method</code> class represents a method bound to an object. This <dfn
      id=method-object>method
      object</dfn> enables you to store a reference to a method in a variable, as you would any other
    object, query the method’s metadata, and manipulate it. This is quite distinct from capturing the
    return value of a method. <!-- TODO: Note that unlike procs, method objects aren't closures -->

    <p>Method objects can be created with <code>Kernel#method</code>:
    <code><var>receiver</var>.method(<var>name</var>)</code>, where <var>name</var> is the method
    name as a <code>Symbol</code> or <code>String</code>. For example, <code>method(:eval)</code>
    returns a <code>Method</code> object for <code>Kernel#eval</code>. If the object does not
    <code>respond_to?</code> the given method a <code>NameError</code> will be raised. (Therefore,
    if the object’s <code>respond_to_missing?</code> method returns <code>true</code> for the method
    in question the method object will be created successfully).

    <p><code>Kernel#public_method</code> works in the same way, but raises a <code>NameError</code>
    if the given method is private or protected.

    <h4>Arity</h4>

      <p><code>Method#arity</code> returns an <code>Integer</code> corresponding to the method’s arity. If
      the method expects a fixed number of arguments, the number of arguments it expects will be returned.
      If the method expects a variable number of arguments, the additive inverse of its parameter count
      will be returned. Methods implemented in C, i.e.  most core methods, have an arity of
      <code>-1</code> if they accept a variable number of parameters. It follows, then, that a return
      value ≥ 0 indicates a fixed number of parameters; a negative value, a variable number. 

    <h4>Calling</h4>

      <p>The method represented by a <code>Method</code> object can be invoked with
      <code>Method#call</code> or its alias <code>Method#[]</code>. The semantics are the same as
      for standard method invocation. <a href=#refFLAN08>Flanagan &amp; Matsumoto</a> caution,
      however: <q>…invoking a method through a <code>Method</code> object is less efficient than
        invoking it directly.</q>

    <h4>Converting to a <code>Proc</code></h4>
      
      <p>A method object can be converted to a <code>Proc</code> by prefixing it with an ampersand
      (<code>&amp;</code>). Therefore it can be passed to a method expecting a block. <!-- TODO: Note
      availability of Symbol:to_proc; use with define_method -->
    
    <h4>Equality</h4>

      <!-- Bug: #1898 -->
      <p><code>Method#==</code> returns true if both methods are bound to the same object and have
      the same body. The first requirement means that the objects must be identical in the sense of
      <code>Object.equal?</code>. The second encompasses methods defined with
      <code>Object#define_method</code> using the same <code>Proc</code>/block, aliases created
      with <code>alias</code>, and core method aliases. <!-- TODO: clarify situation with
      #respond_to_missing? -->

    <h4>Source Location</h4>

      <p>The filename and line number where a method was defined is returned as an <code>Array</code>
      by <code>Method#source_location</code>. If the method is core, i.e. implemented in C, it returns
      <code>nil</code>. This is primarily useful for extracting a method’s signature and any preceding
      documentation.

    <h4>Parameters</h4>

      <!-- [ruby-core:19759] Proposal: Method#get_args -->   
      
      <p><code>Method#parameters</code> returns an <code>Array</code>, each element of which is a
      sub-<code>Array</code> of <code>Symbol</code>s that describe the corresponding parameter
      expected by the method. The first <code>Symbol</code> is <code>:req</code> for a required
      parameter, <code>:opt</code> if it is optional, <code>:rest</code> if its of variable length,
      or <code>:block</code> if it corresponds to a block. The last <code>Symbol</code> is the name
      of the parameter. An empty <code>Array</code> is returned for method’s expecting no arguments.

  <h3><code>UnboundMethod</code> Objects</h3>

    <p><code>Module#instance_method</code> is used in the same way:
    <code><var>receiver</var>.instance_method(<var>name</var>)</code>.  It is used to create an
    <code>UnboundMethod</code> object for the given <em>instance method</em> of a class. For example,
    <code>String.instance_method(:size)</code> returns an <code>UnboundMethod</code> object for
    <code>String#size</code>.


    In addition to the Method class, Ruby also defines an UnboundMethod class. As its name
    suggests, an UnboundMethod object represents a method, without a binding to the object
    on which it is to be invoked. Because an UnboundMethod is unbound, it cannot be
    invoked, and the UnboundMethod class does not define a call or [] method.
    To obtain an UnboundMethod object, use the instance_method method of any class or
    module:
    unbound_plus = Fixnum.instance_method("+")
    In Ruby 1.9, you can also use public_instance_method to obtain an UnboundMethod
    object. It works like instance_method does, but it ignores protected and private methods
    (see §7.2).
    In order to invoke an unbound method, you must first bind it to an object using the
    bind method:
    204 | Chapter 6: Methods, Procs, Lambdas, and Closures
    plus_2 = unbound_plus.bind(2)  # Bind the method to the object 2
    The bind method returns a Method object, which can be invoked with its call method:
    sum = plus_2.call(2)    # => 4
    Another way to obtain an UnboundMethod object is with the unbind method of the
    Method class:
    plus_3 = plus_2.unbind.bind(3)
    In Ruby 1.9, UnboundMethod has name and owner methods that work just as they do for
    the Method class.

<h2>Classes</h2>

  <p>We have introduced classes as templates from which objects can be
  created. A class is typically created with the <code>class</code>
  keyword followed by the class name.

  <figure id=class-keyword>
  <dt>Usage of the <code>class</code> keyword to <i>open</i> a class named
  <code>Dog</code></dt>
  <dd>
    <pre><code>
    class Dog
    end
    </code></pre>
  </dd>
  </figure>

  <p>The <code>Class.new</code> constructor may be used to the same effect
  if it is assigned to a constant.

  <figure id=class-new>
  <dt>Usage of the <code>Class.new</code> constructor to create a class
  named <code>Dog</code></dt>
  <dd>
    <pre><code>
    Dog = Class.new
    </code></pre>
  </dd>
  </figure>

  <h3>Names</h3>

  <h4>Rules</h4>

  <p>The name of class must: 
    <ul>
      <li>Begin with an uppercase ASCII letter (A-Z) (U+0041..U+005A).
      <li>Not contain a colon (U+003A).
      <li>Not contain an ASCII space character (U+0020)
    </ul>
    <!-- FIXME: Derive and enumerate rules -->

  <p>More generally, a class name consists of an uppercase ASCII character, optionally followed by a
  sequence of other alphanumeric characters

  <aside class=warning>
    Class names containing non-ASCII characters cannot be referred to from source files using a
    different encoding. For example, a class name containing character U+03BB (<i>GREEK SMALL LETTER
      LAMDA</i>) can only be referenced from source files using the UTF-8 source encoding. <!-- FIXME:
    What about other Unicode character sets? -->
   </aside>

  <h4>Conventions</h4>

  <p>Conventionally class names use camel-case capitalization: The initial letter of each word is
  capitalized, and spaces between the words are removed. For example:
  <code>RubyProgrammingLanguage</code> or <code>NutsAndBolts</code>.</p>

  <p>A class name is a constant. The use of camel-case for class names and uppercase for constant
  names ensures that the two don't clash.

  <h3>Reopening Classes</h3>

  <p>If <code>class</code> is used with the name of a pre-existing class that class is
  <i>re-opened</i>. If a method is defined in a re-opened class with the same name as a pre-existing
  method in the same class the old method is overwritten with the new.

  <figure id=reopened-class>
    <dt>Re-defining a method in an existing class</dt>
    <dd>
      <pre><code>
        'hello'.size #=&gt; 5
        class String
          def size
            'How long is a piece of string?'
          end
        end
        'hello'.size #=&gt; 'How long is a piece of string?'
      </code></pre>
    </dd>
  </figure>  

  <h3>Anonymous Classes</h3>

  <p>When a constant is used as a class name it has global scope. This gives rise to the
  characteristic described above in <i>Reopening
    Classes</i>. If this behaviour is not desirable, a class can be made anonymous by assigning the
  value of <code>Class.new</code> to a local variable, thus restricting the class to the local scope.

  <figure id=anonymous-class>
  <dt>Creating an anonymous class with <code>Class.new</code></dt>
    <dd>
      <pre><code>
        dog = Class.new
        dog.class_eval do
          def bark
            :woof
          end
        end
        dog.new.bark #=&gt; :woof
      </code></pre>
    </dd>
  </figure>

<h2>References</h2>
  <dl>
  <dt id=refBROWN09>[BROWN09]</dt>
  <dd><cite><a href=//rubybestpractices.com/>Ruby Best Practices</a></cite>, G. Brown, O'Reilly Media,
  2009.</dd>
  <dt id=refFLAN08>[FLAN08]</dt>
  <dd><cite><a href=//oreilly.com/catalog/9780596516178>The Ruby Programming Language</a></cite>, D.
  Flanagan &amp; Y. Matsumoto, O'Reilly Media, 2008.</dd>
  <dt id=refTHOM09>[THOM09]</dt>
  <dd><cite><a href=//books.pragprog.com/titles/ruby3/programming-ruby-1-9>Programming Ruby 1.9: The
      Pragmatic Programmers’ Guide</a></cite>, D. Thomas, et al., The Pragmatic Bookshelf, 2009.</dd>
  </dl>
<body>
</html>

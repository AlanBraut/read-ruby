<!DOCTYPE html>
<html>
  <head>
    <title>Ruby</title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <h1>Ruby</h1>
      
      <h2>Objects</h2>
      <p>Ruby embodies the object-orientated paradigm. She holds as
      fundamental that <q>everything is an object</q>.

      <p>An <dfn id=object>object</dfn> is a compilation of data
      (attributes) and behaviour (methods) which encapsulate a specific
      <i>instance</i> of a <i>class</i>. The String <code>"hello"</code> and
      the Integer <code>3</code> are both examples of objects, and instances
      of the <i>String</i> and <i>Integer</i> classes, respectively. They
      constitute data (<q>hello</q> and <q>3</q>, respectively) and behaviour
      relevant to that data.

      <p>A <dfn id=class>class</dfn> is a <i>classification</i> of objects. It
      constitutes a template from which such objects can be constructed. Hence
      <code>3</code> and <code>198705</code> are both instances of the
      <code>Integer</code> class. Their data (i.e. their numerical value)
      differs but they behave as any other instance of their class. That is,
      by their nature as integers both objects can be multiplied by another
      integer, and both are either odd or even, etc.
      
      <aside>The term <i>class</i> is roughly analogous to its biological
      definition where it denotes a taxonomic rank, however this analogy does not
      extend to subclasses. That is, a subclass of a class is termed a
      <i>subclass</i>; not an <i>order</i>.</aside>
      
      <h2>Methods</h2>
        
        <p>A <dfn id=method>method</dfn> is a block of code associated with a
        class or object. For now we will define <i>block of code</i> as a
        sequence of one or more statements.

        <p>A method is invoked for the side-effect it causes, the value it
        returns, or a combination of these factors. Note that this definition
        encompasses <i>accessor</i> and <i>mutator</i> methods; Ruby makes no
        such distinction.

        <h3>Instance Methods</h3>

          <p>An instance method is a behaviour of an object. It is typically
          created with the <code>def</code> keyword in the context of a class.
          
          <aside>
          It is conventional to employ the <code>Class#method</code> notation
          when referring to instance methods in documentation and prose. For
          example: <code>Integer#even?</code>.
          </aside>

          <figure id=def-instance-method>
          <dt>Defining an instance method named <code>bark</code> for the <code>Dog</code> class
            with the <code>def</code> keyword.
            <dd>
              <pre><code>
                class Dog
                  def bark
                    :woof
                  end
                end
                Dog.new.bark #=&gt; :woof
              </code></pre>  
            </dd>
          </figure>

        <h3>Singleton Methods</h3>

          <p>A singleton method is associated with a class as opposed to its
          instances. Indeed, it is typically a <i>factory method</i>: a constructor of
          instances. They are also created with the <code>def</code> keyword,
          but their names are prefixed with <code>self.</code> to denote their
          singleton status.
          
          <figure id=def-singleton-method>
          <dt>Defining a singleton method named <code>breed</code> for the
          <code>Dog</code> class with the <code>def</code> keyword.
            <dd>
              <pre><code>
                class Dog
                  def self.breed
                    [new, new]
                  end
                end
                Dog.breed #=&gt; [#<Dog:0x95cb530>, #<Dog:0x95cb508>]
              </code></pre>  
            </dd>
          </figure>

          <aside>
          It is conventional to employ the <code>Class.method</code>
          notation when referring to singleton methods in documentation and
          prose. For example: <code>File.exists?</code>.
          </aside>

          <h3>Return Values</h3>

          <p>A method always returns a value. This is <code>nil</code> if the
          method was defined without a body; the last statement executed
          otherwise. If an explicit <code>return</code> statement is reached
          inside a method, its value will be returned. 

          <p>This gives rise to two conventions:
            <ul>
              <li>A method uses a <code>return</code> statement iff it may
              return before its last statement.
              <li>A method intended to return a value has that value as its
              last statement
            </ul>
          </p>
          
          <!-- TODO: Mention Object#tap -->

          <figure id=def-implicit-return>
            <dt>A method which returns the Symbol <code>:to_sender</code>
            <dd>
              <pre><code>
                def elvis
                  :to_sender
                end
              </code></pre>
            </dd>
          </figure>

          <h3>Names</h3>

            <h4>Conventions</h4>

            <p><i>Predicate</i> methods (those which return either
            <code>true</code> or <code>false</code>) use a <code>?</code>
            suffix. For example: <code>Integer#even?</code>.

            <p>The <code>!</code> suffix (colloquially called a <i>bang</i>)
            is used <q>…to mark a method as special. It doesn’t necessarily
              mean that it will be destructive or dangerous, but it means that
              it will require more attention than its alternative.</q> <a
              class=ref href=#refBROWN09>[Brown,
            2009, pp. 52]</a>. <q>Usually, the method without the exclamation
            mark returns a modified copy of the object it is invoked on, and
            the one with the exclamation mark is a mutator method that alters
            the object in place.</q> <a class=ref href=#refFLAN08>[Flanagan
            &amp; Matsumoto, 2008, pp. 7]</a> 

            <h4>The <code>=</code> Suffix</h4>
            
            <p>Methods named with a <code>=</code> suffix can be used in
            assignment statements as <i>lvalues</i>. That is, a method defined
            as <code>name=(value)</code> on object <code>obj</code> can be
            invoked as <code>obj.name = value</code> or
            <code>obj.name=(value)</code>.     

            <aside class=warning>
            <p>The syntax <code>name = value</code> is therefore ambiguous. Is
            the intent to assign the value <code>value</code> to the local variable
            <code>name</code> or to invoke the method named <code>name=</code>
            with <code>value</code> as the argument?

            <p>The resolution is to always invoke a <code>=</code>-suffixed method with an explicit
            receiver, such as <code>self</code>. Alternatively, make it
            explicit that you are invoking a method with the
            <code>name=(value)</code> syntax.
            </aside>
           
        <h3>Visibility</h3>

        <p>An instance method is either <i>public</i>, <i>private</i>, or
        <i>protected</i>. It is declared as such with
        <code>Module#public</code>, <code>Module#private</code>, and
        <code>Module#protected</code> (hereafter: <i>visibility
          specifiers</i>), respectively.

         <p>A visibility specifier invoked without arguments affects every
         method subsequently defined in the same class definition until
         another visibility specifier is encountered.

          <figure id=visibility-specifiers>
            <dt>Declaring the visibility of methods with visibility specifiers
            <dd>
              <pre><code>
              class C                
                # This method is public because it hasn't been specified
                # otherwise
                def pub
                end
                
                private
                # This method is private because it appears after the
                #'private' visibility specifier
                def pri
                end

                # This method is also private because the previous visibility
                # specifier has not been overridden
                def pri2
                end

                protected
                # This method is protected because it appears after the
                #'protected' visibility specifier
                def pro
                end
                
                public
                # This method is public because the protected visibility
                # specifier has been explicitly overridden. Typically this would
                # have been defined after 'pub', removing the need for a
                # visibility specifier
                def pub2
                end  
              end  
              </code></pre>
            </dd>
          </figure>

         <p>A visibility specifier with one or more method names (given as
         Symbols or Strings) affects only the named methods, which must have
         already been defined.

          <figure id=visibility-specifiers-args>
            <dt>Declaring the visibility of methods with visibility specifiers
            that take arguments
            <dd>
              <pre><code>
              class C                
                # This method is public because it hasn't been specified
                # otherwise
                def pub
                end
                
                def pri
                end

                def pri2
                end

                # Both :pri and :pri2 are made private because their names are
                # given as arguments to the 'private' visibility specifier
                private :pri, :pri2

                def pro
                end
                # This method is made protected because its name is given to
                # the 'protected' visibility specifier
                protected 'pro'
                
                # This method is public because it hasn't been declared
                # otherwise; the previous 'protected' specifier only affects the
                # method it was called for
                def pub2
                end  
              end  
              </code></pre>
            </dd>
          </figure>

          <h4>Advisory Privacy</h4>

          <p>Method visibility is merely an advisory construct. Ruby does not
          <i>prohibit</i> the invocation of private methods; she ensures that
          they will not be called accidentally as follows:

          <ul>
            <li>Standard method invocation syntax (<code>obj.method</code>)
            raises a <code>NoMethodError</code>, signaling that the
            programmer's intent is ill-advised. The caviller programmer must
            use a technique such as <code>Object#send</code> to explicitly
            ignore the privacy advice.
            <li>The method introspection API (e.g.
            <code>Object#private_methods</code>,
            <code>Object#protected_methods</code>, and
            <code>Object#public_methods</code>) delineates methods by their visibility,
            allowing private and protected methods to be determined
            automatically.
            <li>RDoc/<code>ri</code> only displays public methods by default.
          </ul>

          <h4>Public Methods</h4>

          <p>A method is public unless explicitly declared otherwise, or
          declared outside of a class definition. The <code>initialize</code>
          method is private by default.

          <h4>Private Methods</h4>

          <p>A <dfn id=private-method>private method</dfn> cannot be invoked
          with an explicit receiver.  Therefore they can only be called by
          other instance methods of the class in which they were defined, or a
          subclass thereof. 

          <p><code>self</code> is also regarded as an explicit receiver so a
          method invocation of the form <code>self.<var>private</var></code>,
          where <var>private</var> is a private instance method in the same
          class, is disallowed.


          <h4>Protected Methods</h4>

          <p>Protected methods can invoked only from the class in which
          they were defined or a subclass thereof, that is they behave the
          same as private methods. However, unlike private methods
          they can be explicitly invoked on any instance of their class.

          <p><a class=ref href=#refFLAN08>Flanagan &amp; Matsumoto (2008, pp.
            232)</a> suggest that <q>A
            protected method can be used, for example, to define an accessor
            that allows instances of a class to share internal state with each
            other, but does not allow users of the class to access that
            state.</q>

           
       <h2>Classes</h2>

      <p>We have introduced classes as templates from which objects can be
      created. A class is typically created with the <code>class</code>
      keyword followed by the class name.

      <figure id=class-keyword>
      <dt>Usage of the <code>class</code> keyword to <i>open</i> a class named
      <code>Dog</code></dt>
        <dd>
          <pre><code>
          class Dog
          end
          </code></pre>
        </dd>
      </figure>

      <p>The <code>Class.new</code> constructor may be used to the same effect
      if it is assigned to a constant.

      <figure id=class-new>
      <dt>Usage of the <code>Class.new</code> constructor to create a class
      named <code>Dog</code></dt>
        <dd>
          <pre><code>
          Dog = Class.new
          </code></pre>
        </dd>
      </figure>

        <h3>Names</h3>
          
          <h4>Rules</h4>
          
          <p>The name of class must: 
            <ul>
              <li>Begin with an uppercase ASCII letter (A-Z) (U+0041..U+005A).
              <li>Not contain a colon (U+003A).
              <li>Not contain an ASCII space character (U+0020)
            </ul>
            <!-- FIXME: Derive and enumerate rules -->

          <p>More generally, a class name consists of an uppercase ASCII
          character, optionally followed by a sequence of other alphanumeric
          characters

          <aside class=warning>
            Class names containing non-ASCII characters cannot be referred to
            from source files using a different encoding. For example, a class
            name containing character U+03BB (<i>GREEK SMALL LETTER LAMDA</i>)
            can only be referenced from source files using the UTF-8 source
            encoding. <!-- FIXME: What about other Unicode character sets? -->
           </aside>

          <h4>Conventions</h4>

          <p>Conventionally class names use camel-case capitalization: The
          initial letter of each word is capitalized, and spaces between the
          words are removed. For example:
          <code>RubyProgrammingLanguage</code> or
          <code>NutsAndBolts</code>.</p>

          <p>A class name is a constant. The use of camel-case for class names
          and uppercase for constant names ensures that the two don't clash.

        <h3>Reopening Classes</h3>

        <p>If <code>class</code> is used with the name of a pre-existing class
        that class is <i>re-opened</i>. If a method is defined in a re-opened
        class with the same name as a pre-existing method in the same class
        the old method is overwritten with the new.

        <figure id=reopened-class>
          <dt>Re-defining a method in an existing class</dt>
          <dd>
            <pre><code>
              'hello'.size #=&gt; 5
              class String
                def size
                  'How long is a piece of string?'
                end
              end
              'hello'.size #=&gt; 'How long is a piece of string?'
            </code></pre>
          </dd>
        </figure>  

        <h3>Anonymous Classes</h3>

        <p>When a constant is used as a class name it has global scope. This
        gives rise to the characteristic described above in <i>Reopening
          Classes</i>. If this behaviour is not desirable, a class can be made
        anonymous by assigning the value of <code>Class.new</code> to a local
        variable, thus restricting the class to the local scope.

        <figure id=anonymous-class>
        <dt>Creating an anonymous class with <code>Class.new</code></dt>
          <dd>
            <pre><code>
              dog = Class.new
              dog.class_eval do
                def bark
                  :woof
                end
              end
              dog.new.bark #=&gt; :woof
            </code></pre>
          </dd>
        </figure>
  
  <h2>References</h2>
    <dl>
      <dt id="refBROWN09">[BROWN09]</dt>
      <dd><cite><a href=//rubybestpractices.com/>Ruby Best Practices</a></cite>,
      G. Brown, O'Reilly Media, 2009.</dd>
      <dt id="refFLAN08">[FLAN08]</dt>
      <dd><cite><a href=//oreilly.com/catalog/9780596516178>The Ruby Programming Language</a></cite>,
      D. Flanagan &amp; Y. Matsumoto, O'Reilly Media, 2008.</dd>
    </dl>
  <body>
</html>

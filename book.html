<!DOCTYPE html>
<!-- vim: set fdm=indent tw=78: --> 
<html>
  <head>
    <title>Ruby</title>
    <meta charset="utf-8"/>
    <!-- <script src="http://html5-now.appspot.com/base2-legacy.js"></script> 
    <script src="http://html5-now.appspot.com/html5-now.js"></script>
    -->
  </head>
  <body>
<h1>Ruby</h1>
<!-- html2text book.html | diction --language en_GB --suggest|less -->
<!-- Cover: Read\nRuby with Rs overlapping, caligraphy font? -->

<h2>Names</h2>
<!-- Chapter on variables? -->
<!-- Include in Principles? -->
<ol>
  <li>Variables
  <li>Conventions
  <li>Scope?
  <li>Symbols as names
  <li>Assignment
  <li>Constants
</ol>

<ol>
  <li><a href=principles.html>Principles</a>
  <li><a href=messages.html>Messages</a>
  <li><a href=methods.html>Methods</a>
  <li><a href=objects.html>Objects</a>
  <li><a href=classes.html>Classes</a>
  <li>Closures
</ol>

    <h2>Messages</h2>
      <p>A message is a <q>request for an object to perform some operation</q>
      (<a href=#refBUDD87 class=ref>Budd</a>, p. 6). It consists of <q>a
        <i>receiver</i>, a message <i>selector</i>, and zero or more
        <i>arguments</i>.</q> (<a href=#refBUDD87 class=ref>Budd</a>, p. 16).
      An object <i>sends</i> a message to another object.
      <p>The <dfn title=receiver>receiver</dfn> is the object to which the
      message is sent. If not specified an <i>implicit</i> receiver of the
      current object (<code>self</code>) is assumed.
      <p>The <dfn title=selector>selector</dfn> is the name of the operation
      the receiver should perform. Typically this corresponds to the name of a
      method in the receiver, but need not if <code>method_missing</code> <!--
      Link --> is used.
      <p><code>Object#respond_to?(<var>selector</var>)</code> returns
      <code>true</code> if an object understands the given selector.
      <p>The <dfn title=arguments>arguments</dfn> are a list of variables to
      be used in the receiver’s computations.  Arguments are passed by
      reference, so when the receiver modifies an object it receives, the
      sender’s copy will also be affected.
      <p>Prefixing an <code>Enumerable</code> argument’s name with an asterisk causes it to be
      exploded into its constituent elements by sending it
      <code>#to_ary</code>. For example, if a message expects three arguments and the sender
      has an <code>Array</code>, <var>array</var>, each element of which constitutes an
      argument, he can’t supply <var>array</var> as an argument, because then
      the receiver would only receive one argument (a reference to
      <var>array</var>); he must send <code>*array</code>, instead.  
      <p>Similarly, if a message is to be sent with a literal block but the
      sender only has a reference to one, he may prefix the block name with an
      ampersand (<code>&amp;</code>). This sends the argument
      <code>#to_proc</code>, leaving it indistinguishable from a block literal
      to the method.
      <h3>Message Expression Syntax</h3>
      <p>The syntax
      <code><var>receiver</var>.<var>selector</var>(<var>argument<sub>0</sub></var>,</code>…<code>,<var>argument<sub>n</sub></var>)</code>
        sends a message with the selector <var>selector</var> to the object
        <var>receiver</var> with arguments
        <var>argument<sub>0</sub></var>–<var>argument<sub>n</sub></var>.
        Omitting <code><var>receiver</var>.</code> causes the message to be
        sent to <code>self</code>. 
      <p>The parenthetical is a comma-separated list of variables. It can be
      omitted if no arguments are being sent. Whitespace is forbidden between
      <var>selector</var> and the opening parenthesis. The parentheses are
      only required when they resolve ambiguity. <!-- Explain this better -->
      If they are omitted, whitespace <em>is</em> required between the selector and
      first argument.
      <p>A message expression may be followed by a block literal, which is
      made available to the receiver.
      <p>The syntax above requires the selector to be a literal, hardcoded
      into the source file. It can be determined dynamically at runtime with
      <code>Object#send(<var>selector</var>,
        <var>argument<sub>0</sub></var>,</code>…<code>,<var>argument<sub>n</sub></var>)</code>,
        where <var>selector</var> is a <code>Symbol</code>, e.g.
        <code>3.send(:odd?) #=&gt; true</code>.
    <h2>Methods</h2>
      <p>A method is the means by which an object responds to a message. An
      object that receives a message attempts to invoke a method with the same
      name as the selector.
      <p>By default a method is an <dfn title="instance method">instance
        method</dfn>: it is available to every instance of the class inside
      which it is defined. For example, <code>String#upcase</code> is an
      instance method because each <code>String</code> instance responds to
      it.
      <p>A <dfn title="singleton method">singleton method</dfn>, by contrast,
      is defined on a specific, <i>single</i> object. Class methods are
      singleton methods defined on a <code>Class</code> object. For example,
      <code>File.expand_path</code> is a singleton method defined on the
      <code>File</code> class.
      <p>Methods are defined with the <code>def</code> keyword:
      <pre><code>
        def
        <var>name</var>(<var>parameter<sub>0</sub></var>,</code>…<code>,<var>parameter<sub>n</sub></var>)
          <var>body</var>
        end
      </pre></code>
      <p><var>name</var> is the method name. If <var>name</var> is of the form
      <code><var>object</var>.<var>name</var></code> the method is a singleton
      method defined on <var>object</var>. For example, <code>def
        Array.glark</code> defines a singleton method on the
      <code>Array</code> class. Otherwise, if <var>name</var> does not include
      a period, an instance method is defined. 
      <p>The <var>body</var> is a sequence of statements which will be
      executed when the method is invoked. The last statement executed is the
      method’s <dfn title="method return value">return value</dfn>. A method
      may return prematurely with the <code>return
        <var>value<sub>0</sub></var>,</code>…<code>,<var>value<sub>n</sub></var></code>
      keyword. If no arguments are supplied, <code>nil</code> will be
      returned. <!--
      Expand on return values? -->
      <p>The parenthetical portion is the <dfn id="paramater
        list">parameter list</dfn>, which is omitted if the method expects no arguments.
      <p>Parameters are the names of local variables to which the
      corresponding arguments will be assigned. A parameter list of <code>(a,
        b)</code> assigns the first argument to a local variable named
      <var>a</var>, and the second to a variable named <var>b</var>.
      Parameters specified in this way are <dfn title="required
        parameters">required</dfn>; if the method does not receive the same
      number of arguments as it has parameters, an <code>ArgumentError</code>
      will be raised.
      <p>A parameter can be <dfn title="optional paramaters">optional</dfn>
      with the <code><var>parameter</var>=<var>default</var></code> syntax,
      where <var>default</var> is an expression whose value will be assigned
      to <var>parameter</var> if a corresponding argument is not supplied. For
      example, a parameter list of <code>(a,b=2)</code> allows either one or
      two arguments to be supplied; in the first case, <var>b</var> will be
      assigned the value <code>2</code>.
      <p>A parameter prefixed with an asterisk consumes every remaining
      parameter while still allowing any following parameters to receive their
      arguments. The arguments consumed are given to the method as an
      <code>Array</code>. For example, a parameter list of <code>(a, b=2,
        *c)</code> requires at least one argument, with the second defaulting
      to <code>2</code>, and any remaining arguments being stored in an
      <code>Array</code> named <var>c</var>.
      <p>The final parameter may be prefixed with an ampersand, in which case
      the method accepts, but does not require, a block literal argument. If
      the method simply wants to <code>yield</code> to a block it receives,
      this parameter is unnecessary; it is used when the method needs a
      reference to the block, perhaps for assigning to a variable or sending
      to another method. 
      <p>A method can simulate <i>named arguments</i> by accepting a
      <code>Hash</code> as the last parameter. In this scenario, the curly
      braces of the <code>Hash</code> literal can be omitted, which furthers
      the illusion. Lastly, the <i>symbol-key</i> notation <!-- Link --> can
      be employed. This allows a method defined as <code>def m(<var>args</var>)</code> to
      be invoked as <code>m fish: :chips, size: 25</code>; causing
      <var>args</var> to equal <code>{ :fish =&gt; :chips, :size =&gt; 25
        }</code>.
      <p>The <dfn title="method visibility">visibility</dfn> of a method
      determines how it can be invoked. A method may be <dfn title="public
        method">public</dfn>, <dfn title="protected method">protected</dfn>,
      or <dfn title="private method">private</dfn>.
      <p>Methods are private by default if defined at the top-level, i.e.
        outside of a class definition, named <code>#initialize</code>. They
        may not be called with an explicit receiver, so can only be invoked
        from within their class.
      <p>Protected methods can be invoked only from the class in which they
      were defined or a subclass thereof, that is they behave the same as
      private methods. However, unlike private methods they can be explicitly
      invoked on any instance of their class.
      <p>All other methods are public unless specified otherwise.
      <p>The <code>public</code>, <code>protected</code>, and
      <code>private</code> keywords are used to change a method’s visibility.
      They may be followed by a comma-separated list of method names
      (specified as <code>Symbol</code>s), in which case they alter the
      visibility of those named. If they are used without arguments, they set
      the visibility of any method defined subsequently until another
      visibility specifier is seen or the class definition ends. 
      <!-- Method objects? -->
      <!-- aliases -->
    <h2>Enumerables</h2>

    <!-- Mention #to_enum? -->
    <p>Core classes such as <code>Array</code>, <code>Hash</code>, and
    <code>Range</code> mixin the <code>Enumerable</code> module. Any object
    may do the same as long as its class defines an <code>#each</code> method
    which <code>yield</code>s the next element in the collection on every
    invocation.  In return, the class gains a staggering variety of methods
    for working with collections such as the following.

    <p><code>#map {|<var>element</var>| }</code> returns an
    <code>Array</code> created by passing each element of the collection to
    the block, then storing the result. For example, <code>[1,2,3].map{|n|
      n**2} #=&gt; [1,4,9]</code>. <!-- Symbol#to_proc ? -->

    <p><code>#reduce {|<var>element<sub>0</sub></var>,
      <var>element<sub>n</sub></var>| }</code> passes the first two elements
    to the block, then for each subsequent element the last result of the
    block and the element itself. For example: <code>[2,3,5,7].reduce(&amp;:+)
      =&gt; 17</code>.

    <p><code>#select {|<var>element</var>| }</code> returns an
    <code>Array</code> of elements for which the block returned
    <code>true</code>.

    <p>Lastly, <code>#any?</code>, <code>#all?</code>, and <code>#none?</code>
    accept a block which is called with an element of the collection. The
    determinative indicates how many elements of the collection the block must
    return <code>true</code> for the method to return <code>true</code>. For
    instance, <code>#any?</code> returns <code>true</code> as soon as a single
    element in the collection satisfies the block. 
    
    <!-- ruby-core: 25769 (Enumerator#next in JRuby) -->

    <h2>Structs</h2>
      <ol>
        <li>Light-weight classes
        <li>Data-only objects
        <li>Can be extended with methods; how
        <li>Used as superclass for proper class
        <li>Struct vs. OpenStruct
      </ol>
    <h2>Blocks &amp; Closures</h2>
      <ol>
        <li>Literal syntax: <code>{</code>…<code>}</code>,
        <code>do</code>…<code>end</code>
        <li>What a closure is
        <li>Block-local variables
        <li>Can be passed to methods
        <li>Stored in variables (Proc objects)
        <li>Procs vs. lambdas (#lambda?)
        <li>Literal lambda syntax
        <ol>
          <li>Optional parameter list; like method parameters
        </ol>
      </ol>
    <h2>Exceptions</h2>

    <p>An <dfn title=exception>exception</dfn> is an urgent notification of an
    unexpected error <i>raised</i> for the attention of the enclosing block.
    If the exception is ignored, it will continue propagating up the call
    stack until it reaches the top-level, where it will cause the program to
    abort. At any stage of the exception’s passage it may be <i>rescued</i>,
    acknowledging the notification, and preventing the program’s termination.

    <p>An exception is raised with <code>raise <var>exception</var>,
      <var>message</var></code>, where <var>exception</var> is the
    name of a class inheriting from <code>Exception</code> (hereafter: the
    exception class), and <var>message</var> is an optional
    <code>String</code> describing the exception. If <var>exception</var> is
    omitted, a <code>RuntimeError</code> is raised.

    
    <p>Statements expected to raise exceptions may be wrapped in a
    <code>begin…rescue <var>exception</var>…end</code> construct. The
    statements between <code>begin</code> and <code>rescue</code> are
    executed. If they cause an exception of class <var>exception</var>, or a
    child thereof, to be raised, the statements inside the <code>rescue</code>
    block are executed.  Again, <var>exception</var> may be omitted, in which
    case it defaults to <code>StandardError</code>, or a subclass thereof.
    <code>rescue</code> accepts a comma-separated list of exception classes,
    any of which will cause execution of the <code>rescue</code> block.
    <var>exception</var> may be followed by <code> =&gt; <var>var</var></code>
    to capture the <code>Exception</code> object to a local variable named
    <var>var</var>, accessible from the <code>rescue</code> block.

    <p><code>rescue</code> blocks may be followed by other
    <code>rescue</code> blocks, each of which handle a different set of
    exception classes. The first such block that matches the current exception
    will be executed; the others ignored.

    <p><code>rescue</code> may also be used as a postfix statement, whose
    argument is returned if the proceeding expression raises an exception,
    i.e. <code><var>expression</var> rescue <var>value</var></code>. This form
    does not allow the exception class to be specified.

    <p>A custom exception object is created idiomatically with
    <code><var>exception</var> = Class.new(Exception)</code>, where
    <var>exception</var> is a constant naming the new exception class.
      
        <!--<li>Common types:
        <ol>
          <li><code>RuntimeError</code>
          <li><code>ArgumentError</code>
          <li><code>NoMethodError</code>
          <li><code>TypeError</code>
          <li><code>SyntaxError</code>
        </ol>
        <li><code>ensure</code> clause
      </ol>-->
    <h2>Logic &amp; Truth</h2>
      <ol>
        <li><code>false</code> and <code>nil</code> are false
        <li>Everything else is true
        <li>False is represented explicitly as <code>false</code>
        <li>True is represented explicitly as <code>true</code>
        <li><code>nil</code> means…
        <li>Used in conditionals
        <li><code>and</code>, <code>&amp;&amp;</code>
        <li><code>or</code>, <code>||</code>
        <li><code>not</code>, <code>!</code>
        <li>These short-circuit
        <li><code>!!object</code>
      </ol>
    <h2>Conditionals</h2>
    <ol>
      <li>Purpose
      <li>What is a condition
      <li><code>if</code>…<code>end</code>
      <li><code>else</code>…<code>end</code>
      <li><code>elsif</code>…<code>end</code>
      <li><code>unless</code>…<code>end</code>
      <li>…<code>if</code> (postfix form)
      <li>…<code>unless</code> (postfix form)
      <li><code><var>condition</var>? <var>statement<sub>0</sub></var> :
        <var>statement<sub>1</sub></var></code>
    </ol>
    <h2>Loops</h2>
    <ol>
      <li>Why loop
      <li>Explicit subscript loops are rare
      <li><code>loop</code>…<code>end</code>
      <li><code>until(<var>cond</var>)</code>…<code>end</code>
      <li><code>while(<var>cond</var>)</code>…<code>end</code>
      <li><code><var>integer</var>.times do<code>…<code>end</code>
      <li>Iteration with enumerators is more common. (Explain here or own
      section?
    </ol>
    <h2>Classes</h2>
    <ol>
      <li>Definition
      <li>Are constants
      <li>Created with <code>class</code>
      <li>Created with <code>Class.new</code> (<i>because</i> they're objects)
      <li>May have superclass (link to Inheritance)
      <li>Methods (link to Methods)
      <li>Instance variables (link to Variables)
      <li>Attributes
      <ol>
        <li><code>attr</code>
        <li><code>attr_reader</code>
        <li><code>attr_writer</code>
      </ol>
      <li><code>.new</code>
      <ol>
        <li><code>.allocate</code>
        <li><code>#initialize</code>
      </ol>
    </ol>
    <h2>Objects</h2>
    <ol>
      <li>Definition
      <li>Instances of classes
      <li>Created by literals or constructors <!-- .new here or in Classes?
      -->
      <li><code>#is_a?</code> vs. <code>#kind_of?</code>
      <li>Can have methods defined on
      <li><code>#methods</code>
    </ol>
    <h2>Modules</h2>
    <ol>
      <li><code>module</code>
      <li>Namespacing
      <li>Mixins
      <ol>
        <li><code>include</code>
        <li><code>extend</code>
        <li>How instance/class methods are mixed in
        <li><code>#include?</code>
      </ol>
    </ol>
    <h2>Equality</h2>
    <ol>
      <li><code>==</code>
      <li><code>eql?</code>
      <li><code>equal?</code>
      <li>Identity
    </ol>
    <h2>Source Files</h2>
    <ol>
      <li><code>require</code>
      <li><code>load</code>
      <li>Load path
      <li>Encoding: magic comments
      <ol>
        <li><code>__ENCODING__</code>
      </ol>
      <li><code>__FILE__</code>
    </ol>
    <h2>Encoding</h2>
    <ol>
      <li>Source encoding (link: Source Files)
      <li>Default internal
      <li>Default external
    </ol>
    <h2>Gems</h2>
    <ol>
      <li>Loaded with <code>require</code>
      <li>Installed with <code>gem</code>
      <li>Created with <code>jeweler</code>
    </ol>
    <h2>Conversion</h2>
    <ol>
      <li><code>#to_*</code>
      <li>Implicit conversion
      <li>Explicit conversion
      <li>try_convert
      <li><code>#coerce</code>
    </ol>
    <h2>Eval &amp; Exec</h2>
    <h2>Files</h2>
    <ol>
      <li><code>File.open</code> with block
      <li><code>File.read</code>
      <li><code>File.expand_path</code>
      <li><code>File.absolute_path</code>
    </ol>
    <h2>Processes &amp; Commands</h2>
    <ol>
      <li><code>Process.spawn</code>
      <li><code>`</code>…<code>`</code>
    </ol>
    <h2>Inheritance</h2>
    <ol>
      <li>Purpose
      <li>Superclass
      <li>Effect on method lookup
      <li>Inheritance versus mixins
      <li><code>super</code>
    </ol>
    <h2>Threads</h2>
    <h2>Fibers</h2>
    <h2>Variables</h2>

    <p>A variable is a name attached to a specific object reference, valid
    within a certain scope. The scope is determined by the sigil with which
    the variable name is prefixed. The name beings with a lowercase character
    and uses low lines as word separators.

    <p>A dollar sign prefix denotes a global scope. Such <dfn title="global
      variable">global variables</dfn> are available to any part of the
    program. They are rarely used in practice.

    <p>A prefix of two commercial at signs creates a <dfn title="class
      variable">class variable</dfn>, visible
    to all instances of the class in which defined and initialized only once.
    Class variables may be used to share data between instances of a class.
    <!-- warn against? -->

    <p>A single commercial at sign introduces an <dfn title="instance
      variable">instance variable</dfn>, local to a specific instance of a
    class, and initialized anew for each instantiation.

    <p>An unadorned variable is a <dfn title="local variable">local
      variable</dfn>. It is local to the block in which it was defined, and
    remains accessible to any block defined inside of that block, falling out
    of scope when this block ends. <!-- Explain about block local variables?
    -->

    <h2>Constants</h2>

    <p>A constant is an identifier whose name begins with an uppercase ASCII
    character. It is used both to name classes and values which will not
    change for the course of the program. The two uses are distinguished with a
    naming convention: Class names are written in camel-case, a mixture of
    upper- and lowercase; names of constant values are written entirely in
    uppercase.

    <p>Ruby does not prevent the value of a constant being changed, although
    does issue a warning. Freezing <!-- link --> the
    value causes an exception to be raised if it is modified; but does not
    stop another value from being assigned to the constant.

    <h2>Serialization</h2>
    <ol>
      <li>Marshal
      <ol>
        <li>What can't be dumped
        <li>Dumping
        <li>Loading
      </ol>
      <li>YAML
      <ol>
        <li>Plain text: readable
        <li>Editable: good for config files
        <li>Dumping
        <li>Loading
      </ol>
    </ol>
    <h2>Time</h2>
    <h2>Missing Methods</h2>
    <ol>
      <li>When <code>method_missing</code> is called
      <li>Its arguments
      <li>Uses (<i>Dynamic reception</i>)
      <li><code>super</code>
    </ol>
    <h2>Assignment</h2>
    <ol>
      <li>rvalue is an object reference
      <li><code>=</code> isn’t a method
      <li> ||=
      <li>Selectors with <code>=</code> suffix as lvalues
      <li>Parallel assignment
      <li>Splats
      <li>To constants
      <li>Abbreviated assignment
    </ol>
    <h2>Comments</h2>
    <ol>
      <li>#
      <li>=begin…=end
      <li>__END__
    </ol>
    <h2>Operators</h2>
<h2>References</h2>
  <dl>
  <dt id=refBLACK09>[BLACK09]</dt>
  <dd><cite><a href=//www.manning.com/black2/>The Well-Grounded Rubyist</a></cite>, D. A. Black,
  Manning, 2009.</dd>
  <dt id=refBROWN09>[BROWN09]</dt>
  <dd><cite><a href=//rubybestpractices.com/>Ruby Best Practices</a></cite>, G. Brown, O'Reilly Media,
  2009.</dd>
  <dt id=refBRUCE02>[BRUCE02]</dt>
  <dd><cite><a href=//www.cs.pomona.edu/~kim/FOOLbook.html>Foundations of
      Object-Oriented Languages: Types and Semantics</a></cite>, K. B. Bruce,
  The MIT Press, 2002.</dd>
  <dt id=refBUDD87>[BUDD87]</dt>
  <dd><cite>A Little Smalltalk</a></cite>, T. Budd, Addison-Wesley, 1987.</dd>
  <dt id=refFLAN08>[FLAN08]</dt>
  <dd><cite><a href=//oreilly.com/catalog/9780596516178>The Ruby Programming Language</a></cite>, D.
  Flanagan &amp; Y. Matsumoto, O'Reilly Media, 2008.</dd>
  <dt id=refTHOM09>[THOM09]</dt>
  <dd><cite><a href=//books.pragprog.com/titles/ruby3/programming-ruby-1-9>Programming Ruby 1.9: The
      Pragmatic Programmers’ Guide</a></cite>, D. Thomas, et al., The Pragmatic Bookshelf, 2009.</dd>
  <dt id=refLIU99>[LIU99]</dt>
  <dd><cite>Smalltalk, Objects, and Design</cite>, C. Liu, ToExcel, 1999.</dd>
  <dt id=refMEYER00>[MEYER00]</dt>
  <dd><cite>Object-oriented Software Construction, 2<sup>nd</sup> ed.</cite>,
  B. Meyer, Prentice Hall, 2000.</dd>
  <dt id=refMITCHELL04>[MITCHELL04]</dt>
  <dd><cite>Concepts in Programming Languages</cite>, J. C. Mitchell, Cambridge University Press, 2004.</dd>
  <dt id=refKLAS95>[KLAS95]</dt>
  <dd><cite>Metaclasses and Their Application</cite>, W. Klass &amp; M. Schrefl,
  Springer-Verlag Berlin Heidelberg, 1995.</dl>
<body>
</html>

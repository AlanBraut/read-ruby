<!DOCTYPE html>
<meta charset=utf-8>
<title>Closures</title>
<link rel=license href=//creativecommons.org/licenses/by-sa/3.0/>
<link rel=author href=mailto:runrun@runpaint.org>
<link rel=stylesheet href=/style>
<link rel=next href=/references>

<body>
  <section>
    <h1 id=closures>Closures</h1>

    <!--<blockquote cite=/references#refGRAHAM96>
      A closure is a combination of a function and an environment. Closures
      are created implicitly whenever a function refers to something from the
      surrounding lexical environment.
      <cite>ANSI Common Lisp</cite>
    </blockquote> -->

    <p><q cite=/references#refGRAHAM96>A closure is a combination of a
      function and an environment.</q> (<a href=/references#refGRAHAM96
      class=ref>Graham</a>, 1996, pp. 107–109). The function is a parametrised
    block of executable code, and the <q
      cite=/references#refCOTT06>referencing environment</q> (<a
      href=/references#refSCOTT06 class=ref>Scott</a>, 2006, pp. 138–140), or
    <dfn>binding</dfn>, is a
    reference to the lexical environment of the closure’s creation site. The
    binding represents its variables as references, which are de-referenced in
    the environment the closure is called, every time it is called. The figure
    below provides the typical demonstration of this concept:</p>
    
    <figure id=closure-example>
      <dt>A closure encapsulates a block of code and its associated binding
    </figure>

    <p>A closure is an instance of the <code>Proc</code> class, which provides
    methods for calling the closure and accessing its binding. The following
    example shows a closure being called with <code>Proc#[]</code> and an
    argument.</p>

    <figure id=closure-with-argument>
    <dt>A closure may accept arguments from its calling environment
    </figure>

    <section>
      <h1 id=semantics>Semantics</h1>

      <p>A <code>Proc</code> has either <a href=#proc-semantics>proc
        semantics</a> or <a href=#lambda-semantics>lambda semantics</a>. Its
      semantics determine how it handles unexpected arguments and control flow
      statements, such as <code>return</code>, appearing within the body of
      the closure. The differences are summarised in the following table, and
      elaborated below.</p>

      <table id=closures-semantics-table>
        <caption>A comparison of <code>Proc</code> semantics</caption>
        <tr>
          <th></th>
          <th>Lambda
          <th>Proc
        </tr>
        <tr>
          <th>Extra arguments
          <td><a href=#lambda-semantics-arguments>Raise <code>ArgumentError</code></a>
          <td><a href=#proc-semantics-arguments>Ignored</a>
        </tr>
        <tr>
          <th>Omitted arguments
          <td><a href=#lambda-semantics-arguments>Raise <code>ArgumentError</code></a>
          <td><a href=#proc-semantics-arguments>Assigned <code>nil</code></a>
        </tr>
        <tr>
          <th><code>Array</code> arguments
          <td><a href=#lambda-semantics-arguments>Never exploded</a>
          <td><a href=#proc-semantics-arguments>Exploded if necessary</a>
        </tr>
        <tr>
          <th><code>return</code>
          <td><a href=#lambda-semantics-return>Returns from the lambda itself</a>
          <td><a href=#proc-semantics-return>Returns from the creation site
              method</a>
        </tr>
        <tr>
          <th><code>break</code>
          <td><a href=#lambda-semantics-break>Returns from the lambda itself</a>
          <td><a href=#proc-semantics-break>Returns from the call site method</a>
        </tr>
      </table>

      <section>
        <h1 id=lambda-predicate>The <code>#lambda?</code> Predicate</h1>

        <p><code>Proc#lambda?</code> is a predicate which returns
        <code>true</code> if the receiver has lambda semantics;
        <code>false</code> if it has proc semantics.
      </section>
      
      <section>
        <h1 id=proc-semantics>Proc Semantics</h1>
          
        <section>
          <h1 id=proc-semantics-arguments>Argument Passing</h1>
          
          <p>A <code>Proc</code> with proc semantics interprets the
          arguments it receives with <dfn>yield semantics</dfn>:
          according to the same rules as a block invoked with the
          <code>yield</code> statement. This has the following
          implications:</p>

          <ul>
            <li>Superfluous arguments are silently ignored.
            <li>Parameters representing omitted arguments are assigned
            <code>nil</code>.
            <li><code>Array</code> arguments are automatically exploded.
          </ul>
        </section>

        <section>
          <h1 id=proc-semantics-control-flow>Control Flow Statements</h1>

          <section>
            <h1 id=proc-semantics-return><code>return</code></h1>

            <p>Returns from the lexically enclosing method of the
            <code>Proc</code>’s <em>creation</em> site.</p>

            <figure id=proc-semantics-return>
            <dt>Within a <code>Proc</code> with proc
            semantics, <code>return</code> jumps to the <code>Proc</code>
            creation site
            </figure>

            <p>If the <code>Proc</code> was not created within a method,
            e.g. at the top level, or the method has already returned, a
            <code>LocalJumpError</code> is raised.</p>

            <figure id=proc-semantics-return-localjump>
              <dt>A <code>LocalJumpError</code> is raised
              when a <code>Proc</code> with proc semantics tries to
              <code>return</code> without an enclosing method.
            </figure>
          </section>

          <section>
            <h1 id=proc-semantics-break><code>break</code></h1>

            <p>Returns from the lexically enclosing method of the
            <code>Proc</code>’s <em>call</em> site.</p>

            <figure id=proc-semantics-break>
              <dt class=figure-dt>Within a <code>Proc</code> with proc
              semantics, <code>break</code> jumps to the <code>Proc</code>
              call site
            </figure>
            
            <p>A <code>LocalJumpError</code> is raised if
            <code>break</code> is used from a block no longer in scope,
            e.g. at the top-level of a block created with
            <code>Proc.new</code> or <code>proc</code>.</p>

            <figure id=proc-semantics-break-localjump>
              <dt class=figure-dt>A <code>Proc</code> created with
              <code>proc</code> or <code>Proc.new</code> cannot use
              <code>break</code> at the top level
            </figure>
          </section>
        </section>
      </section>

      <section>
        <h1 id=lambda-semantics>Lambda Semantics</h1>
          
        <section>
          <h1 id=lambda-semantics-arguments>Argument Passing</h1>
          
          <p>A <code>Proc</code> with lambda semantics interprets the
          arguments it receives with <dfn>invocation semantics</dfn>:
          according to the same rules as method invocation. This has the
          following implications:</p>

          <ul>
            <li>Superfluous arguments cause an <code>ArgumentError</code> to
            be raised.
            <li>Omitted arguments cause an <code>ArgumentError</code> to be
            raised.
            <li><code>Array</code> arguments are <em>not</em> automatically exploded.
          </ul>
        </section>

        <section>
          <h1 id=lambda-semantics-control-flow>Control Flow Statements</h1>

          <section>
            <h1 id=lambda-semantics-return><code>return</code></h1>

            <p>Returns from the <code>Proc</code> as if it were a method.</p>

            <figure id=lambda-semantics-return>
              <dt>Within a <code>Proc</code> with lambda semantics,
              <code>return</code> returns from the <code>Proc</code> itself
            </figure>
          </section>

          <section>
            <h1 id=lambda-semantics-break><code>break</code></h1>

            <p>Acts exactly like <code>return</code>.</p>

            <figure id=lambda-semantics-break>
              <dt>Within a <code>Proc</code> with lambda semantics,
              <code>break</code> returns from the <code>Proc</code> itself
            </figure>
          </section>
        </section>

        <section>
          <h1 id=control-flow>Control Flow</h1>

          <p>Control flow statements other than <code>break</code> or
          <code>return</code> operate in the same way for both kinds of
          <code>Proc</code>s.</p>

          <dl>
            <dt><code>next</code>
            <dd>Returns its arguments to the <code>yield</code> statement or method that
            invoked the <code>Proc</code>.
            <dt><code>redo</code>
            <dd>Jump to the beginning of the <code>Proc</code>
            <dt><code>retry</code>
            <dd>Always raises a <code>LocalJumpError</code>
            <dt><code>raise</code>
            <dd>Propagates the exception up the call stack: through any
            enclosing block, then to the invoking method.
          </dl>
        </section>
    </section>

    <section>
      <h1 id=creation>Creation</h1>
      
      <section>
        <h1 id=proc-new><code>Proc.new</code></h1>

        <p><code>Proc.new</code> creates a <code>Proc</code> with proc
        semantics from the given block.</p>

        <aside>
          <h1 id=creation-with-implicit-block>Implicit Block</h1>
          
          <p>If the block is omitted, the block with which the lexically
          enclosing method was invoked is used in its place. If the method was
          not invoked with a block, or there is not an enclosing method, an
          <code>ArgumentError</code> is raised.
        </aside>
      </section>

      <section>
        <h1 id=proc-keyword><code>proc</code> keyword</h1>

        <p>The <code>proc</code> keyword is a synonym for <a
          href=#proc-new><code>Proc.new</code></a>: it creates a
        <code>Proc</code> with proc semantics from the given block. Without a
        block argument an <a href=#creation-with-implicit-block>implicit
          block</a> is assumed.
      </section>

      <section>
        <h1 id=ampersand-prefixed-parameter>&<var>parameter</code></h1>

        <p>A method or lambda whose parameter list includes an identifier
        prefixed with an ampersand, assigns to the parameter a
        <code>Proc</code> with proc semantics representing the block literal
        that the method/lambda was sent. For more details, see <a
          href=/methods#block-arguments>Methods: Block Arguments</a>, which
        includes an <a
          href=/methods#method-using-block-arguments>example</a>.
      </section>

      <section>
        <h1 id=lambda-keyword><code>lambda</code> keyword</h1>

        <p>The <code>lambda</code> keyword creates a <code>Proc</code> with
        lambda semantics from the given block. Without a
        block argument an <a href=#creation-with-implicit-block>implicit
          block</a> is assumed.</p>

        <figure id=lambda-keyword-examples>
          <dt><code>lambda</code> takes a block with which it creates a
          <code>Proc</code> with lambda characteristics
        </figure>
      </section>

      <section>
        <h1 id=lambda-literal>Lambda Literal (<code>->(){}</code>)</h1>

        <p>The expression <code>-&gt;{<var>block</var>}</code> creates a
        <code>Proc</code> with lambda semantics for the given <var>block</var>
        which expects no arguments. The block may be preceded by a
        parenthetical parameter list, i.e.
        <code>-&gt;(<var>arg</var><sub>0</sub>…<var>arg</var><sub>n</sub>){
          <var>block</var> }</code>, in which case the resulting lambda
        expects to receive the corresponding arguments.</p>
        
        <figure id=lambda-literal-syntax>
          <dt><code>-&gt;(){}</code> creates a <code>Proc</code> with lambda
          characteristics
        </figure>
      </section>
    </section>

    <section>
      <h1 id=calling>Calling</h1>

      <p>A <code>Proc</code> can be invoked in the following ways:</p>
      
      <dl>
        <dt><code>Proc#call(<var>arg</var><sub>0</sub>,…,<var>arg</var><sub>n</sub>)</code>
        <dd>Also invoked with the syntax below.
        <dt><code><var>proc</var>.(<var>arg</var><sub>0</sub>,…,<var>arg</var><sub>n</sub>)</code>
        <dd>A syntactical shortcut for <code>Proc#call</code>. The
        parentheses are mandatory, even if there are no arguments.
        <dt><code>Proc#yield(<var>arg</var><sub>0</sub>,…,<var>arg</var><sub>n</sub>)</code>
        <dd>An instance method with the selector <code>:yield</code>;
        distinct from the <code>yield</code> keyword.
        <dt><code>Proc#[<var>arg</var><sub>0</sub>,…,<var>arg</var><sub>n</sub>]</code>
        <dd>The square brackets are mandatory, even if there are no arguments.
        <dt><code>Proc#=== <var>arg</var></code>
        <dd>Allows <code>Proc</code>s to be used in
        <code>case</code> expressions. It requires exactly one argument, so is
        unsuitable for a <code>Proc</code> with <a
          href=#lambda-semantics>lambda semantics</a> that have arities other than 1.
      </dl>
      
      <figure id=proc-calling>
        <dt>Syntax for invoking a <code>Proc</code>
      </figure>
    </section>

    <section>
      <h1 id=parameters>Parameters</h1>

      <p>A <code>Proc</code> may be defined with a parameter list, which
      describes the arguments it accepts. The syntax of the parameter list
      content mostly mirrors that of <a href=/methods#method-arguments>method
        parameter lists</a>, with the following differences:</p>

      <ul>
        <li>It is enclosed within a pair vertical lines (<code>|</code>),
        rather than parentheses, which are mandatory if a parameter list is
        specified.
        <li>It is specified as the first element of the block associated with
        the <code>Proc</code>: after the opening curly bracket or the
        <code>do</code> keyword.
        <li>If the <a href=#lambda-literal>lambda literal</a> syntax is used,
        the vertical lines must be omitted and the parameter list must be
        specified within the parentheses following <code>-&gt;</code> à la
        method parameter lists; <em>not</em> in the block.
      </ul>

      <figure id=proc-parameters>
        <dt>The parameter list for a <code>Proc</code> is enclosed within vertical
        lines
      </figure>

      <section>
        <h1 id=block-local-variables>Block-Local Variables</h1>

        <p>A closure may define <dfn>block-local variables</dfn>: local
        variables which are distinct from those with the same name in an outer
        lexical scope.</p>

        <p>Block-local variables are defined in the parameter list after the
        non-block-local parameters, and before the closing vertical line. They
        are specified as a comma-separated list of identifiers, with a
        semicolon preceding the first:
        <code>|<var>param</var><sub>0</sub>,…,<var>param</var><sub>n</sub>;<var>block-local</var><sub>0</sub>,…,<var>block-local</var><sub>n</sub>|</code>.
        The semicolon is mandatory, even if the list of block-local variables
        is not preceded by any regular parameters.</p>

        <p>In the case of <a href=#lambda-literal>lambda literals</a>,
        block-local variables are specified in the same manner before the
        closing parentheses of the parameter list, i.e.
        <code>-&gt;(<var>param</var><sub>0</sub>,…,<var>param</var><sub>n</sub>;<var>block-local</var><sub>0</sub>,…,<var>block-local</var><sub>n</sub>){}</code>.</p>

        <figure id=block-local-variables-syntax>
          <dt>Block-local variables are specified after regular parameters and
          preceded by a semicolon
        </figure>
        
        <p>If a variable <var>v</var> is defined block-local:
          <ol>
            <li>If <var>v</var> was defined in an outer scope, its value is saved.
            <li>Within the block <var>v</var> is assigned <code>nil</code>,
            then behaves as any other local variable.
            <li>Upon leaving the block, <var>v</var> is assigned the value it
            had originally in the outer scope.
          </ol>
        </p>


        <figure id=block-local-variables-example>
          <dt>Block-local variables are are distinct from those with the same
          name in an outer lexical scope
        </figure>

        <p>By contrast, if <var>v</var> is not defined as block-local, it
        retains the value it was assigned inside the block, even after leaving
        the block scope. However, defining a variable, <var>w</var>, inside
        the block which did not exist in the outer scope, does not define it
        in the outer scope. In both examples, <var>w</var> is undefined upon
        leaving the block.</p>

        <figure id=non-block-local-variables-example>
          <dt>Non-block-local variables defined prior to the block retain the
          value they were assigned inside the block even after leaving it
        </figure>
      </section>  
    </section>
  </section>
</body>

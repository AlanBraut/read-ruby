<h1>The Communication of Objects in Ruby</h1>
<h2>Fundamentals</h2>
<p>Ruby holds as fundamental that every value is an object: an entity with
state, behaviour, and identity. Objects communicate with each other through
message passing. 

Smith and Tockey, suggest that “an object represents an individual, identifiable item, unit, or entity, either real or abstract, with a well-defined role in the problem domain” [4].

<ol>
  <li>Ruby holds as fundamental that every value is an object. (Blatantly
  untrue that "everything" is an object: variables and keywords aren't).
  <li>An object is an entity that has state, behaviour, and identity. 
  <li>The structure and behaviour of similar objects are defined in their common class. 
  <li>Objects communicate by sending and receiving messages
  <li>The receipt of a message implies a response
  <li>Messages may alter state and/or enact behaviour, but cannot affect identity
  qua identity ("This convenience is afforded by SELF’s uniform use of
  messages to access both state and behavior,").
  <li>A recipient of a message attempts to invoke a method whose name
  corresponds with the message selector
  <li>A recipient of a message may delegate it to another object/class
  <li>Variables store references to objects (Implies pass by reference?)
  <li>An object's class cannot be changed
  <li>Messages are not analogous to methods:
  <ol>
    <li>A message has meaning outside of a class' context
    <li>method_missing means one method may respond to a variety of messages
    (plus parent's method_missing?)
    <li>Very late binding means the caller does not, and cannot, assume a
    message send implies a method invocation
    <li>Metaclasses.pdf defines _message_ as "A request for an object to carry
    out one of its methods."
  </ol>
</ol>

<h2>Objects</h2>

  <h3>Identity</h3>
  <ol>
    <li><code>Object#object_id</code>
    <li><code>Object#hash</code>
    <li>Distinct from equality (#eql? vs. ==)
    <li>Distinct from name (better term?)
    <li>In terms of class
    <li>Implications regarding use as Hash keys
    <li>Identity Hashes
    <li>clone and dup
  </ol>

  <h3>State</h3>

  <h3>Behaviour</h3>

  <h3>Instantiation</h3>  

  <h3>Equality</h3>
  <ol>
    <li><code>==</code> vs. <code>===</code>
    <li>The essence of equality: equivalence
    <li>Implementing with <code>Object#==</code>
    <li><code>!=</code> need not imply <code>not ==</code>
    <li>Assignment is not equality
  </ol>
  
<h2>Communication</h2>
<!-- Too broad? -->
<ol>
  <li>Via message passing
  <li>Methods versus messages
  <li><code>#respond_to?</code>
  <li>Sending messages: <code>.</code> and <code>Object#send</code>
  <li>Naming conventions for messages: <code>?</code>, <code>!</code>,
  <code>=</code>
  <li>Argument passing: parentheses, '&amp;', '*', blocks, named arguments
</ol>

<h2>Vocabulary</h2>
<!-- TODO: Discuss def here? -->
<ol>
  <li>An object's vocabulary is the set of messages it understands
  <li><code>Object#methods</code>, and friends, enumerates a subset of this
  vocabulary
  <li>The difference between <code>#respond_to?</code> and
  <li><code>Method</code> objects and RDoc provide a dictionary of sorts,
  metadata
  <code>methods.include?</code>.
</ol>

<h2>Understanding</h2> / <h2>Comprehension</h2>
<ol>
  <li>A message is only understood in context
  <li>The object's state and the message's arguments provide this context
  <li>IOW, that an object responds_to a message doesn't imply it understands
  it in the same way the caller intends.
  <li><code>Method#arity</code> and the raising of
  <code>TypeError</code>/<code>ArgumentError</code> help in this regard
  <li><code>NoMethodError</code> indicates that the message per se isn't
  understood.
</ol>

<h2>Messages</h2>

<p>A message is a "request for an object to perform some operation" (Budd, p
6). It consists of "...a receiving object (the receiver), the message selector
(which indicates which method to execute) and zero or more parameters." (Hunt,
1997, p 73). We will use these definitions with the slight modification that
<i>arguments</i> will be substitued for <i>paramaters</i>, for reasons
explained later.

<p>A message selector <var>s</var> is typically <i>sent</i> to a receiver
<var>r</var> with arguments
<var>a<sub>0</sub></var>...<var>a<sub>n</sub></var> with the dot operator:
<code><var>r</var>.<var>s</var>(<var>a<sub>0</sub></var>,...,<var>a<sub>n</sub></var>)</code>.

<h3>The Distinction Between Messages and Methods</h3>

<p>A message selector often corresponds to the name of a method in the
receiver. That is, sending the message <var>s</var> to receiver <var>r</var>
is equivalent to invoking the method <var>s</var> on <var>r</var>. Indeed,
Flanagan &amp; Matsumoto (p 178) claim that "...methods are called
“messages”". However, this analogy is problematic for the following reasons:

<p>In the definitions of Budd (A Little Smalltalk, 1987, p 6), Hunt (Smalltalk
and Object Orientation: An Introduction, 1997, p 73), Mitchell (Concepts in
Programming Languages, 2004, p 279), and Klas &amp; Schrefl (Metaclasses and
Their Application, 1995, p 13) <i>message</i> refers to the <i>request</i>
being made of an object; whereas Flanagan &amp; Matsumoto use it to refer the
means with which the receiver would respond to such a request. We prefer what
Mitchell terms "Smalltalk terminology" because it is well established in the
literature, and the basis for Ruby's misappropriation.

<p>Further, there is not necessarily a one-to-one correspondence between
message selector and method name. If the named method does not exist, the
receiver may respond by sending itself a <code>method_missing</code> message,
which would contradict this simplistic assertion, but still fulfil the
"request" the message represented.

<p>The proper relation of <i>message</i> to <i>method</i> can be understood by
Budd's use of the term "operation": a method must perform the requested
operation, invoking whatever method is most appropriate to do so.

<p>Defining messages in terms of operations also provides the framework for
our discussion of "duck typing" later in this chapter.

<h3>Receivers</h3>

<p>Every message is sent to a receiver object.  

<h4>Implicit Receivers</h4>

<p>If a receiver is not specified an <i>implicit receiver</i> of
<code>self</code> is assumed. <code>self</code> is always defined and refers
to the current object. Outside of any class definition, i.e. at the top-level,
the current object is an instance of <code>Object</code>. Inside a class
definition, but outside of a method definition, the current object is an
instance of <code>Class</code>. Within a method definition the current object
is the instance of the containing class.

<p>There are three situations where the implicit reciever can not be used:

<ol>
  <li>The message is also a keyword such as <code>class</code>
  <li>The message is used as an lvalue.
  <li>The message name is identical to a local variable. There are other ways
  to disambiguate this case.
</ol>

<p>By contrast, the implicit receiver must be used when the message is
private.

<h4>Explicit Receivers</h4>

<p>An explicit receiver is an expression that evaluates to an object. It
cannot be used when the message is private.

<h3>Message Selectors</h3>

<p>The message selector is the name of the operation the receiver should
perform. It is unique to a given object.

<p>The selector is assumed to be the name of a method defined upon the
receiver. If a corresponding method is not found in the receiver or its
parents, the receiver is sent a <code>method_missing</code> message, whose
arguments are the original message selector and its arguments.

<p>A message selector may consist of any <code>Symbol</code>, even those which
are illegal when defining a method with the <code>def</code> keyword. Methods
with corresponding names can be defined with
<code>Object#define_method</code>, or such messages can be handled by
<code>method_missing</code>







[["In Smalltalk terminology, a message consists of an operation name and set of additional
arguments. When a message is sent to an object, the object responds to the
message by executing a function called a method. Dynamic lookup means that a
method is selected dynamically, at run time according to the implementation of
the object that receives a message. The important property of dynamic lookup
is that different objects may implement the same operation differently."]]
(Mitchell, Concepts in Programming Languages, 2004, p 279).




Klas and Schrefl (1995, p 13) concur, stressing that the disparity between the
two terms, by defining <i>message</i> as "A request for an object to carry out
one of its methods."

<p>Budd (pp 6) states that "A message is a request for an object to perform
some operation, and it can contain certain argument values to be used in
conjunction with the execution of the requested operation." 

Hunt (1997,
p 73) elaborates : "Message expressions describe messages to
receivers. They are composed of a receiving object (the receiver), the message
selector (which indicates which method to execute) and zero or more
parameters." 


<p>"In pure object-oriented languages such as Smalltalk, we speak of one
object passing a message to another. Generally, a message is simply an
operation that one object performs on another, although the underlying
dispatch mechanisms are different. For our purposes, the terms operation and
message are interchangeable. Message passing is one part of the equation that
defines the behavior of an object; our definition for behavior also notes that
the state of an object affects its behavior as well." (Booch et al., 2007, p
81).

<p>"A message consists of an addressee, a method selector, and possibly
several actual parameters. In response to a message, the receiver invokes the
method identified by the selector specified within the message." (p 10, Klas
and Schrefl, 1995)

<p>"When a message is sent to an object, the corresponding method of the
object is executed". (p 17, Foundations of OO Languages, Bruce, 2002).

<h2>Methods</h2>
<h2>Classes</h2>
<h2>Modules</h2>

Form:
'.' - Call method
Initial capital - constant, class
Lowercase - variable
...

Principles:
To convert an object to another use its #to_* method
To instantiate an object use its .new method

<h2>Truth</h2>
<ol>
  <li>Anything non-false is true. 
  <li><code>false</code> is false
  <li><code>nil</code> is false
  <li>Implications (0, '', and [] are true)
  <li><code>!!</code> returns the truthfulness of an expression
  <li>Primarily used in conditionals
</ol>


<h2>Repetition</h2>
<ol>
  <li>Why repeat yourself?
  <li><code>loop</code>ing forever (<code>break</code>/<code>return</code>)
  <li><code>#upto</code>/<code>#downto</code> for a fixed number of
  repetitions
  <li>Distinct from iteration, unlike other languages
</ol>

<h2>Choice</h2>
<ol>
  <li>Conditionals: comparison, <code>Enumerable#any?</code>, etc.
  <li><code>if</code> for simple branches
  <li><code>unless</code> to simplify negative conditionals
  <li>Post-(proper name?)-<code>if</code>/<code>unless</code>.
  <li><code>else</code>: expressing a default action
  <li>Ternary expression to express simple either-or choice on a single line
  <li>Multiple choices with <code>elsif</code>
  <li>Choosing between multiple consecutive <code>if</code>s and
  <code>if..elsif</code>.
  <li><code>case</code>: <code>===</code>
  <li><code>if</code> versus <code>case</code>
</ol>

<h2>Unforseen</h2>
<ol>
  <li>What an Exception is
  <li>Exceptions must inherit from <code>Exception</code>
  <li>When to use exceptions
  <li>The meaning and use of <code>raise</code>
  <li>Pessimism: expecting the exceptional with <code>rescue</code>
  <li>What exceptions to rescue?
</ol>

<h2>Multiplicity</h2>
<!-- Too broad? -->
<ol>
  <li>Arrays for storing ordered collection of objects
  <li>Elements need not be homogeneous (<i>scalable</i> in mathematics jargon)
  <li>Creation with <code>[]</code> literal
  <li>Creation by multiplcation
  <li>Communication en-masse with <code>Enumerable#map</code> and
  <code>Symbol#to_proc</code>. Wholesale transformation.
  <li>Querying with <code>Enumerable#any?</code> et al.
  <li>Reduction with <code>Enumerable#reduce</code>
  <li>Abstracting Arrays to Enumerables
</ol>

<h2>Lineage</h2>
<ol>
  <li>Inheritance: '&lt;'.
  <li>Conceding control to one's parents. Expansion of vocabulary.
  <li>Mixins (mongrel objects): learning traits
</ol>

<h4>Logic</h4>
<ol>
  <li>Short-circuiting decisions
  <li><code>not</code> / <code>!</code>
  <li><code>or</code> / <code>||</code>
  <li><code>and</code> / <code>&amp;&amp;</code>
</ol>

<h4>Transformation</h4>
<ol>
  <li>Instructing an object to represent itself as a member of another class
  <li>Using (to_*) methods for transformation to core classes
  <li>Implicit transformation, e.g. #to_path, #to_s
  <li>Explicit transformation, i.e. to_str vs. to_s.
  <li>Numerics as a special case: #coerce,
  <li>A more general approach: asking the target object to transform the
  source object: .try_convert. <!-- Fix terminology -->
</ol>

Similarity (regexps)
Creation/Reproduction (better title)

<h2>Associations</h2>
<ol>
  <li>As a dictionary
  <li>Name describes the type of association
  <li>Hashes
  <li>The association between one object and another
  <li>Keys are unique, but Arrays can be used
  <li>Abstract associations with default procs
</ol>

<h2>Action</h2> / <h2>Behaviour</h2>

<h2>Privacy</h2>
<ol>
  <li>Its advisory
  <li>private, protected, public
  <li>Subverting with <code>Object#send</code>
</ol>

<h2>Order</h2>
<ol>
  <li>Sorting
</ol>

<h2>Class</h2>
<ol>
  <li>Is not a <i>type</i>
  <li>Pre-destination, caste system: objects will always behave like their class
  <li>An object's class cannot be changed
  <li><code>#is_a?</code>: Wrong kind of discrimination; we prefer to judge an
  object on its abilities: <code>respond_to?</code>.
  <li>Aristotelian "classical" concept
</ol>

<h2>Individualism</h2>
<ol>
  <li>An object can behave differently to its class
  <li>Singleton methods
  <li><code>Object#extend</code>
  <li>An object can be cloned then the clone specialised in these ways. A more
  precise form of inheritance?
</ol>

<h2>Accountability</h2>
<ol>
  <li><code>Module#inherited</code>: Determining who my children are
  <li><code>Kernel#set_trace_func</code>: Tracking who called what
  <li>Other hook methods
</ol>

<h2>Responsibility</h2>
<ol>
  <li><code>super</code> for delegating upwards
  <li>Inheritance as pushing responsibility downwards
  <li><code>method_missing</code> allows decision to be made dynamically, at
  run-time
  <li>Abstract method that raises exception if not overridden: forcing your
  children to be responsible
  <li>Delegating with <code>delegator.rb</code>
</ol>

<h2>Epistemology</h2>
<h2>Categorization</h2>
<ol>
  <li>Aristotelian "classical" concept
</ol>

Certainty (testing)
Permanence (serialization, files,...)
Composability?
"An intrinsic property is a property that an object or a thing has of itself,
independently of other things, including its context. An extrinsic (or
relational) property is a property that depends on a thing's relationship with
other things. "

"In the context of Social Science to be Interpellated is to identify with a
particular idea or identity. For example, if someone were to shout your name
at you in the street, you would recognize that salutation to mean yourself. It
is basically thinking 'that means me'. It is the process by which you
recognise yourself to belong to a particular identity."

Sortal
Unity

<!DOCTYPE html>
<meta charset=utf-8>
<title>Flow - Read Ruby</title>
<link rel=license href=//creativecommons.org/licenses/by-sa/3.0/>
<link rel=author href=mailto:runrun@runpaint.org>
<link rel=stylesheet href=style>
<link rel=next href=/references>

<!-- http://www.engineyard.com/blog/2010/iteration-shouldnt-spin-your-wheels/
-->
<section>
  <h1 id=flow>Flow</h1>
  
  <section>
    <h1 id=conditionals>Conditionals</h1>

    <p>A <dfn>conditional</dfn> is an expression evaluated as a truthbearer.
    The conditional is <dfn title="false conditional">false</dfn> if the
    expression’s value is <code>nil</code> or <code>false</code>; otherwise it
    is <dfn title="true conditional">true</dfn>.</p>

    <figure id=conditional-true.rb>
      <!-- FIXME: Use if statement in example to show the conditionals’ truth
      -->
      <figcaption>Conditionals that are true
    </figure>

    <figure id=conditional-false.rb>
      <!-- FIXME: Use unless statement in example to show the conditionals’
      falsity -->
      <figcaption>Conditionals that are false
    </figure>
  </section>

  <section>
    <h1 id=branching>Branching</h1>
    
    <p><dfn>Branching statements</dfn> predicate the execution of block on a
    conditional. For example, an <code>if</code> statement executes its
    associated code block iff its conditional is true. Each code block of an
    branching statement is termed a <dfn>branch</dfn>, to describe the effect
    of the statement on program execution.</p>

    <section>
      <h1 id=if-statement>The <code>if</code> Statement</h1>
      
      <figure class=railroad>
        <img id=if-statement.png>
        <figcaption>Syntax diagram of <code>if</code> statement
      </figure>

      <p>The <code>if</code> statement comprises a conditional, zero or more
      statements (the branch), then, optionally, additional branches whose
      forms are explained subsequently. The branch is executed iff the
      conditional is true.</p>

      <figure id=if-statement-simple.rb>
        <figcaption>The simple form of the <code>if</code> statement
      </figure>

      <p>The return value of an <code>if</code> statement is that of the
      executed branch, or <code>nil</code> if no branch was executed.</p>

      <section>
        <h1 id=postfix-if>Postfix <code>if</code></h1>

        <figure class=railroad>
          <img id=postfix-if-statement.png>
          <figcaption>Syntax diagram of the postfix <code>if</code> statement
        </figure>

        <p>A postfix <code>if</code> statement is a concise alternative when
        the branch consists of a sole statement. It comprises an
        expression, the <code>if</code> keyword, then a conditional. The
        expression is executed iff the conditional is true.</p>
        
        <figure id=postfix-if-statement.rb>
          <figcaption>The postfix <code>if</code> statement executes its
          left-hand side if its right-hand side is true
        </figure>

        <p>This syntax, as opposed to <code>if <var>conditional</var>…</code>,
        foregrounds the expression. This is of stylistic benefit if the
        conditional is normally true because it highlights the default
        case.</p>
      </section>

      <section>
        <h1 id=if-else-clause>The <code>else</code> Clause</h1>

        <figure class=railroad>
          <img id=else-clause.png>
          <img id=if-statement.png>
          <figcaption>Syntax diagram of <code>if</code> statement with an
          <code>else</code> branch
        </figure>

        <p>Prior to an <code>if</code> statement’s <code>end</code> keyword an
        <code>else</code> branch may appear. It is executed iff no preceding
        branch was executed, serving as the default branch.</p>

        <figure id=if-statement-with-else-clause.rb>
          <figcaption>An <code>if</code> statement can contain an
          <code>else</code> clause, which is executed iff no other branch was
          executed.
        </figure>
      </section>

      <section>
        <h1 id=if-elsif-clause>The <code>elsif</code> Clause</h1>

        <figure class=railroad>
          <img id=elsif-clause.png>
          <img id=if-statement.png>
          <figcaption>Syntax diagram of <code>if</code> statement with an
          <code>elsif</code> branch
        </figure>

        <p>An <code>if</code> statement may contain any number of
        <code>elsif</code> branches between the <code>if</code> branch and
        before the <code>else</code> branch, if present. To execute they
        require all prior conditionals to be false and their conditional to be
        true.</p>

        <figure id=if-statement-with-elsif-and-else-clause.rb>
          <figcaption>Using an <code>if</code> statement with
          <code>elsif</code> and <code>else</code> branches to compute the
          Möbius function
        </figure>
      </section>
    </section>


    <section>
      <h1 id=unless-statement>The <code>unless</code> Statement</h1>

      <figure class=railroad>
        <img id=else-clause.png>
        <img id=unless-statement.png>
        <figcaption>Syntax diagram of <code>unless</code> statement
      </figure>

      <p>The <code>unless</code> statement executes its branch iff its
      conditional is false. It is equivalent to an <code>if</code> statement
      with the conditional inverted. It may be followed by an
      <code>else</code> branch, which executes iff the <code>unless</code>
      conditional is true.  <code>elsif</code> clauses are prohibited.</p>

      <figure id=unless-statement-fig.rb>
        <figcaption>The <code>unless</code> statement executes its body iff
        its conditional is false.
      </figure>

      <section>
        <h1 id=postfix-unless-statement>Postfix Form</h1>
        
        <figure class=railroad>
          <img id=postfix-unless-statement.png>
          <figcaption>Syntax diagram of the postfix <code>unless</code>
          statement
        </figure>

        <p>The postfix form of the <code>unless</code> statement behaves as
        the postfix <code>if</code> statement, except the expression is
        executed iff the conditional is false.</p>

        <figure id=postfix-unless-statement-fig.rb>
          <figcaption>Using the postfix-<code>unless</code> statement to
          <code>raise</code> an <code>ArgumentError</code> if the argument
          can’t be converted to a <code>String</code>
        </figure>
      </section>
    </section>
  </section>

  <section>
    <h1 id=boolean-logic>Boolean Logic</h1>
    
    <p>The Boolean logic operators return either <code>true</code> or
    <code>false</code> by evaluating their operands as conditionals. For this
    reason, Boolean expressions are often themselves used as conditionals.

    <p>There are two forms of each Boolean operator—keyword (e.g.
    <code>and</code>) and  punctuation (e.g. <code>&amp;&amp;</code>)—which
    differ only in precedence. The former have low precedence; the latter
    high.</p>

    <section>
      <h1 id=and-operator>The AND Operator</h1>
      
      <figure class=railroad>
        <img id=boolean-and-operator.png>
        <figcaption>Syntax diagram of the Boolean AND operator
      </figure>

      <p>The binary <code>and</code>/<code>&amp;&amp;</code> operators return
      <code>true</code> iff both operands are true. They perform short-circuit
      evaluation, so will only evaluate the second operand if the first is
      true.</p>

      <figure id=and-operator-fig.rb>
        <figcaption>Using the Boolean AND operator (<code>&amp;&amp;</code>)
        and the bitwise AND operator (<code>&amp;</code>) to determine whether
        an integer is a power of 2
      </figure>
    </section>

    <section>
      <h1 id=or-operator>The OR Operator</h1>

      <figure class=railroad>
        <img id=boolean-or-operator.png>
        <figcaption>Syntax diagram of the Boolean OR operator
      </figure>

      <p>The binary <code>or</code>/<code>||</code> operators return
      <code>true</code> iff at least one operand is true. They perform
      short-circuit evaluation, so will only evaluate the second operand if
      the first is false.</p>

      <figure id=or-operator-fig.rb>
        <figcaption>Using the Boolean OR operator to determine whether the
        check digit of an ISBN-13 is correct
      </figure>
    </section>

    <section>
      <h1 id=not-operator>The NOT Operator</h1>

      <figure class=railroad>
        <img id=boolean-not-operator.png>
        <figcaption>Syntax diagram of the Boolean NOT operator
      </figure>

      <p>The unary <code>not</code>/<code>!</code> operators return
      <code>true</code> iff the operand is false.</p>

      <figure id=not-operator-fig.rb>
        <figcaption>Using the Boolean NOT operator to invert the value of its
        operand
      </figure>
    </section>

    <section>
      <h1 id=ternary-operator>The Ternary Operator</h1>

      <figure class=railroad>
        <img id=ternary-operator.png>
        <figcaption>Syntax diagram of the ternary operator
      </figure>

      <p>The ternary operator is a concise alternative to <code>if
        <var>conditional</var>…else…</code> when the conditional and branches
      are simple. It consists of three operands, the first of which is the
      conditional. If the conditional is true, the second expression is
      evaluated; otherwise the third expression is evaluated.</p>

      <figure id=ternary-operator-on-single-line.rb>
        <figcaption>The ternary operator is a compact two-way branching
        construct 
      </figure>
    </section>

    <section>
      <h1 id=case-statement>The <code>case</code> Statement</h1>

      <figure class=railroad>
        <img id=case-statement-syntax.png>
        <figcaption>Syntax diagram of the <code>case</code> statement
      </figure>

      <p>The <code>case</code> statement allows a single expression
      (hereafter: the <dfn title="topic of a case statment">topic</dfn>) to be
      tested against other expressions without having to evaluate the
      topic each time. It begins with a <code>case
        <var>topic</var></code> clause, where <var>topic</var> is an arbitrary
      expression.</p>

      <figure class=railroad>
        <img id=when-clause.png>
        <figcaption>Syntax diagram of the <code>case</code> statement’s
        <code>when</code> clause  
      </figure>
      
      <p>A branch is introduced by the <code>when</code> keyword followed by a
      comma-separated list of one or more expressions. This list is separated
      from the statements comprising the branch body by the <code>then</code>
      keyword or a statement terminator.</p>

      <figure class=railroad>
        <img id=else-clause.png>
        <figcaption>Syntax diagram of the <code>case</code> statement’s
        <code>else</code> clause  
      </figure>
      
      <p>A single <code>else</code> clause may appear between the final
      <code>when</code> clause and the <code>end</code> keyword which delimits
      the <code>case</code> statement.</p>
      
      <figure id=case-cf-if.rb>
        <figcaption>The same method implemented first with an <code>if</code>
        statement then with a <code>case</code> statement
      </figure>

      <p>A <code>when</code> clause <dfn title="matching <code>when</code>
        clause">matches</dfn> the topic if any of the expressions listed after
      <code>when</code> have case equality (<code><var>expression</var> ==
        <var>topic</var></code>) with the topic. Therefore, <code>when
        <var>expression</var></code> is equivalent to <code>if
        <var>expression</var> === <var>topic</var></code>. By default, the
      <code>#===</code> message is equivalent to <code>#==</code>—they both
      test for equality—but certain core classes redefine <code>#===</code> to
      behave more usefully in this context, as shown in the following
      table.</p>

      <figure id=case-equality-operator-table>
        <table>
          <tr><th>Class (<var>a</var>)
              <th>Semantics of <code><var>a</var> === <var>b</var></code>
          <tr><td><code>Class</code>
              <td><code><var>b</var>.instance_of?(<var>a</var>)</code>
          <tr><td><code>Proc</code>
              <td><code><var>a</var>.call(<var>b</var>)</code>
          <tr><td><code>Range</code>
              <td><code><var>a</var>.include?(<var>b</var>)</code>
          <tr><td><code>Regexp</code>
              <td><code><var>a</var> =~ <var>b</var></code>
          <tr><td><code>Symbol</code>
              <td><code><var>a</var> == <var>b</var>.to_sym</code>
          </table>
        <figcaption>The effect of the case equality operator on a receiver of
        class <var>a</var> and a single operand (<var>b</var>)
      </figure>

      <p>A <code>case</code> expression is evaluated by evaluating each
      <code>when</code> branch in the order that they appear in the source
      file. If a branch matches the topic, it is executed, and its return
      value becomes that of the <code>case</code> statement; otherwise, the
      next branch is evaluated in the same manner. If none of the
      <code>when</code> branches match, and an <code>else</code> branch is
      present, the <code>case</code> statement’s return value is that of the
      <code>else</code> branch; otherwise it is <code>nil</code>.</p>

      <figure id=case-statement-fig.rb>
        <figcaption>Using the <code>case</code> statement to classify a HTTP
        status code
      </figure>
    </section>
  </section>

  <section>
    <h1 id=looping>Looping</h1>
    
    <p>Looping constructs represent repetition. They comprise a block of code
    (hereafter: the <dfn title="loop body">body</dfn>) and a <dfn>terminating
      condition</dfn> which governs the number of times the body will
    execute.</p>

    <p>The following constructs are materially identical in that they can all
    be used to create any kind of loop, albeit when combined with control flow
    statements. The purpose of having many different approaches to looping, as
    opposed to a single, generic construct, is to allow common scenarios to be
    expressed concisely and simply, and in doing so lessen the chance of
    erroneous terminating conditions.</p>
    <section>
      <h1 id=count-controlled-loops>Count-Controlled Loops</h1>

      <p>The constructs that follow instrument an <i>a priori</i> number of
      repetitions.</p>

      <!-- for loops are unnecessary -->
      
      <section>
        <h1 id=integer-times><code>Integer#times</code></h1>

        <figure class=railroad>
          <img id=integer-times.png>
          <figcaption>Syntax diagram of the <code>Integer#times</code> loop
        </figure>

        <p><code>Integer#times</code> creates a loop which executes
        <var>n</var> times, where <var>n</var> is the integer’s magnitude. For
        example, <code>10.times { … }</code> executes the block ten times,
        passing into the block the number of the current iteration. When the
        block is omitted an <code>Enumerator</code> is returned.</p>

        <figure id=integer-times-loop.rb>
          <figcaption><code>Integer#times</code> executes the associated block
          the number of times specified by the receiver.
        </figure>
      </section>

      <section>
        <h1 id=integer-upto><code>Integer#upto</code></h1>

        <figure class=railroad>
          <img id=integer-upto.png>
          <figcaption>Syntax diagram of the <code>Integer#upto</code> loop
        </figure>

        <p>Similarly, <code>Integer#upto(<var>limit</var>)</code> counts from
        the value of the receiver <em>up</em> to the value of
        <var>limit</var>, executing the loop body each time. On each iteration
        the block is passed the current number in the progression. For,
        example, <code>10.upto(13)</code> executes the loop body four times,
        passing it 10, 11, 12, 13, then terminating. When the
        block is omitted an <code>Enumerator</code> is returned.</p>

        <figure id=integer-upto-loop.rb>
          <figcaption><code>Integer#upto</code> counts from the receiver up to
          its argument, executing the associated block each time
        </figure>
      </section>

      <section>
        <h1 id=integer-downto><code>Integer#downto</code></h1>

        <figure class=railroad>
          <img id=integer-downto.png>
          <figcaption>Syntax diagram of the <code>Integer#downto</code> loop
        </figure>

        <p>Conversely, <code>Integer#downto(<var>limit</var>)</code> counts
        from the value of the receiver <em>down</em> to the value of
        <var>limit</var>, executing the loop body each time. As with
        <code>Integer#upto</code>, the block is passed the number of the
        current progression. When the block is omitted an
        <code>Enumerator</code> is returned.</p>

        <figure id=integer-downto-loop.rb>
          <figcaption><code>Integer#downto</code> counts from the receiver
          down to its argument, executing the associated block each time
        </figure>

      </section>
    </section>

    <section>
      <h1 id=condition-controlled-loops>Condition-Controlled Loops</h1>

      <p>A condition-controlled loop uses a conditional to determine when the
      loop should terminate. The conditional is tested prior to each
      repetition, its value determining whether to repeat or terminate the
      loop.</p>
      <!-- warn about constant conditions -->
      <section>
        <h1 id=while-loop><code>while</code> Loops</h1>

        <figure class=railroad>
          <img id=while-loop.png>
          <figcaption>Syntax diagram of the <code>while</code> loop
        </figure>

        <p>The <code>while</code> loop executes its body as long as its
        conditional is true. If the conditional is initially false the body is
        never executed.</p>
  
        <figure id=while-loop-fig.rb>
          <figcaption>Using a <code>while</code> loop to calculate the Farey
          sequence of order <var>n</var>
        </figure>

        <section>
          <h1 id=postfix-while-statement>Postfix <code>while</code></h1>

          <figure class=railroad>
            <img id=postfix-while-statement.png>
            <figcaption>Syntax diagram of the postfix-<code>while</code>
            statement
          </figure>

          <p><code>while</code> can also be used as a statement modifier in
          which case it executes its left-hand side while its right-hand side
          is true.</p>

          <figure id=postfix-while-statement-fig.rb>
            <figcaption>Using the postfix-<code>while</code> statement to
            naïvely calculate the number of bits set in an integer
          </figure>
        </section>
      </section>

      <section>
        <h1 id=until-loop><code>until</code> Loops</h1>

        <figure class=railroad>
          <img id=until-loop.png>
          <figcaption>Syntax diagram of the <code>until</code> loop
        </figure>

        <p>The <code>until</code> loop executes its body as long as its
        conditional is false. If the conditional is initially true the body is
        never executed.</p>

        <figure id=until-loop-fig.rb>
          <figcaption>Using the <code>until</code> loop to generate the
          <i>look-and-say</i> sequence
        </figure>

        <section>
          <h1 id=postfix-until-statement>Postfix <code>until</code></h1>

          <figure class=railroad>
            <img id=postfix-until-statement.png>
            <figcaption>Syntax diagram of the postfix-<code>until</code> loop
          </figure>

          <p><code>until</code> can also be used as a statement modifier in
          which case it executes its left-hand side until its right-hand side
          is true.</p>

          <figure id=postfix-until-statement-fig.rb>
            <figcaption>Using the postfix-<code>until</code> statement to
            determine the next prime number following the receiver
          </figure>
        </section>
      </section>
    </section>

    <section>
      <h1 id=loop>Infinite Loops: <code>loop</code></h1>

      <figure class=railroad>
        <img id=loop-loop.png>
        <figcaption>Syntax diagram of the <code>loop</code> loop
      </figure>

      <p>The <code>loop</code> keyword executes its body indefinitely. Unlike
      the constructs discussed previously, there is no explicit terminating
      condition. An infinite loop qua infinite loop is undesirable, so the
      body will typically include statements that conditionally terminate it.
      Such statements include the control flow statements,
      <code>return</code>, <code>throw</code>, <code>raise</code>, and
      <code>exit</code>. The principle of <code>loop</code>, therefore, is to
      repeat an operation until explicitly told to halt.</p>

      <figure id=loop-loop-fig.rb>
        <figcaption>Using the <code>loop</code> construct to determine whether
        an integer is <i>happy</i>
      </figure>
    </section>

    <section>
      <h1 id=control-flow-statements>Control Flow Statements</h1>

      <!-- Clarify the below applies only to loops; the remarks in Closures
      apply to iterators. Perhaps move the Closures section to here?
      Similarly, return is introduced in Methods... -->

      <section>
        <h1 id=break-statement><code>break</code> Statement</h1>
        
        <figure class=railroad>
          <img id=break-statement.png>
          <figcaption>Syntax diagram of the <code>break</code> statement
        </figure>

        <p>Within a loop the <code>break</code> statement transfers control to
        the first statement following the loop. (Within a <a
          href=/closures#return-proc-semantics>proc</a> or <a
          href=/closures#return-lambda-semantics>lambda</a> it has different
        semantics). The value of a <code>break</code> statement, and therefore
        the enclosing loop, is that of its arguments—coerced into an
        <code>Array</code> if there is a plurality—, or <code>nil</code> in
        their absence.
      </section>

      <section>
        <h1 id=next-statement><code>next</code> Statement</h1>

        <figure class=railroad>
          <img id=next-statement.png>
          <figcaption>Syntax diagram of the <code>next</code> statement
        </figure>

        <p>The <code>next</code> statement ends the current iteration of the
        loop and begins the next. It raises a <code>LocalJump</code> exception
        when used outside of a loop or closure. Any arguments it is given are
        ignored.
      </section>

      <section>
        <h1 id=redo-statement><code>redo</code> Statement</h1>

        <figure class=railroad>
          <img id=redo-statement.png>
          <figcaption>Syntax diagram of the <code>redo</code> statement
        </figure>

        <p>The <code>redo</code> statement restarts the current iteration of
        the loop, returning control to the first expression in the body. The
        loop conditional is not re-evaluated.
      </section>

      <section>
        <h1 id=throw-catch><code>throw</code>/<code>catch</code> Statements</h1>
        
        <p>The <code>catch</code> method defines a labeled block of code. The
        <code>throw</code> method exits a <code>catch</code> block with a
        given label. Taken together, they form a general-purpose control
        structure.</p>

        <figure class=railroad>
          <img id=catch-throw-label.png>
          <figcaption>Syntax diagram of the label used in
          <code>catch</code>/<code>throw</code> pairs
        </figure>

        <p>The label is normally given as a <code>Symbol</code>, but a
        <code>String</code> is permissible, too.</p>

        <figure class=railroad>
          <img id=catch-statement.png>
          <figcaption>Syntax diagram of the <code>catch</code> statement
        </figure>

        <p>A <code>catch</code> block is defined with <code>catch
          <var>label</var> <var>block</var></code>, where <var>label</var> is
        the label which this block should catch, and <var>block</var> is a
        block literal. The block is called immediately.</p>

        <figure class=railroad>
          <img id=throw-statement.png>
          <figcaption>Syntax diagram of the <code>throw</code> statement
        </figure>

        <p>The syntax of <code>throw</code> is <code>throw <var>label</var>,
          <var>value</var></code>, where <var>label</var> is the label of an
        enclosing <code>catch</code> block, and <var>value</var> is an optional
        expression which, if supplied, becomes the value of the corresponding
        <code>catch</code> block. 
        
        <p><code>throw</code> immediately causes the current execution path to
        terminate and a search to begin for the nearest <code>catch</code>
        block defined with the same label. The search proceeds out through the
        current lexical scope, then up through the call stack towards the
        top-level of the program, crossing method boundaries if necessary. If
        such a <code>catch</code> is found, it is exited, and execution
        resumes from the statement that follows it. Otherwise, if the search
        is unsuccessful, an <code>ArgumentError</code> exception is raised.
      </section>
    </section>
    
    <section>
      <h1 id=iterating-collection>Iterating Over a Collection</h1>

      <section>
        <h1 id=each><code>each</code></h1>
      </section>

      <section>
        <h1 id=for><code>for</code></h1>
      </section>
    </section>
  </section>

  <section>
    <h1 id=exceptions>Exceptions</h1>

    <p>An <dfn>exception</dfn> is an object representing an abnormal condition
    that changes the typical flow of execution. A block may initiate, or
    <dfn>raise</dfn>, an exception to signal an abnormality which it is either
    unwilling or unable to handle locally. This suspends program execution and
    causes a corresponding <dfn>exception handler</dfn>—a block which has
    elected to resolve the abnormality—to be sought. If the search is
    successful, the handler is called, then execution resumes from the
    statement following that which raised the exception. Otherwise, the
    program terminates.</p>

    <section>
      <h1 id=exception-objects><code>Exception</code> Objects</h1>

      <p>Exceptions are instances of <code>Exception</code> or a subclass
      thereof. These subclasses primarily exist to increase granularity in
      <code>rescue</code> clauses, which match exceptions solely on their
      class. They rarely augment the behaviour of their parent.

      <p>Most core exceptions subclass <code>StandardError</code>, allowing
      them to rescued by a bare <code>rescue</code> clause. The remainder are
      not expected to be rescued in the normal course of a program, so must be
      mentioned explicitly if they are to be rescued. The principle,
      therefore, is that custom exception classes should inherit from
      <code>StandardError</code> if they are generally recoverable; and
      <code>Exception</code> otherwise.

      <p>A custom exception is created by subclassing an existing
      <code>Exception</code> class. Idiomatically this is:
      <code><var>CustomError</var> =
        Class.new(<var>ExceptionClass</var>)</code>, where
      <var>CustomError</var> is the name of the new exception class and
      <var>ExceptionClass</var> is that of an existing exception class.</p>

      <p>Exception objects are generally created implicitly with
      <code>raise</code>. An <code>Exception</code> class can be instantiated
      manually with its <code>.new</code> constructor, which accepts an
      optional <code>String</code> argument with which to set the exception’s
      message.</p>

      <section>
        <h1 id=exception-message>The Message</h1>

        <p>An exception’s <dfn title="exception message">message</dfn> is a
        human-readable <code>String</code> describing the nature of the
        encapsulated error. It is intended primarily for debugging purposes.
        
        <p>It is retrieved with the exception’s <code>#message</code>
        accessor. It can be set with an argument to
        <code>raise</code> or the constructor of the exception class. The
        default message is the name of the exception’s class.
      </section>

      <section>
        <h1 id=exception-backtrace>The Backtrace</h1>

        <p>The <dfn title='exception backtrace'>backtrace</dfn> of an
        exception describes the call stack at the moment the exception was
        raised. It is represented as an <code>Array</code> which details the
        call stack in reverse chronological order: the first element
        describing the line where the exception was raised, the second, the
        caller of the method where the exception was raised, the third, the
        caller of that method, etc. Each element of the <code>Array</code> is
        a <code>String</code> detailing the filename and line number of the
        event.

        <p>An exception’s backtrace is set automatically by <code>raise</code>
        using <code>Kernel.caller</code>. It can be created manually by
        supplying an appropriate <code>Array</code> as the third argument to
        <code>raise</code>, or <code>Exception#set_backtrace</code>.

        <p>The <code>Exception#backtrace</code> accessor returns the backtrace
        of the receiver.
      </section>
    </section>

    <section>
      <h1 id=raise><code>raise</code></h1>

      <figure class=railroad>
        <img id=raise-statement.png>
        <figcaption>Syntax diagram of the
        <code>raise</code>/<code>fail</code> statement
      </figure>
      
      <p>An exception is raised with the <code>Kernel.raise</code> method,
      or its alias <code>Kernel.fail</code>.

      <p>When <code>raise</code> is called without arguments it raises a
      <code>RuntimeError</code>. If called thusly inside a
      <code>rescue</code> clause, it re-raises the current exception.

      <p>If the sole argument to <code>raise</code> is an
      <code>Exception</code> object, that exception is raised. When the sole
      argument is a <code>String</code>, a <code>RuntimeError</code> is
      raised with that string as its message.

      <p>The first argument of <code>raise</code> can be an object
      responding to <code>:exception</code>, in which case the exception
      raised is the <code>Exception</code> object returned by that method.
      The <code>Exception</code> class itself defines such a method,
      allowing any of its subclasses to be used in this manner.

      <p><code>raise</code> accepts a <code>String</code> as an optional
      second argument, which becomes the exception’s message.

      <p>The exception’s <a href=#exception-backtrace>backtrace</a> may be set
      explicitly by providing an <code>Array</code> of <code>String</code>s as
      <code>raise</code>’s third argument.</p>

      <figure>
        <figcaption class=nowrap>A summary of the arguments accepted by
        <code>raise</code></figcaption>
        <table class=border>
          <thead>
            <tr>
              <th colspan=3>Arguments
              <th>Raises
            <tr>    
              <th><var>a</var>
              <th><var>b</var>
              <th><var>c</var>
              <th>&nbsp;
          <tbody>  
            <tr>
              <td>&nbsp;         
              <td>&nbsp;        
              <td>&nbsp;        
              <td><code>RuntimeError</code> or current exception
            <tr>
              <td><code>Exception</code>
              <td>&nbsp;
              <td>&nbsp;
              <td><var>a</var>  
            <tr>
              <td><code>Exception</code>
              <td><code>String</code>
              <td>&nbsp;
              <td><var>a</var> with <var>b</var> as the message 
            <tr>
              <td><code>Exception</code>
              <td><code>String</code>
              <td><code>Array</code>
              <td><var>a</var> with <var>b</var> as the message,
                  <var>c</var> as the backtrace 
            <tr>
              <td><code>String</code>
              <td>&nbsp;
              <td>&nbsp;
              <td><code>RuntimeError</code> with <var>a</var> as the message
            <tr>
              <td><code>respond_to?(:exception)</code>
              <td>&nbsp;
              <td>&nbsp;
              <td><code><var>a</var>.exception</code>
            <tr>
              <td><code>respond_to?(:exception)</code>
              <td><code>String</code>
              <td>&nbsp;
              <td><code><var>a</var>.exception</code> with <var>b</var> as the message
            <tr>
              <td><code>respond_to?(:exception)</code>
              <td><code>String</code>
              <td><code>Array</code>
              <td><code><var>a</var>.exception</code> with <var>b</var> as the
                  message, <var>c</var> as the backtrace
          </table>
       </figure>
    </section>

    <section>
      <h1 id=exception-propagation>Propagation</h1>

      <p>Once raised, exceptions propagate <q
        cite=/references#refFLAN08>outward and upward</q> (<a class=ref
        href=/references#refFLAN08>Flanagan &amp; Matsumoto</a>, pp.
      160–161) toward the first matching exception handler. Each block
      encountered by the search is examined for the presence of a
      <code>rescue</code> clause that matches the class of the current
      exception. If one is found, the exception is handled, and the search
      halted.
      
      <p>The outward propagation is the passage from the <code>raise</code>
      statement to the lexically enclosing block, to that block’s lexically
      enclosing block, until arriving at the top-level of the program. If
      the entire program is contained in a single file this step can be
      visualised as the movement from <code>raise</code> toward the left
      margin. 

      <p>If the outward search completes without the current exception being
      handled, the search continues up the call stack: to the caller of the
      current block, to the caller of the current block’s caller, and so on
      until the call stack is exhausted. If at this point the exception has
      not been handled, it is printed to STDERR and the program is aborted.
    </section>

    <section>
      <h1 id=exception-handling>Exception Handling</h1>


      <section>
        <h1 id=rescue><code>rescue</code></h1>

        <figure class=railroad>
          <img id=rescue-clause.png>
          <figcaption>Syntax diagram of a <code>rescue</code> clause
        </figure>

        <p>A <code>rescue</code> clause may be inserted as the final clause of
        a <code>begin</code> block, a method definition, a class definition,
        or a module definition. It handles the exceptions described by its
        arguments, then returns control to the statement following the
        initiating <code>raise</code>.

        <p>Without arguments, <code>rescue</code> handles only
        <code>StandardError</code> exceptions and subclasses thereof.
        <code>rescue</code> may be followed by <code> =&gt;
          <var>identifier</var></code> to assign the rescued exception to a
        local variable named <var>identifier</var>. Having done so,
        <code>Exception</code> instance methods such as <code>#message</code>
        and <code>#class</code> may be sent to it.

        <!-- TODO: Mention $! -->

        <p>If arguments are provided to <code>rescue</code> they must be
        supplied as a comma-separated list of <code>Exception</code> classes
        to be handled. A <code>rescue</code> clause so written will handle
        exceptions of any of the named classes or their subclasses.

        <p>A construct that accepts a <code>rescue</code> clause accepts any
        number of them. They are tested against the current exception in the
        order that they appear in the source file, so they should be arranged
        in order of decreasing specificity.
      </section>

      <section>
        <h1 id=begin-statement><code>begin</code> Statements</h1>
        
        <figure class=railroad>
          <img id=begin-statement.png>
          <figcaption>Syntax diagram of a <code>begin</code> statement
        </figure>

        <p><code>rescue</code> is typically used in conjunction with a
        <code>begin</code> statement, which simply associates a block
        of statements with one or more <code>rescue</code> clauses. The
        <code>rescue</code> clauses may be followed by optional
        <code>else</code> and <code>ensure</code> clauses, described below.
      </section>

      <section>
        <h1 id=else-clause><code>else</code> Clause</h1>
        
        <figure class=railroad>
          <img id=else-clause.png>
          <figcaption>Syntax diagram of an <code>else</code> clause
        </figure>

        <p>A group of <code>rescue</code> statements may be followed by an
        <code>else</code> clause, whose body is executed iff neither the
        <code>rescue</code> clauses handled an exception nor the preceding
        statements raised one. However, even in this case the use of flow
        control statements in the statements preceding the
        <code>rescue</code> clauses may cause the <code>else</code> clause
        to be skipped.
      </section>

      <section>
        <h1 id=ensure-clause><code>ensure</code> Clause</h1>
        
        <!-- Note that it handles exit(), too -->

        <p>A construct that accepts <code>rescue</code> clauses may include
        an <code>ensure</code> clause as its final clause. The statements in
        an <code>ensure</code> clause will always be executed, regardless of
        whether their previous sibling clauses raised an exception or
        employed a flow control statement such as <code>return</code>.
        Specifically, if the construct to which <code>ensure</code> is
        attached…
        
        <dl>
          <dt>Exits normally
          <dd>The <code>else</code> clause, if any, is
              executed, followed by the <code>ensure</code> clause.
          <dt>Executes <code>return</code>
          <dd>The <code>else</code> clause, if any, is skipped, and the
          <code>ensure</code> clause is executed.
          <dt>Raises an exception
          <dd>A matching <code>rescue</code> clause, if any, is executed,
          followed by the <code>ensure</code> clause.
        </dl>

        <p>The return value of a construct containing <code>ensure</code> is
        that of the previously executed clause, unless the
        <code>ensure</code> clause explicitly returns a value with
        <code>return</code>. That is, unlike other constructs the return
        value of <code>ensure</code> is not necessarily its last statement
        executed.  This is to allow <code>ensure</code> clauses to be
        attached to <code>def</code> statements, for example; otherwise the
        method being defined would never be able to return a value.

        <p>An <code>ensure</code> clause may cancel the propagation of an
        exception by raising an exception of its own or executing a control
        flow statement. This new transfer of control—be it to the end of the
        current block via <code>break</code> or <code>next</code>, the
        return of the current method via <code>return</code>, or the nearest
        matching <code>rescue</code> clause via <code>raise</code>—replaces
        that of the current exception, aborting its passage. 
      </section>
    </section>
  </section>
  
  <section>
    <h1 id=begin-end><code>BEGIN</code> / <code>END</code></h1>
  </section>
</section>

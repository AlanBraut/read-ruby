<!DOCTYPE html>
<meta charset=utf-8>
<title>Flow - Read Ruby</title>
<link rel=license href=//creativecommons.org/licenses/by-sa/3.0/>
<link rel=author href=mailto:runrun@runpaint.org>
<link rel=stylesheet href=style>

<!-- http://www.engineyard.com/blog/2010/iteration-shouldnt-spin-your-wheels/
-->
<section>
  <h1>Flow</h1>
  
  <section>
    <h1>Conditionals</h1>

    <p>A <dfn>conditional</dfn> is an expression evaluated as a truthbearer.
    The conditional is <dfn title="false conditional">false</dfn> if the
    expression’s value is <code>nil</code> or <code>false</code>; otherwise it
    is <dfn title="true conditional">true</dfn>.</p>

    <figure id=conditional-true>
      <!-- FIXME: Use if statement in example to show the conditionals’ truth
      -->
      <figcaption>Conditionals that are true
    </figure>

    <figure id=conditional-false>
      <!-- FIXME: Use unless statement in example to show the conditionals’
      falsity -->
      <figcaption>Conditionals that are false
    </figure>
  </section>

  <section>
    <h1>Branching</h1>
    
    <p><dfn>Branching statements</dfn> predicate the execution of block on a
    conditional. For example, an <code>if</code> statement executes its
    associated code block iff its conditional is true. Each code block of an
    branching statement is termed a <dfn>branch</dfn>, to describe the effect
    of the statement on program execution.</p>

    <section>
      <h1>The <code>if</code> Statement</h1>
      
      <figure class=railroad>
        <img id=if-statement>
        <figcaption>Syntax diagram of <code>if</code> statement
      </figure>

      <p>The <code>if</code> statement comprises a conditional, zero or more
      statements (the branch), then, optionally, additional branches whose
      forms are explained subsequently. The branch is executed iff the
      conditional is true.</p>

      <figure id=if-statement-simple>
        <figcaption>The simple form of the <code>if</code> statement
      </figure>

      <p>The return value of an <code>if</code> statement is that of the
      executed branch, or <code>nil</code> if no branch was executed.</p>

      <section>
        <h1 id=postfix-if>Postfix <code>if</code></h1>

        <figure class=railroad>
          <img id=postfix-if-statement>
          <figcaption>Syntax diagram of the postfix <code>if</code> statement
        </figure>

        <p>A postfix <code>if</code> statement is a concise alternative when
        the branch consists of a sole statement. It comprises an
        expression, the <code>if</code> keyword, then a conditional. The
        expression is executed iff the conditional is true.</p>
        
        <figure id=postfix-if-statement>
          <figcaption>The postfix <code>if</code> statement executes its
          left-hand side if its right-hand side is true
        </figure>

        <p>This syntax, as opposed to <code>if <var>conditional</var>…</code>,
        foregrounds the expression. This is of stylistic benefit if the
        conditional is normally true because it highlights the default
        case.</p>
      </section>

      <section>
        <h1>The <code>else</code> Clause</h1>

        <figure class=railroad>
          <img id=else-clause>
          <img id=if-statement>
          <figcaption>Syntax diagram of <code>if</code> statement with an
          <code>else</code> branch
        </figure>

        <p>Prior to an <code>if</code> statement’s <code>end</code> keyword an
        <code>else</code> branch may appear. It is executed iff no preceding
        branch was executed, serving as the default branch.</p>

        <figure id=if-statement-with-else-clause>
          <figcaption>An <code>if</code> statement can contain an
          <code>else</code> clause, which is executed iff no other branch was
          executed.
        </figure>
      </section>

      <section>
        <h1>The <code>elsif</code> Clause</h1>

        <figure class=railroad>
          <img id=elsif-clause>
          <img id=if-statement>
          <figcaption>Syntax diagram of <code>if</code> statement with an
          <code>elsif</code> branch
        </figure>

        <p>An <code>if</code> statement may contain any number of
        <code>elsif</code> branches between the <code>if</code> branch and
        before the <code>else</code> branch, if present. To execute they
        require all prior conditionals to be false and their conditional to be
        true.</p>

        <figure id=if-statement-with-elsif-and-else-clause>
          <figcaption>Using an <code>if</code> statement with
          <code>elsif</code> and <code>else</code> branches to compute the
          Möbius function
        </figure>

      </section>
    </section>


    <section>
      <h1>The <code>unless</code> Statement</h1>

      <figure class=railroad>
        <img id=else-clause>
        <img id=unless-statement>
        <figcaption>Syntax diagram of <code>unless</code> statement
      </figure>

      <p>The <code>unless</code> statement executes its branch iff its
      conditional is false. It may be followed by an <code>else</code> branch,
      which executes iff the <code>unless</code> conditional is true.
      <code>elsif</code> clauses are prohibited.</p>

      <section>
        <h1>Postfix Form</h1>
        
        <figure class=railroad>
          <img id=postfix-unless-statement>
          <figcaption>Syntax diagram of the postfix <code>unless</code>
          statement
        </figure>

        <p>The postfix form of the <code>unless</code> statement behaves as
        the postfix <code>if</code> statement, except the expression is
        executed iff the conditional is false.</p>
      </section>
    </section>
  </section>

  <section>
    <h1>Boolean Logic</h1>
    
    <p>The Boolean logic operators return either <code>true</code> or
    <code>false</code> by evaluating their operands as conditionals. For this
    reason, Boolean expressions are often themselves used as conditionals.

    <p>There are two forms of each Boolean operator—keyword (e.g.
    <code>and</code>) and  punctuation (e.g. <code>&amp;&amp;</code>)—which
    differ only in precedence. The former have low precedence; the latter
    high.</p>

    <section>
      <h1>The AND Operator</h1>
      
      <figure class=railroad>
        <img id=boolean-and-operator>
        <figcaption>Syntax diagram of the Boolean AND operator
      </figure>

      <p>The binary <code>and</code>/<code>&amp;&amp;</code> operators return
      <code>true</code> iff both operands are true. They perform short-circuit
      evaluation, so will only evaluate the second operand if the first is
      true.</p>

      <figure id=and-operator-fig>
        <figcaption>Using the Boolean AND operator (<code>&amp;&amp;</code>)
        and the bitwise AND operator (<code>&amp;</code>) to determine whether
        an integer is a power of 2
      </figure>
    </section>

    <section>
      <h1>The OR Operator</h1>

      <figure class=railroad>
        <img id=boolean-or-operator>
        <figcaption>Syntax diagram of the Boolean OR operator
      </figure>

      <p>The binary <code>or</code>/<code>||</code> operators return
      <code>true</code> iff at least one operand is true. They perform
      short-circuit evaluation, so will only evaluate the second operand if
      the first is false.</p>
    </section>

    <section>
      <h1>The NOT Operator</h1>

      <figure class=railroad>
        <img id=boolean-not-operator>
        <figcaption>Syntax diagram of the Boolean NOT operator
      </figure>

      <p>The unary <code>not</code>/<code>!</code> operators return
      <code>true</code> iff the operand is false.</p>
    </section>

    <section>
      <h1>The Ternary Operator</h1>

      <figure class=railroad>
        <img id=ternary-operator>
        <figcaption>Syntax diagram of the ternary operator
      </figure>

      <p>The ternary operator is a concise alternative to <code>if
        <var>conditional</var>…else…</code> when the conditional and branches
      are simple. It consists of three operands, the first of which is the
      conditional. If the conditional is true, the second expression is
      evaluated; otherwise the third expression is evaluated.</p>

      <figure id=ternary-operator-on-single-line>
        <figcaption>The ternary operator is a compact two-way branching
        construct
      </figure>
    </section>

    <section>
      <h1>The <code>case</code> Statement</h1>
    </section>
  </section>

  <section>
    <h1>Looping</h1>
    
    <p>Looping constructs represent repetition. They comprise a block of code
    (hereafter: the <dfn title="loop body">body</a>) and a <dfn>terminating
      condition</dfn> which governs the number of times the body will
    execute.</p>

    <p>The following constructs are materially identical in that they can all
    be used to create any kind of loop, albeit when combined with control flow
    statements. The purpose of having many different approaches to looping, as
    opposed to a single, generic construct, is to allow common scenarios to be
    expressed concisely and simply, and in doing so lessen the chance of
    erroneous terminating conditions.</p>
    <section>
      <h1>Count-Controlled Loops</h1>

      <p>The constructs that follow instrument an <i>a priori</i> number of
      repetitions.</p>

      <!-- for loops are unnecessary -->
      
      <section>
        <h1><code>Integer#times</code></h1>

        <figure class=railroad>
          <img id=integer-times>
          <figcaption>Syntax diagram of the <code>Integer#times</code> loop
        </figure>

        <p><code>Integer#times</code> creates a loop which executes
        <var>n</var> times, where <var>n</var> is the integer’s magnitude. For
        example, <code>10.times { … }</code> executes the block ten times,
        passing into the block the number of the current iteration. When the
        block is omitted an <code>Enumerator</code> is returned.</p>

        <figure id=integer-times-loop>
          <figcaption><code>Integer#times</code> executes the associated block
          the number of times specified by the receiver.
        </figure>
      </section>

      <section>
        <h1><code>Integer#upto</code></h1>

        <figure class=railroad>
          <img id=integer-upto>
          <figcaption>Syntax diagram of the <code>Integer#upto</code> loop
        </figure>

        <p>Similarly, <code>Integer#upto(<var>limit</var>)</code> counts from
        the value of the receiver <em>up</em> to the value of
        <var>limit</var>, executing the loop body each time. On each iteration
        the block is passed the current number in the progression. For,
        example, <code>10.upto(13)</code> executes the loop body four times,
        passing it 10, 11, 12, 13, then terminating. When the
        block is omitted an <code>Enumerator</code> is returned.</p>

        <figure id=integer-upto-loop>
          <figcaption><code>Integer#upto</code> counts from the receiver up to
          its argument, executing the associated block each time
        </figure>
      </section>

      <section>
        <h1><code>Integer#downto</code></h1>

        <figure class=railroad>
          <img id=integer-downto>
          <figcaption>Syntax diagram of the <code>Integer#downto</code> loop
        </figure>

        <p>Conversely, <code>Integer#downto(<var>limit</var>)</code> counts
        from the value of the receiver <em>down</em> to the value of
        <var>limit</var>, executing the loop body each time. As with
        <code>Integer#upto</code>, the block is passed the number of the
        current progression. When the block is omitted an
        <code>Enumerator</code> is returned.</p>

        <figure id=integer-downto-loop>
          <figcaption><code>Integer#downto</code> counts from the receiver
          down to its argument, executing the associated block each time
        </figure>

      </section>
    </section>

    <section>
      <h1>Condition-Controlled Loops</h1>

      <p>A condition-controlled loop uses a conditional to determine when the
      loop should terminate. The conditional is tested prior to each
      repetition, its value determining whether to repeat or terminate the
      loop.</p>
      <!-- warn about constant conditions -->
      <section>
        <h1><code>while</code> Loops</h1>

        <figure class=railroad>
          <img id=while-loop>
          <figcaption>Syntax diagram of the <code>while</code> loop
        </figure>

        <p>The <code>while</code> loop executes its body as long as its
        conditional is true. If the conditional is initially false the body is
        never executed.</p>
  
        <figure id=while-loop-fig>
          <figcaption>Using a <code>while</code> loop to calculate the Farey
          sequence of order <var>n</var>
        </figure>

        <section>
          <h1>Postfix <code>while</code></h1>

          <figure class=railroad>
            <img id=postfix-while-statement>
            <figcaption>Syntax diagram of the postfix-<code>while</code>
            statement
          </figure>

          <p><code>while</code> can also be used as a statement modifier in
          which case it executes its left-hand side while its right-hand side
          is true.</p>

          <figure id=postfix-while-statement-fig>
            <figcaption>Using the postfix-<code>while</code> statement to
            naïvely calculate the number of bits set in an integer
          </figure>
        </section>
      </section>

      <section>
        <h1><code>until</code> Loops</h1>

        <figure class=railroad>
          <img id=until-loop>
          <figcaption>Syntax diagram of the <code>until</code> loop
        </figure>

        <p>The <code>until</code> loop executes its body as long as its
        conditional is false. If the conditional is initially true the body is
        never executed.</p>

        <figure id=until-loop-fig>
          <figcaption>Using the <code>until</code> loop to generate the
          <i>look-and-say</i> sequence
        </figure>

        <section>
          <h1>Postfix <code>until</code></h1>

          <figure class=railroad>
            <img id=postfix-until-statement>
            <figcaption>Syntax diagram of the postfix-<code>until</code> loop
          </figure>

          <p><code>until</code> can also be used as a statement modifier in
          which case it executes its left-hand side until its right-hand side
          is true.</p>

          <figure id=postfix-until-statement-fig>
            <figcaption>Using the postfix-<code>until</code> statement to
            determine the next prime number following the receiver
          </figure>
        </section>
      </section>
    </section>

    <section>
      <h1>Infinite Loops: <code>loop</code></h1>

      <figure class=railroad>
        <img id=loop-loop>
        <figcaption>Syntax diagram of the <code>loop</code> loop
      </figure>

      <p>The <code>loop</code> keyword executes its body indefinitely. Unlike
      the constructs discussed previously, there is no explicit terminating
      condition. An infinite loop qua infinite loop is undesirable, so the
      body will typically include statements that conditionally terminate it.
      Such statements include the control flow statements,
      <code>return</code>, <code>throw</code>, <code>raise</code>, and
      <code>exit</code>. The principle of <code>loop</code>, therefore, is to
      repeat an operation until explicitly told to halt.</p>

      <figure id=loop-loop-fig>
        <figcaption>Using the <code>loop</code> construct to determine whether
        an integer is <i>happy</i>
      </figure>
    </section>

    <section>
      <h1>Iterating Over a Collection</h1>

      <section>
        <h1><code>each</code></h1>
      </section>

      <section>
        <h1><code>for</code></h1>
      </section>
    </section>

    <section>
      <h1>Exceptions</h1>
    </section>
    
    <section>
      <h1><code>BEGIN</code> / <code>END</code></h1>
    </section>
  </section>
</section>

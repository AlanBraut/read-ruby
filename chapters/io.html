<link rel=next href=/files>
<article>
  <h1 id=io>Input &amp; Output</h1>

  <blockquote cite=/references#refWALL00>
    <p>Unless you're using artificial intelligence to model a solipsistic
    philosopher, your program needs some way to communicate with the outside
    world.
    <p>&mdash;  Wall, Christiansen, &amp; Orwant, <a
      href=/references#refWALL00><cite>Programming Perl, 3<sup>rd</sup>
        ed.</cite></a>, 2000, pp. 20&ndash;22. 
  </blockquote>

  <p>The <code>IO</code> class provides an interface to input and output on
  the level of file descriptors, while its <code>File</code> subclass deals
  with files on a higher level of abstraction. Accordingly, <code>File</code>,
  which is discussed in the <a href=/files>following chapter</a>, is often
  more appropriate, and easier to use.

  <blockquote cite=/references#refKERNIGHAN84>
    <p>All input and output is done by reading or writing files, because all
    peripheral devices, even your terminal, are files in the file system. This
    means that a single interface handles all communication between a program
    and peripheral devices.
    <p>&mdash; Kernighan &amp; Pike, <a
      href=/references#refKERNIGHAN84><cite>The UNIX Programming
        Environment</cite></a>, 1984, pp. 201&ndash;202
  </blockquote>

  <p>In keeping with Unix’s everything-is-a-file philosophy<a
    href=#fn-unix-philosophy>‡</a>, Ruby allows regular files, directories,
  block and character devices, symbolic links, hard links, sockets, unnamed
  pipes, and <abbr title='First-In First-Out'>FIFO</abbr>s (named pipes), to
  be treated conceptually the same. They can be read from and written to.
  Before operating on a file, we need to <a href=#open><i>open</i></a> it by
  providing the operating system with the pathname and asking permission to
  read it, write to it, or both. If our request is granted, we are provided
  with a integer <i>file descriptor</i> which we must use to refer to the file
  in future operations. We are allowed only to use the file in the manner, or
  <a href=#access-mode><i>access mode</i></a>, we requested: it is illegal to
  write to a file opened for reading, or vice versa. With this file descriptor
  we can <a href=#init>initialize an <code>IO</code> object</a>, or
  <i>stream</i><a href=#fn-stream>†</a>, which provides an interface for
  accessing the corresponding file.  
  
  <p>A stream containing binary data can have its <a
    href=#binmode><code>binmode</code></a> attribute set, which prevents it
  from being transcoded and associates it with the <a
    href=/text#ascii-8bit>ASCII-8BIT</a> encoding.  Conversely, a stream
  containing textual data can have its <a
    href=#textmode><code>textmode</code></a> attribute set, which allows
  transcoding and newline normalisation.

  <p>Also, associated with a stream is a byte offset, or <a
    href=#position><i>file position</i></a>, which specifies where the next
  read or write should occur. <q cite=/references#refLOVE07>When a file is
    first opened, the file position is zero. Usually, as bytes in the file are
    read from or written to, byte-by-byte, the file position
  increases in kind. The file position may also be set manually to a given
  value, even a value beyond the end of the file.</q> (Love, <a
  href=/references#refLOVE07><cite>Linux System Programming</cite></a>, 2007,
  pp. 9&ndash;10) Attempting to read past the end of a file (<i>EoF</i>) will
  result in either a <code>nil</code> value or an exception being raised,
  depending on the method used. A file is appended to by writing to a position
  past its end. The size of a file may be reduced by truncating<a
    href=#fn-truncate>†</a> it to a smaller size. 
  <!-- Link truncate to description in Files of File.truncate
  -->

  <p>Finally, having used a file descriptor, we should <i>close</i> it to
  release it back to the operating system.</p>

  <!-- TODO: closing a stream -->
  <section>
    <h1 id=standard-streams>Standard Input, Output, &amp; Error</h1>

    <blockquote cite=/references#refKERNIGHAN84>
      <p>When it is started by the shell, a program inherits three open files,
      with file descriptors 0, 1, and 2, called the standard input, the standard
      output, and the standard error. All of these are by default connected to
      the terminal, so if a program only reads file descriptor 0 and writes file
      descriptors 1 and 2, it can do I/O without having to open files. If the
      program opens any other files, they will have file descriptors 3, 4, etc.

      <p>&mdash; Kernighan &amp; Pike, <a
        href=/references#refKERNIGHAN84><cite>The UNIX Programming
          Environment</cite></a>, 1984, pp. 201&ndash;202
    </blockquote>

    <p>Ruby behaves in the same manner. The constants <code>STDIN</code>,
    <code>STDOUT</code>, and <code>STDERR</code>, are defined automatically to
    refer to the program’s standard input, standard output, and standard error
    streams, respectively. The value of each constant is an <code>IO</code>
    object associated with the corresponding file descriptor.
    <code>IO#fileno</code> returns the file descriptor it is associated with as
    an <code>Integer</code>, as shown below.</p>

    <figure id=stdin-stdout-stderr.rb>
      <figcaption>Ruby predefines three constants, referring to the standard
      input, standard output, and standard error streams.
    </figure>
    
    <p>Three global variables are also defined
    automatically-<code>$stdin</code>, <code>$stdout</code>, and
    <code>$stderr</code>-which initially hold the value of the corresponding
    constant. We have in fact been interacting with <code>$stdout</code>
    implicitly all along: <code>Kernel.puts</code> is equivalent to
    <code>$stdout.puts</code>. Similarly, <code>Kernel.warn</code> writes to
    <code>$stderr</code>. The reason for the existence of these global
    variables in addition to the aforementioned constants is that by assigning
    another <code>IO</code> object to one of the global variables, we can
    temporarily redirect it elsewhere. Then, if we want to restore the
    original behaviour, we can assign the corresponding constant to the
    variable.</p>

    <figure id=stdout-redirection.rb>
      <figcaption>By assigning <code>IO</code> objects to <code>$stdout</code> we
      can redirect our output.
    </figure>

    <!--  
    def with_verbosity(verbosity=false)
      old, $VERBOSE = $VERBOSE, verbosity
      yield
    ensure
      $VERBOSE = old
    end

    def quietly(&block)
      with_verbosity(nil, &block)
    end
    def loudly(&block)
      with_verbosity(true, &block)
    end
    -->  
  </section>

  <section>
    <h1 id=writing>Writing to a Stream</h1>

    <!-- Cover warn here? -->
    
    <p>If a stream has been opened for writing, we can write data to it using
    a variety of methods. We will begin, with the low-level
    <code>IO#syswrite</code>, which requires exactly one argument that it
    converts to a <code>String</code>, writes to the stream, then returns the
    number of bytes written. It uses a low-level system call to perform this
    operation, so the official documentation cautions that it should not be
    used in conjunction with other, higher-level writing methods<a
      href=#fn-syswrite-caution>†</a>. <code>IO#write</code> behaves in the
    same manner, but without the risks. In fact, all other writing methods are
    implemented in terms of <code>#write</code>. For example,
    <code>IO#printf</code> formats its arguments with <a
      href=/text#format-strings><code>Kernel#sprintf</code></a> before passing
    the result to <code>#write</code>, i.e. <code>write(sprintf *args)</code>.</p>

    <figure id=write-syswrite-printf.rb>
      <figcaption>Displaying output with <code>#write</code>,
      <code>#syswrite</code>, and <code>#printf</code>
    </figure>
    
    <p><code>IO#&lt;&lt;</code> writes its argument to its receiver, which it
    then returns. This is a more common way to write to a stream because the
    selector is polymorphic, <a href=/messages#left-shift>conventionally</a>
    appending its argument to its receiver.

    <p><code>IO#putc</code> writes a single byte to its stream, then returns
    its argument. It interprets a <code>Numeric</code> argument as a character
    code, writing the least-significant byte of the character corresponding to
    its integer part. A non-numeric argument is converted to a
    <code>String</code>, then its least-significant byte is written to the
    stream. Please note the term <i>byte</i>: this method will only ever write
    a single byte, even when given a multi-byte character. </p>

    <figure id=syswrite-write-putc.rb>
      <figcaption>The <code>#syswrite</code>, <code>#write</code>, and
      <code>#putc</code> methods of <code>IO</code> write their arguments to
      an <code>IO</code> stream.
    </figure>

    <p><code>Object#display</code> converts its receiver to a
    <code>String</code>, then writes it to <code>$stdout</code>. If given an
    <code>IO</code> stream as an argument, it writes to that stream
    instead.</p>

    <figure id=object-display.rb>
    <figcaption><code>Object#display</code> writes its receiver to an
    <code>IO</code> stream.
    </figure>

    <p><code>IO#print</code> accepts any number of arguments, each of which
    are converted with <code>#to_s</code>, then their concatenation is written
    to the receiver. If no arguments are supplied, an argument of
    <code>$_</code> is assumed. <code>Kernel#print</code> behaves identically,
    expect it writes to <code>$stdout</code>.

    <p><code>IO#puts</code> also accepts any number of arguments, which it
    converts with <code>#to_s</code>. A newline is appended to each of these
    <code>String</code>s that do not already end with one. Then, their
    concatenation is written to their receiver. If no arguments are
    provided, <code>nil</code> is assumed, so by default a single newline is
    written. <code>Array</code> arguments are automatically expanded into
    their constituent elements, so each element is written on a line of its
    own. <code>Kernel#puts</code> writes to <code>$stdout</code>, instead.</p>

    <figure id=print-puts.rb>
      <figcaption>The <code>#print</code> and <code>#puts</code> methods of
      <code>IO</code> and <code>Kernel</code> write their arguments to an
      <code>IO</code> stream.
    </figure>

    <p><code>Kernel#p</code> provides output suitable for debugging. It
    accepts any number of arguments, which it converts with
    <code>#inspect</code>, then writes each of them to <code>$stdout</code>
    separated by <code>"\n"</code>.</p>

    <figure id=object-p.rb>
      <figcaption><code>Object#p</code> writes its argument’s
      <code>#inspect</code> output to <code>$stdout</code>
    </figure>

    <table class=border>
      <caption>
        <details>
          <summary>
            A comparison of the methods that write to an <code>IO</code>
            stream.
          </summary>

          <p>Each method converts its input as described in the <i>Converts</i>
          column. If multiple arguments are expected and received, they are
          concatenated with the contents of the <i>Separator</i> column. The
          method returns the value in <i>Returns</i>. If it can be invoked
          without any arguments, the <i>Default Output</i> column describes
          what it writes.
        </details>
      </caption>  
      <thead>
        <tr>
          <th>Method
          <th>Arity    
          <th>Converts
          <th>Separator
          <th>Returns
          <th>Default Output
      <tbody class=zebra>      
        <tr>
          <td><code>IO#syswrite</code>
          <td>1  
          <td><code>#to_s</code>
          <td>N/A  
          <td><code>Integer</code>
          <td>N/A  
        <tr>
          <td><code>IO#write</code>
          <td>1  
          <td><code>#to_s</code>
          <td>N/A  
          <td><code>Integer</code>
          <td>N/A  
        <tr>
          <td><code>IO#putc</code>
          <td>1
          <td><code>#to_s</code> or <code>#chr</code>
          <td>N/A
          <td>Argument  
          <td>N/A
        <tr>
          <td><code>Object#display</code>
          <td>0&ndash;1  
          <td><code>#to_s</code>
          <td>N/A
          <td><code>nil</code>  
          <td><code>self.to_s</code>    
        <tr>
          <td><code>IO#print</code>
          <td>-1
          <td><code>#to_s</code>
          <td><code>""</code>  
          <td><code>nil</code>  
          <td><code>$_.to_s</code>  
        <tr>
          <td><code>IO#puts</code>
          <td>-1
          <td><code>#to_s</code>
          <td><code>"\n"</code> (if needed)
          <td><code>nil</code>  
          <td><code>"\n"</code>  
        <tr>
          <td><code>Object#p</code>
          <td>-1
          <td><code>#inspect</code>
          <td><code>\n</code>  
          <td>Arguments
          <td><code>""</code>  
    </table>

    <!--TODO: Link to #printf coverage in Text -->
  </section>


  <section>
    <h1 id=reading>Reading from a Stream</h1>

    <section>
      <h1 id=reading-bytes>Bytes</h1>

      <p>At the most basic level, a stream can be thought of as a sequence of
      bytes. The next byte in a stream is returned by <code>IO#getbyte</code>
      as a <code>Fixnum</code>, or <code>nil</code> if EoF has been reached.
      <code>IO#readbyte</code> also returns the next byte from a stream, but
      when EoF is reached it raises an <code>EOFError</code> exception.

      <p>A variable number of bytes may be read each time with
      <code>IO#read</code>. By default it reads every byte until EoF, at which
      point it returns <code>nil</code>. If provided with an
      <code>Integer</code> as its first argument, it will read at most the
      given number of bytes. When provided with a <code>String</code> as its
      second argument, it will assign the data it reads to that
      <code>String</code>. In all cases, the data is returned as a
      <code>String</code> with <a href=/text#ascii-8bit>ASCII-8BIT</a>
      encoding. <code>IO#sysread</code> behaves in a similar fashion, except
      it requires the <code>Integer</code> first argument, and raises
      <code>EOFError</code> at EoF.

      <p>Rather than reading bytes piecemeal, <code>IO#bytes</code>, and its
      alias <code>IO#each_byte</code>, return an <code>Enumerator</code> of the
      stream’s bytes as <code>Fixnum</code>s. If a block is supplied, it is
      yielded each byte in turn. 

      <table class=border>
        <thead>
          <tr>
            <th>Method
            <th>Bytes Read 
            <th><code>String</code> Buffer?   
            <th>At EoF   
        <tbody class=zebra>
          <tr>
            <td><code>IO#read(<var>n</var> = all, &hellip;)</code>
            <td><var>n</var>
            <td>✔
            <td><code>nil</code>
          <tr>
            <td><code>IO#sysread(<var>n</var>, &hellip;)</code>
            <td><var>n</var>
            <td>✔
            <td><code>EOFError</code>
          <tr>
            <td><code>IO#getbyte</code>
            <td>1  
            <td>✖
            <td><code>nil</code>
          <tr>
            <td><code>IO#readbyte</code>
            <td>1  
            <td>✖
            <td><code>EOFError</code>
      </table>
    </section>

    <section>
      <h1 id=reading-chars>Characters</h1>

      <p>A stream may be read character-by-character with either
      <code>IO#getc</code> or <code>IO#readchar</code>, both of which return
      one-character <code>String</code>s. When EoF is reached, the former
      returns <code>nil</code>, while the latter raises an
      <code>EOFError</code>. Alternatively, <code>IO#chars</code>, and its alias
      <code>IO#each_char</code> return an <code>Enumerator</code> of the
      stream’s characters. As is customary, they may also be supplied with a
      block in which case they yield each character in turn.
    </section>

    <section>
      <h1 id=io-reading-lines>Lines</h1>

      <p><code>IO#gets</code> allows a stream to be processed as a sequence of
      “lines”, each separated by separator, <var>sep</var>. If <var>sep</var>
      is not given, it is assumed to have the value of <code>$/</code>, which
      is <code>"\n"</code> by default. If an <code>Integer</code> limit is
      supplied, at most that many bytes will be returned at a time; by default
      there is no limit. According to Thomas et al., a negative limit makes
      the search for <var>sep</var> more efficient by ignoring the stream’s
      encoding (<cite>Programming Ruby 1.9: The Pragmatic Programmers’
        Guide</cite>, 2009, p. 551).  The permutations of these arguments are
      enumerated below:

      <table class=border>
        <thead>
          <tr>
            <th>Arguments
            <th>Separator
            <th>Limit
        <tbody class=zebra>
          <tr>
            <td>&nbsp;
            <td><code>$/</code>
            <td>None  
          <tr>
            <td><code>nil</code>
            <td>None
            <td>None  
          <tr>
            <td><code>""</code>
            <td><code>"\n\n"</code>
            <td>None  
          <tr>
            <td><var>sep</var> (<code>String</code>)
            <td><var>sep</var>
            <td>None  
          <tr>
            <td><var>limit</var> (<code>Integer</code> &gt; 0)
            <td><var>$/</var>
            <td><var>limit</var>
          <tr>
            <td><var>limit</var> (<code>Integer</code> &lt; 0)
            <td><var>$/</var>
            <td>None
          <tr>
            <td><var>sep</var> (<code>String</code>), <var>limit</var>
              (<code>Integer</code> &gt; 0)
            <td><var>sep</var>
            <td><var>limit</var>
      </table>
      
      <p><code>IO#readline</code> behaves identically, and expects the same
      arguments, but raises an <code>EOFError</code> when EoF is reached.
      <code>IO#readlines</code> also expects the same arguments, but returns an
      <code>Array</code>, each element of which is a line terminated by the
      given separator. <code>IO#lines</code>, and its alias
      <code>IO#each_line</code>, behave like <code>IO#readlines</code>, but
      return an <code>Enumerator</code> instead of an <code>Array</code>. When
      either method is given a block, it yields each line in turn.
    </section>
  </section>
  
  <section>
    <h1 id=access-mode>Access Mode</h1>

    <p>A file is opened with a particular <dfn>access mode</dfn> which
    specifies the type of action that may be performed on it. It is given as
    either a <code>String</code> or, less commonly, a <a
      href=#open-flags>bitmask</a>, as shown in the table below. The default
    access mode is <code>r</code>.</p>

    <table class=border>
      <caption>
        <details>
          <summary>Access mode specifiers</summary>  
          
          <p>The access mode is presented as both a <i>String</i> and the
          equivalent <i>Bitmask</i>. The <i>Read?</i> and <i>Write?</i>
          columns indicate whether the opened file can be read from or written
          to, respectively.  <i>Truncate?</i> specifies that existing files
          will be truncated before use. <i>Creates?</i> specifies that
          non-existent files will be created before use.  Finally, <i>Start
            Position</i> is the position in the file reading/writing starts
          from: <i>Beginning</i> is before the first byte; <i>End</i> is after
          the last.
        </details>
      </caption>
      <thead>  
        <tr>
          <th>String
          <th>Bitmask
          <th title='Opened for reading?'>Read?
          <th title='Opened for writing?'>Write?
          <th title='Truncated if it exists?'>Truncates?
          <th title='Created if it doesn’t exist?'>Creates?
          <th title='Where reading/writing starts from'>Start Position
      <tbody class=zebra>
        <tr>
          <td><code>r</code>
          <td><code>File::RDONLY</code>  
          <td>✔
          <td>✖
          <td>✖
          <td>✖
          <td>Beginning.
        <tr>
          <td><code>r+</code>
          <td><code>File::RDWR</code>  
          <td>✔
          <td>✔
          <td>✖
          <td>✖
          <td>〃  
        <tr>
          <td><code>w</code>
          <td><code>File::WRONLY | File::TRUNC | File::CREAT</code>  
          <td>✖
          <td>✔
          <td>✔
          <td>✔
          <td>〃  
        <tr>
          <td><code>w+</code>
          <td><code>File::RDWR | File::TRUNC | File::CREAT</code>  
          <td>✔
          <td>✔
          <td>✔
          <td>✔
          <td>〃  
        <tr>
          <td><code>a</code>
          <td><code>File::APPEND | File::WRONLY | File::CREAT</code>  
          <td>✖
          <td>✔
          <td>✖
          <td>✔
          <td>End.
        <tr>
          <td><code>a+</code>
          <td><code>File::APPEND | File::RDWR | File::CREAT</code>  
          <td>✔
          <td>✔
          <td>✖
          <td>✔
          <td>〃  
    </table>
  </section>        
  
  <section>
    <h1 id=binmode-textmode>Binary &amp; Text Mode</h1>

    <p>An <code>IO</code> stream may be configured to use binary mode or text
    mode. These mutually exclusive options determine what automatic
    modifications, if any, Ruby will make to data read from, and written to,
    the stream. They have no relationship to the <a href=#access-mode>access
      mode</a>.</p>

    <section>
      <h1 id=binmode>Binary Mode</h1>
      
      <p><dfn>Binary mode</dfn> is disabled by default. It must be enabled
      when reading a file with an <a
        href=/text#encoding-compatibility>ASCII-incompatible</a> <a
        href=#external-encoding>external encoding</a>. When enabled it has the
      following effects:

      <ul>
        <li>Unless an external encoding has been specified explicitly, it
        is set to ASCII-8BIT.
        <li><a href=#text-mode>Newline conversion</a> is disabled. <!-- Unless *_newline Hash
        key? -->
        <li>Transcoding is disabled unless both an internal and external
        encoding have been specified.
      </ul>  
    </section>

    <section>
      <h1 id=textmode>Text Mode</h1>
      
      <p><dfn>Text mode</dfn> defaults to on under Microsoft Windows, and off
      everywhere else.  Reading a file in text mode causes <code>"\r\n"</code>
      to be replaced by <code>"\n"</code>, and other occurrences of
      <code>"\r"</code> to be replaced by <code>"\n"</code>. Writing a file in
      text mode causes <code>"\n"</code> to be replaced with
      <code>"\r\n"</code> under Windows; having no effect on other platforms.
    </section>
  </section>

  <section>
    <h1 id=open>Opening a File</h1>

    <p><code>IO.sysopen</code> <dfn>opens</dfn> a given pathname and returns a
    corresponding file descriptor. (Use the <a href=/files><code>File</code>
      class</a> for higher-level interface to this operation). Optionally, it
    accepts an <a href=#access-mode>access mode</a> as the second argument,
    and <a href=#perm>permission bits</a> as the third.</p>

    <section>
      <h1 id=perm>Permissions</h1>
      
      <p>If a file is being created, its initial permissions may be specified
      as an <code>Integer</code>; otherwise, this argument is ignored. On
      Unix-like systems, these permissions bits are interpreted in the same
      fashion that <code>chmod(1)</code> interprets octal mode arguments. For
      example, permissions of <code>0400</code> gives the user read
      permission, and no permissions to anybody else. See <a
        href=/files#permissions>Files: Permissions</a> for further details.
    </section>
  </section>

  <section>
    <h1 id=string>Encoding String</h1>

    <p><code>IO</code> methods that expect encoding names as arguments, often
    accept <dfn>encoding string</dfn>s, which allow one or both of the <a
      href=/encoding#external>external encoding</a> and <a
      href=/encoding#internal>internal encoding</a> to be specified at once in
    one of the forms below.</p>

    <table class=border>
      <caption>
        <details>
          <summary>
            The forms the value of the encoding string may take.
          </summary>

          <p>Both <var>external</var> and <var>internal</var> are names of
          encodings. The <i>Inferred from BOM</i> column indicates that the
          external encoding is set to that specified by a <abbr
            title='Byte-Order Mark'>BOM</abbr>, if present, otherwise to the
          named encoding.
        </details>
      </caption>
      <thead>  
        <tr>
          <th>Form
          <th colspan=2>External Encoding
          <th>Internal Encoding    
        <tr>
          <th>&nbsp;
          <th>Value
          <th>Inferred from BOM?    
          <th>Value    
      <tbody>        
        <tr class=odd>
          <td><code><var>external</var></code>
          <td rowspan=2><var>external</var>
          <td rowspan=2>✖
          <td rowspan=2><code>Encoding.default_internal</code>
        <tr class=odd>
          <td><code><var>external</var>:-</code>
        <tr>
          <td><code>BOM|<var>external</var></code>
          <td rowspan=2><var>external</var>
          <td rowspan=2>✔
          <td rowspan=2><code>Encoding.default_internal</code>
        <tr>
          <td><code>BOM|<var>external</var>:-</code>
        <tr class=odd>
          <td><code><var>external</var>:<var>internal</var></code>
          <td><var>external</var>
          <td>✖
          <td><var>internal</var>
        <tr>
          <td><code>BOM|<var>external</var>:<var>internal</var></code>
          <td><var>external</var>
          <td>✔
          <td><var>internal</var>
        <tr class=odd>
          <td><code>:<var>internal</var></code>
          <td>Default external
          <td>✖
          <td><var>internal</var>
    </table>
    
    <p>The <code>BOM|</code> prefix deserves a fuller explanation. The
    UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE encodings support
    the presence of a byte-order mark: a special character occuring at
    the start of the stream which indicates the byte order of the
    encoding. This can be used to distinguish between the big-endian and
    little-endian forms of UTF-16, for example. Prefixing one of the
    aforementioned encoding names with the case-insensitive string
    <code>BOM|</code> has the following result:

    <ul>
      <li>If no BOM is present, the named encoding is used.
      <li>If a BOM is present, the encoding that it specifies is used
      instead of the named encoding, and the BOM is stripped from the
      data.
    </ul>

    <table class=border>
      <caption>Encodings that support byte-order marks, and the content of
        the corresponding BOM.</caption>
      <thead>  
        <tr>
          <th>Encoding
          <th>Byte-Order Mark
      <tbody class=zebra>        
        <tr>
          <td>UTF-8
          <td><code>\xEF\xBB\xBF</code>  
        <tr>
          <td>UTF-16BE
          <td><code>\xFE\xFF</code>  
        <tr>
          <td>UTF-16LE
          <td><code>\xFF\xFE</code>  
        <tr>
          <td>UTF-32BE
          <td><code>\0\0\xFE\xFF</code>  
        <tr>
          <td>UTF-32LE
          <td><code>\xFF\xFE\0\0</code>  
      </table>
  </section>

  <section>
    <h1 id=init>Initializing an <code>I/O</code> Stream</h1>

    <p>An <code>IO</code> instance objectifies a given file descriptor. It may
    be initialized by supplying this file descriptor as the first argument to
    <code>IO.new</code>, or its alias <code>IO.for_fd</code>. Optionally, a <a
      href=#mode-string>mode string</a>, or <a href=#open-flags>numeric access
      mode</a>, can be provided as the second
    argument, however this must agree with the <a href=#access-mode>access
      mode</a> already associated with the file descriptor. An <a
      href=#options-hash>options <code>Hash</code></a> may be provided as the
    final argument.</p>

    <p><code>IO.open</code> accepts the same arguments, but also expects a
    block. It initializes an <code>IO</code> object as before, yields it to
    the block, then ensures the stream is closed when the block exits.</p>

    <section>
      <h1 id=mode-string>The Mode String</h1>

      <p>The <dfn>mode string</dfn> is a concise way to specify options for
      opening a file. At its simplest, it consists of only the <a
        href=#access-mode>access mode</a> as a <code>String</code>, e.g. a
      mode string of <code>"r"</code> opens a file in read-only mode. If the
      next character is <code>b</code>, it specifies <a href=#binmode>binary
        mode</a>; if it is <code>t</code>, it specifies <a href=#textmode>text
        mode</a>. Finally, the <a href=#external-encoding>external</a> and/or
      <a
        href=#internal-encoding>internal</a> encodings may be specified as an
      <a href=#encoding-string>encoding string</a>.

      <table class=border>
        <caption>
          <details>
            <summary>The forms a mode string may take</summary>  

            <p><var>mode</var> denotes one of the access modes given in the <a
              href=#access-mode>Access Mode</a> table.  The <i>Binary?</i> and
            <i>Text?</i> columns indicates whether the stream is in <a
              href=#binmode>binary</a> or <a href=#textmode>text mode</a>,
            respectively. Both <var>internal</var> and <var>external</var> are
            names of encodings.
          </details>
        </caption>
        <thead>  
          <tr>
            <th>Form
            <th>Binary?  
            <th>Text?  
            <th>External Encoding  
            <th>Internal Encoding  
        <tbody class=zebra>        
          <tr>
            <td><code><var>mode</var></code>
            <td>✖
            <td>✖
            <td><code>Encoding.default_external</code>
            <td><code>Encoding.default_internal</code>
          <tr>
            <td><code><var>mode</var>t</code>
            <td>✖
            <td>✔
            <td>〃  
            <td>〃  
          <tr>
            <td><code><var>mode</var>b</code>
            <td>✔
            <td>✖
            <td><code>ASCII-8BIT</code>
            <td>〃  
          <tr>
            <td><code><var>mode</var>:<var>external</var></code>
            <td>✖
            <td>✖
            <td><var>external</var>
            <td>〃  
          <tr>
            <td><code><var>mode</var>t:<var>external</var></code>
            <td>✖
            <td>✔
            <td>〃  
            <td>〃  
          <tr>
            <td><code><var>mode</var>b:<var>external</var></code>
            <td>✔
            <td>✖
            <td>〃  
            <td>〃  
          <tr>
            <td><code><var>mode</var>:<var>external</var>:<var>internal</var></code>
            <td>✖
            <td>✖
            <td>〃  
            <td><var>internal</var>
          <tr>
            <td><code><var>mode</var>t:<var>external</var>:<var>internal</var></code>
            <td>✖
            <td>✔
            <td>〃  
            <td>〃  
          <tr>
            <td><code><var>mode</var>b:<var>external</var>:<var>internal</var></code>
            <td>✔
            <td>✖
            <td>〃  
            <td>〃  
        </table>

        <p>For example, <code>r:ascii</code> reads from the beginning of a file,
        tagging the data it reads as US-ASCII; <code>a+:ascii:utf-8</code> opens
        the file for reading and appending, transcoding from US-ASCII to UTF-8
        when reading, and in the opposite direction when writing.
    </section>

    <section>
      <h1 id=options-hash>Options <code>Hash</code></h1>

      <p>Alternatively, many methods that open files accept an options
      <code>Hash</code> as their final argument. In addition to the keys
      listed below, those of the <a
        href=#encode-options-hash><code>String#encode</code> options
        <code>Hash</code></a> are also recognised.

      <table class=border>
        <caption>
          <details>
            <summary>
              Options that may be specified as the second argument to
              <code>Kernel.open</code>.
            </summary>

            <p>Options accepted by <a
              href=/text#encode-options-hash><code>String#encode</code></a>
            are also accepted.
          </details>
        </caption>
        <thead>
          <tr>
            <th>Key
            <th>Value
            <th>Default value    
            <th>Description
          <tbody class=zebra>
            <tr>
              <td><a href=#file-open-mode><code>:mode</code></a>
              <td>The mode string or the access mode as an
                <code>Integer</code>.
              <td><code>r</code>  
              <td>Whether to open the file in read-only, read-write, or
                write-only mode, and whether to truncate existing files or
                append to them. 
            <tr>
              <td><a href=#textmode><code>:textmode</code></a>
              <td><code>true</code> or <code>false</code>
              <td><code>false</code>  
              <td>Whether to perform newline conversion.
            <tr>
              <td><a href=#binmode><code>:binmode</code></a>
              <td><code>true</code> or <code>false</code>
              <td><code>false</code>  
              <td>Whether to treat the file as a stream of bytes.
            <tr>
              <td><code>:perm</code>
              <td><code>Integer</code>
              <td>Platform-specific
              <td>The permissions the file should be created with.
            <tr>
              <td><code>:external_encoding</code>
              <td><code>Encoding</code> object or encoding name
              <td><code>Encoding.default_external</code>
              <td>The external encoding to apply to the stream.
            <tr>
              <td><code>:internal_encoding</code>
              <td>〃  
              <td><code>Encoding.default_internal</code>
              <td>The internal encoding to apply to the stream.
            <tr>
              <td><code>:encoding</code>
              <td>Encoding name or two names separated by a colon. 
              <td><code><var>default_external</var>:<var>default_internal</var></code>
              <td>The external, or external and internal, encodings to apply
                to the stream.
            <tr>
              <td><code>:autoclose</code>
              <td><code>true</code> or <code>false</code> 
              <td><code>true</code> 
              <td>Whether to automatically close the file descriptor when the
                  <code>IO</code> object is finalised.
      </table>
    </section>
  </section>

  <section>
    <h1 id=open-flags>Open Flags</h1>

    <p>The <a href=#access-mode>access mode</a> may also be given as an
    <code>Integer</code> formed by taking the bitwise OR of one or more
    <dfn>open flags</dfn>, each of which is represented by a constant in the
    <code>File</code> namespace. The available flags are explained below.

    <dl>
      <dt><code>File::APPEND</code>
      <dd>Opens the file in <dfn>append mode</dfn>. <q
        cite=/references#refLOOSEMORE07>If set, then all
        write operations write the data at the end of the file, extending
        it, regardless of the current file position.  This is the only
        reliable way to append to a file. In append mode, you are
        guaranteed that the data you write will always go to the current end of the
      file, regardless of other processes writing to the file. Conversely,
      if you simply set the file position to the end of file and write,
      then another process can extend the file after you set the file
      position but before you write, resulting in your data appearing
      someplace before the real end of file.</q> (Loosemore et al.,
    <a href=/references#refLOOSEMORE07><cite>The GNU C Library Reference
        Manual</cite></a>, 2007, p. 335).

      <dt><code>File::BINARY</code>
      <dd>Puts the stream in <a href=#binmode>binary mode</a>.

      <dt><code>File::CREAT</code>
      <dd>Creates the file if it doesn’t already exist. If the file already
      exists, this has no effect unless <code>File::EXCL</code> is also
      given.

      <dt><code>File::DSYNC</code>
      <dd><q>&hellip; specifies that only normal data be synchronized
        after each write operation, not metadata.</q> (Love, <a
        href=/references#refLOVE07><cite>Linux System
          Programming</cite></a>, 2007, p. 40) On Linux, this is
      synonymous with <code>File::SYNC</code>.

      <dt><code>File::EXCL</code>
      <dd>When given with <code>File::CREAT</code>, an
      <code>Errno::EXIST</code> exception will be raised if the file
      already exists. <q>This is used to prevent race conditions on file
        creation.</q> (Love, <a href=/references#refLOVE07><cite>Linux System
          Programming</cite></a>, 2007, pp. 24&ndash;26)

      <dt><code>File:NOATIME</code>
      <dd>Do not update the access time (<i>atime</i>) of the file.  <q
        cite=/references#refLOOSEMORE07>This is used by programs that do
        backups, so that backing a file up does not count as reading it. Only
        the owner of the file or the superuser may use this bit.  </q>
      (Loosemore et al.,
      <a href=/references#refLOOSEMORE07><cite>The GNU C Library Reference
          Manual</cite></a>, 2007, p.  335).
      
      <dt><code>File:NOCTTY</code> <dd><q cite=/references#refLOOSEMORE07>If
        the named file is a terminal device, don’t make it the controlling
        terminal for the process.</q> (Loosemore et al., <a
        href=/references#refLOOSEMORE07><cite>The GNU C Library Reference
          Manual</cite></a>, 2007, pp. 333&ndash;334). (<code>IO#tty?</code> 
      can be used to determine whether the stream is a TTY).

      <dt><code>File::NOFOLLOW</code>
      <dd>If the pathname is a symbolic link, an <code>Errno::ELOOP</code>
      exception will be raised. <q cite=/references#refLOVE07>Normally, the
        link is resolved, and the target file is opened. If other components
        in the given path are links, the call will still succeed. For example,
        if name is
        <code>/etc/ship/plank.txt</code>, the call will fail if
        <code>plank.txt</code> is a symbolic link. It will succeed, however,
        if <code>etc</code> or <code>ship</code> is a symbolic link, so long
        as <code>plank.txt</code> is not.</q> (Love, <a
        href=/references#refLOVE07><cite>Linux System Programming</cite></a>,
      2007, pp. 24&ndash;26)

      <dt><code>File:NONBLOCK</code>
      <dd><q cite=/references#refLOVE07>If possible, the file will be opened
        in nonblocking mode.  Neither the <code>open()</code> call, nor any
        other operation will cause the process to block (sleep) on the I/O.
        This behavior may be defined only for FIFOs.</q> (Love, <a
        href=/references#refLOVE07><cite>Linux System
          Programming</cite></a>, 2007, pp. 24&ndash;26)
      
      <dt><code>File:RDONLY</code>
      <dd>Opens the file for reading.
      
      <dt><code>File:RDWR</code>
      <dd>Opens the file for reading and writing.
      
      <dt><code>File::RSYNC</code>
      <dd><q cite=/references#refLOVE07>&hellip;specifies the synchronization
        of read requests as well as write requests. It must be used with one
        of [<code>File::SYNC</code>] or [<code>File::DSYNC</code>]. As
        mentioned earlier, reads are already synchronized—they do not return
        until they have something to give the
      user, after all. The [<code>File::RSYNC</code>] flag stipulates that any
      side effects of a read operation be synchronized, too. This means that
      metadata updates resulting from a read must be written to disk before
      the call returns.</q> (Love, <a href=/references#refLOVE07><cite>Linux
        System Programming</cite></a>, 2007, p. 40) On Linux, this is
    synonymous with <code>File::SYNC</code>.

      <dt><code>File:WRONLY</code>
      <dd>Opens the file for writing.

      <dt><code>File::SYNC</code>
      <dd><q cite=/references#refLOVE07>The file will be opened for
        synchronous I/O. No write operation will complete until the data has
        been physically written to disk; normal read operations are already
        synchronous, so this flag has no effect on reads.</q> (Love, <a
        href=/references#refLOVE07><cite>Linux System Programming</cite></a>,
      2007, pp. 24&ndash;26)

      <dt><code>File::TRUNC</code>
      <dd><q cite=/references#refLOVE07>If the file exists, it is a regular
        file, and the given flags allow for writing, the file will be
        truncated to zero length. Use of [<code>File::TRUNC</code>] on a FIFO
        or terminal device is ignored. Use on other file types is undefined.
        Specifying [<code>File::TRUNC</code>] with [<code>File::RDONLY</code>]
        is
      also undefined, as you need write access to the file in order to
      truncate it.</q> (Love, <a href=/references#refLOVE07><cite>Linux System
        Programming</cite></a>, 2007, pp. 24&ndash;26)
    </dl>
        <!-- Digression on bitmasks for #mode -->
  </section>

  <!-- TODO: Closing a stream -->

  <!-- The Standard Trinity: In, Error, Out-->
  <!-- TODO: ARGF (after Files?) -->
  <!-- TODO: ARGV -->
  <!-- TODO: Directories -->
  <!-- TODO: Pipes -->
    <!-- 'Writing' section for symmetry? Show implementation of File.write? -->

    <!-- Iteration; or, cover this in terms of IO objects in general?  -->

  <section>
    <h1 id=buffering>Buffering</h1>

    <p><q cite=/references#refLOVE07>Buffering writes provides a <em>huge</em>
      performance improvement, and consequently, any operating system even
      halfway deserving the mark “modern” implements delayed writes via
      buffers.</q> (Love, <a href=/references#refLOVE07><cite>Linux System
        Programming</cite></a>, 2007, p. 37) Love explains the Linux
    kernel’s approach-which is similar to that of other operating systems-to
    write buffering as follows:

    <blockquote cite=/references#refLOVE07>
      &hellip;when a user-space application issues a <code>write()</code>
      system call, the Linux kernel performs a few checks, and then simply
      copies the data into a buffer.  Later, in the background, the kernel
      gathers up all of the “dirty” buffers, sorts them optimally, and writes
      them out to disk (a process known as <i>writeback</i>). This allows
      write calls to occur lightning fast, returning almost immediately. It
      also allows the kernel to defer writes to more idle periods, and batch
      many writes together.
    </blockquote>
    
    <p>Further, and for the same reasons, Ruby maintains her own I/O buffer.
    Therefore, before data is written to disk by Ruby, it passes first through
    her buffers, and then those of the underlying operating system. The latter
    are beyond the scope of this text, so we shall focus on the former from
    now on.

    <p>The <code>IO</code> methods for writing that we discussed above, all
    buffered-that is, they pass through Ruby’s buffers-with the exception of
    <code>IO#syswrite</code>. It was for this reason that we described it as a
    low-level method, and cautioned against its use in conjunction with other
    methods that perform writing. To understand why combining buffered writes
    with non-buffered writes is potentially dangerous, consider a scenario
    where a given stream has <code>?a</code> written to it with
    <code>IO#print</code>, then <code>?b</code> written to it with
    <code>IO#syswrite</code>, then <code>?c</code> written to it with
    <code>IO#print</code>. The first character written is buffered, the second
    is written directly, and the third is buffered. When the stream is closed,
    Ruby flushes her buffer, causing <code>"ac"</code> to be written.
    Therefore, the data is written out of order: <code>"bac"</code>.

    <p>Ruby’s buffer can be flushed manually with <code>IO#flush</code>. This
    causes the contents of the buffer to be passed to the operating system,
    and the buffer to be emptied. Alternatively, buffering can be disabled for
    a given stream by setting <code>IO#sync=</code> to <code>true</code>; by
    default, it is <code>false</code>. This value can be queried with
    <code>IO#sync</code>.

    <p>Reads are buffered by Ruby, too, hence the corresponding warning about
    <code>IO#sysread</code>. Buffered reads make possible what Loosemore et
    al. (<cite>The GNU C Library Reference Manual</cite>, 2007, p. 241) term
    <dfn>unreading</dfn>:

    <blockquote>
      Using stream I/O, you can peek ahead at input by first reading it and
      then <i>unreading</i> it (also called <i>pushing it back</i> on the
      stream). Unreading a character makes it available to be input again from
      the stream, by the next call to [an] input function on that stream.
    </blockquote>

    <p>Two methods are provided for this purpose: <code>IO#ungetc</code> and
    <code>IO#ungetbyte</code>. Both expect an argument-characters for the
    former; bytes for the latter-which they unread. Subsequent buffered reads
    from the stream will return the unread characters/bytes in reverse
    chronological order before reading new data from the stream. 

    <!-- Needs example -->

    <p><code>IO#fsync</code> wraps the system call of the same name, so may not
    be available on some platforms. Love describes <code>fsync()</code> from
    the perspective of the operating system (<a
      href=/references#refLOVE07><cite>Linux System Programming</cite></a>,
    2007, pp. 37&ndash;38):

    <blockquote cite=/references#refLOVE07>
      <p>A call to <code>fsync()</code> ensures that all dirty data associated
      with the file mapped by the file descriptor <code>fd</code> is written
      back to disk. The file descriptor <code>fd</code> must be open for
      writing. The call writes back both data and metadata, such as creation
      timestamps, and other attributes contained in the inode. It will not
      return until the hard drive says that the data and metadata are on the
      disk.

      <p>In the case of write caches on hard disks, it is not possible for
      <code>fsync()</code> to know whether the data is physically on the disk.
      The hard drive can report that the data was written, but the data may in
      fact reside in the drive’s write cache.  Fortunately, data in a hard
      disk’s cache should be committed to the disk in short order.
    </blockquote>

    <p><code>IO#fsync</code>, therefore, controls the operating system’s
    buffers, as opposed to <code>IO#sync</code> which controls Ruby’s. It
    returns <code>0</code> if supported; <code>nil</code> otherwise.
  </section>

  <!-- TODO: Non-Blocking I/O -->
  <section>
    <h1 id=position>Positions &amp; Seeking</h1>

    <p>Beck et al. explain that an attribute of a file’s structure is <q
      cite=/references#refBECK98>the position of the read/ write pointer at
      which the next I/O operation will be carried out. This value is updated
      by every I/O operation and by the system calls <code>lseek</code> and
      <code>llseek</code>.</q> (<a
      href=/references#refBECK98><cite>Linux Kernel Internals, 2<sup>nd.</sup>
        ed.</cite></a>, 1998, pp.  41&ndash;43). Ruby exposes the current
    position in an I/O stream with <code>IO#pos</code>, or its more
    declarative alias <code>IO#tell</code>, as the offset in bytes. To seek to
    a given position in a stream, one can assign the new,
    <code>Integer</code>, offset to <code>IO#pos=</code>.  For more control
    over seeking, use <code>IO#seek(<var>pos</var>, <var>origin</var>)</code>,
    where <var>pos</var> is a byte offset specified as an
    <code>Integer</code>, and <var>origin</var> is one of the values given
    below. If <var>origin</var> is omitted, it defaults to
    <code>IO::SEEK_SET</code>:

    <dl>
      <dt><code>IO::SEEK_CUR</code>
      <dd>The current position is set to its current value plus
      <var>pos</var>, which can be negative, zero, or positive. If
      <var>pos</var> is zero the current position is unchanged.
      <dt><code>IO::SEEK_END</code>
      <dd>The current position is set to the length of the file plus
      <var>pos</var>, which can be negative, zero, or positive. If
      <var>pos</var> is zero the current position is set to the end of the
      file.
      <dt><code>IO::SEEK_SET</code>
      <dd>The current position is set to <var>pos</var>. If <var>pos</var> is
      zero the current position is set to the beginning of the file.
    </dl>

    <p><code>IO#sysseek</code> expects the same arguments, and behaves in the
    same manner, as <code>IO#seek</code>, except it works on a lower-level,
    ignoring Ruby’s I/O buffer.

    <!-- TODO: Seeking past the end of a file: 'holes' -->
    <p>Ruby also keeps track of the current line number in a stream. The
    line-orientated reading methods increment the line number when they
    encounter the separator character. It initially has a value of zero, and
    its current value may be retrieved with <code>IO#lineno</code>, or its
    alias <code>$.</code>. It may be set explicitly by assigning an
    <code>Integer</code> to <code>IO#lineno=</code>.

    <p>The current position and line number for a given stream may be reset to
    zero with <code>IO#rewind</code>. Subsequent reads and writes will then
    occur from the beginning of the stream.
  </section>

  <section>
    <h1 id=argv><code>ARGV</code></h1>

    <p>The command-line arguments given to a program are available as elements
    of the <code>ARGV</code> <code>Array</code>. If <code>ARGV</code> is
    empty, no arguments were provided. Therefore, unlike C,
    <code>ARGV[0]</code> does not hold the program name, which is available as
    <code>$0</code> instead. This <code>Array</code> can be modified, so
    programs may remove an element after they have processed it.</p>


    <figure id=argv.rb>
      <figcaption>Using <code>ARGV</code> to examine our command-line
      arguments
    </figure>

    <figure>
      <pre>run@paint →  <kbd>ruby -w argv.rb -n 3 "bags full"</kbd>
<samp>3
-n
argv.rb: ["-n", "3", "bags full"]</samp>
run@paint →  <kbd>ln -s argv.rb argv</kbd>
run@paint →  <kbd>chmod +x argv</kbd>
run@paint →  <kbd>./argv</kbd>
<samp>0
nil
"./argv: []"</samp>
run@paint →  <kbd>./argv -n 3 "bags full"</kbd>
<samp>3
-n
./argv: ["-n", "3", "bags full"]</samp></pre>
    <figcaption>How command-line arguments are interpreted by
    <code>ARGV</code>.
    </figure>
  </section>

  <section>
    <h1 id=argf><code>ARGF</code></h1>
    
    <p><code>ARGF</code> is an <code>IO</code> stream abstracting the contents
    of a program’s file arguments. If <code>ARGV</code> is empty,
    <code>ARGF</code> refers to <code>STDIN</code>. Otherwise, each element of
    <code>ARGV</code> is assumed to name a file, and <code>ARGF</code>
    represents the concatenation of their contents. An implication of this
    behaviour is that non-file arguments should be removed from
    <code>ARGV</code> prior to using <code>ARGF</code>.</p>

    <figure id=argf.rb>
      <figcaption><code>ARGF</code> encapsulates the file arguments of a
      program
    </figure>

    <figure>
      <pre>run@paint →  <kbd>for l in "a" "b" "c"; do echo $l &gt; $l; done</kbd>
run@paint →  <kbd>ruby argf.rb</kbd> # Hangs; blocking on STDIN
run@paint →  <kbd>ruby argf.rb &lt; a</kbd>
<samp>[]
"a\n"</samp>
run@paint →  <kbd>ruby argf.rb a b &lt; c</kbd>
<samp>["a", "b"]
"a\nb\n"
</samp>
run@paint →  <kbd>ruby argf.rb --help</kbd>
<samp>["--help"]
/tmp/argf.rb:4:in `read': No such file or directory - --help (Errno::ENOENT)
  from /tmp/argf.rb:4:in `&lt;main&gt;'</samp>
</pre>
      <figcaption>How <code>ARGF</code> interprets command-line arguments
    </figure>
  </section>
  <footer>
    <h1>Footnotes</h1>

    <ol>
      <li id=fn-unix-philosophy>For a thorough investigation of this metaphor,
      see <a href=/references#refRAYMOND03><cite>The Art of UNIX
          Programming</cite></a>, Raymond, 2003.
      
      <li id=fn-stream>Our using <i>stream</i> in this sense fits the spirit
      if not the letter of its existing meaning in I/O. Loosemore et al.
      (<a href=/references#refLOOSEMORE07><cite>The GNU C Library Reference
          Manual</cite></a>, 2007, pp.
      220&ndash;221), for example, differentiate strongly between operations
      performed on file descriptors and those performed on streams. However,
      their description of streams as providing a <q>higher-level
      interface, layered on top of the primitive file descriptor
      facilities.</q> and their remark that <q>You can also initially open a
      connection as a file descriptor and then make a stream associated with
      that file descriptor.</q>, so closely follows the model of
      <code>IO</code>, that our minor redefinition seems justified.

      <li id=fn-truncate>We use <i>truncate</i> in its POSIX sense, i.e. to
      refer to the behaviour of <code>truncate(2)</code>. On most file
      systems, this operation can be used to increase as well as decrease the
      size of a file, hence our clarification.

      <li id=fn-syswrite-caution>The rationale for this warning is that
      <code>IO#syswrite</code> ignores Ruby’s I/O buffer, as explained in <a
        href=#buffering>Buffering</a>.
      </ol>
  </footer>
</article>

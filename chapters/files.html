<link rel=next href=/punctuation>
<article>
  <h1 id=files>Files &amp; Directories</h1>

    <section>
      <h1 id=file>Files</h1>

      <p>A file is an entity on a filesystem addressable by a <a
        href=#file-paths>path</a>. <!-- Any I/O object except a regular pipe
      -->It can be represented as an instance of the <code>File</code> class,
      which provides a high-level API for reading, writing to, and querying and
      manipulating the metadata of, files.  <code>File</code> is a subclass of
      <a href=/io><code>IO</code></a>, so the latter’s methods are available in
      addition to those defined by <code>File</code>.</p>

      <!-- Summary table?
      File.read
      File.binread
      File.exist?
      open(path, ?w)
      open(path, ?a, encoding: 'from:to')
      File.delete
      File.rename
      File.file?
      File.size?
      File.ctime/mtime/..
      File.new()
      File.symlink
      -->
      <section>
        <h1 id=file-paths>Paths</h1>
      
        <!-- Consider glibc's comment about 'filename' vs. 'pathname' -->
        <p>A file’s <dfn>path</dfn> is a <code>String</code> describing its
        location in the filesystem. It consists of one or more
        <dfn>components</dfn>, which in the latter case are separated with the
        <dfn>path separator</dfn>. On non-Windows platforms the path separator
        is the solidus character. Ruby expects paths to be given in the
        Unix-style, but automatically uses the correct path separator for the
        platform it is running on.

        <p>We use the term <i>path</i> to refer either to a <code>String</code>,
        whose contents is a path, or an object that responds to
        <code>:to_path</code> with such a <code>String</code>. A method that
        expects a path as an argument will accept either of these
        representations.

        <!-- TODO: Define what we mean by path normalisation -->

        <p><code>File.path</code> returns the non-normalised path of its
        argument. If its argument is a <code>String</code>, it will be returned
        as-is, otherwise the result of sending the argument
        <code>:to_path</code> will be returned. The path associated with a
        <code>File</code> object is returned by <code>File#path</code>.

        <code>File.dirname</code> returns the directory name of its argument:
        all components other than the last. Conversely, the last component of
        a filename is returned by <code>File.basename</code>. The filename
        extension, e.g. <code>.txt</code>, is returned by
        <code>File.extname</code>. If these methods are given a path without
        the requested component, they return the empty <code>String</code>.
        <code>File.split</code> returns a two-element <code>Array</code> with
        the file’s dirname as the first element, and its basename as the last.
        <code>File.join</code> performs the inverse operation: given a list of
        path components it joins them with the path separator into a
        <code>String</code>.</p>
        
        <table class=border>
          <caption>
            <details>
              <summary>
                Examples of how path components are interpreted by the named
                class methods of <code>File</code>
              </summary>

              <p>Each column indicates the output of the corresponding
              <code>File</code> class method for the path given in the first
              column.
            </details>
          </caption>
          <thead>
            <tr>
              <th><code>path</code>
              <th><code>dirname</code>
              <th><code>basename</code>  
              <th><code>extname</code>  
              <th><code>split</code>  
          <tbody class=zebra>
            <tr>
              <td><code>/home/user/base64.rb</code>
              <td><code>/home/user</code>  
              <td><code>base64.rb</code>  
              <td><code>.rb</code>  
              <td><code>["/home/user", "base64.rb"]</code>
            <tr>
              <td><code>/etc/hosts</code>
              <td><code>/etc</code>  
              <td><code>hosts</code>  
              <td>&nbsp;  
              <td><code>["/etc", "hosts"]</code>
            <tr>
              <td><code>sort</code>
              <td><code>.</code>  
              <td><code>sort</code>  
              <td>&nbsp;  
              <td><code>[".", "sort"]</code>
            <tr>
              <td><code>~/.vimrc</code>
              <td><code>~</code>  
              <td><code>.vimrc</code>  
              <td>&nbsp;  
              <td><code>["~", ".vimrc"]</code>
        </table>

        <p>A <dfn>relative path</dfn> is a path given in terms of another
        path, as opposed to an <dfn>absolute path</dfn> which stands alone. On
        Unix-like systems, the former are paths that do not begin with a
        solidus, and the latter are the opposite. 
        
        <p>A relative path may be expanded to an absolute path with
        <code>File.expand_path</code>. Absolute paths are returned as-is.
        Otherwise, they are assumed to be relative to the current directory. If
        an optional second argument is given, it names the directory the first
        argument is relative to. If the relative path begins with a tilde, it is
        interpreted as relative to the current user’s home directory (as
        returned by <code>ENV['HOME']</code>). If the relative path begins with
        a tilde followed by a username, it is relative to the named user’s home
        directory. <code>File.absolute_path</code> behaves in the same fashion
        except it doesn’t treat tildes specially, i.e. it interprets a path of
        <code>~/glark</code> as <code>./~/glark</code>.</p>

        <figure id=file-expand-path.rb>
          <figcaption><code>File.expand_path</code> resolves relative paths
          into absolute paths.
        </figure>
        
        <p>Neither <code>File.absolute_path</code> nor
        <code>File.expand_path</code> resolve relative paths by traversing the
        filesystem: at most, they request the current working directory or a
        user’s home directory from the environment. An implication is that they
        will quite happily return paths that do not exist on the filesystem.
        <code>File.realpath</code> is an alternative. It creates an absolute
        path from a relative path by interrogating the filesystem, and following
        symbolic links if necessary. It resolves relative to the current working
        directory, or the directory given by the optional second argument. An
        exception is raised if the absolute path it resolves does not exist.
        <code>File.realdirpath</code> accepts the same arguments, and performs
        the same operation, but allows the last component of the path to be
        non-existent.</p>

        <figure id=file-realpath.rb>
          <figcaption><code>File.realpath</code> and
          <code>File.realdirpath</code> resolve relative paths by walking the
          filesystem.
        </figure>
      </section>

      <section>
        <h1 id=file-read>Reading</h1>

        <!-- IO.foreach, and similar --> 
        <p>Reading a file is the process of retrieving its contents. It can be
        achieved by passing a path argument to <code>File.read</code> which
        returns the contents as a <code>String</code>. An optional second
        argument specifies the number of bytes to read, and an optional third
        argument specifies the offset from which to begin reading. An <a
          href=/io#options-hash>options <code>Hash</code></a> may be supplied as
        the final argument.  <code>File.binread</code> takes the same arguments
        but reads the file in <a href=/io#binmode>binary mode</a>.</p>

        <figure id=file-read.rb>
          <figcaption>Reading a file with <code>File.read</code>
        </figure>
      </section>

      <!-- 'Writing' section for symmetry? Show implementation of File.write? -->
      <section>
        <h1 id=file-open>Opening</h1>

        <p>Opening a file enables one to read from, write to, or otherwise
        manipulate and query, the resource. <code>Kernel.open</code> opens the
        file with the given path, returning a corresponding <code>File</code>
        object. It is typically used with a block, which receives the opened
        <code>File</code> object as an argument.  Having executed the block, the
        file is automatically closed, even if the block raises an exception. The
        block-form has a return value equal to that of the block; otherwise a
        new <code>File</code> object is returned. Both forms accept an <a
          href=/io#options-hash>options <code>Hash</code></a> as their final
        argument.</p>

        <figure id=kernel-open-opts.rb>
          <figcaption>Creating, appending to, and reading from a file.
        </figure>

        <!-- IO.foreach, and other IO class methods that take path arguments -->  
      </section>
      
      <section>
        <h1 id=file-exists>Existence</h1>

        <p>It is often necessary to determine whether a given file exists, as
        methods that accept path arguments may raise exceptions otherwise.
        To this end Ruby provides the predicate <code>File.exists?</code>, and
        its alias <code>File.exist?</code>.
      </section>

      <section>
        <h1 id=file-delete>Deletion</h1>

        <p>Files may be deleted by supplying a list of their paths as arguments
        to <code>File.delete</code>, or its alias <code>File.unlink</code>. An
        <code>Integer</code> is returned indicating how many files were deleted.
        <code>File.truncate</code>, which is not available on all platforms,
        truncates a given file to a given number of bytes. It expects a path as
        its first argument, and the number of bytes as an <code>Integer</code>
        for its second. <code>File#truncate</code> behaves in the same fashion,
        but truncates its receiver to the size given as its sole argument.
      </section>

      <!-- File.utime -->
      <section>
        <h1 id=file-rename>Renaming</h1>

        <p>Files may be renamed by invoking <code>File.rename</code> with
        their current path as the first argument, and their desired path as
        the second.
      </section>

      <section>
        <h1 id=file-size>Size</h1>

        <p>A file that exists has a size. The <code>File.size</code> method
        returns the size of its argument, and <code>File#size</code> returns
        that of its receiver. In both cases, the size is an <code>Integer</code>
        and in bytes. The <code>File.size?</code> predicate returns the size of
        the file named by its argument if it exists and has a non-zero size, or
        otherwise: <code>nil</code>. Similarly, <code>File.zero?</code> returns
        <code>true</code> if the file named by its argument exists and has a
        size of zero; <code>false</code> otherwise.
      </section>  
      
      <section>
        <h1 id=file-comparison>Comparison</h1>

        <p>The <code>File.identical?</code> predicate is used to determine
        whether the two files it is given as arguments are the same: returning
        <code>true</code> if they are, <code>false</code> otherwise. Two files
        are considered identical if their paths normalise to the same
        path, or if one or both are symbolic links with identical targets.
        It is not sufficient that two files merely contain the same content for
        this method to succeed. <!-- Doesn't expand paths -->

        <!-- File::Stat <=> -->
      </section>

      <!-- Times section? -->
      <!-- File.fnmatch  -->
      <!-- Technically, this could live in I/O because you can stat IO objects,
      too -->
      <section>
        <h1 id=file-stat><code>File::Stat</code></h1>

        <p><code>File::Stat</code> objects represents file metadata. They are
        normally created with <code>File#stat</code> or
        <code>File.stat(<var>file</var>)</code>. <code>File#lstat</code> and
        <code>File.lstat</code> are used to the same end, but they do not
        follow the last symbolic link, if any, in the file path; they return
        metadata for the link itself.</p>

        <table class=border>
          <caption>Attributes of files</caption>
          <thead>  
            <tr>
              <th>Attribute
              <th>Method
              <th>Returns
              <th><a href=#kernel-test><code>Kernel.test</code></a>  
          <tbody class=zebra>        
            <tr>
              <td>Last access time
              <td><code>File::Stat#atime</code> / <code>File.atime</code> / <code>File#atime</code>
              <td><code>Time</code>
              <td><code>?A</code>  
            <tr>
              <td>Preferred block size for I/O
              <td><code>File::Stat#blksize</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>Number of blocks allocated
              <td><code>File::Stat#blocks</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>Inode change time
              <td><code>File::Stat#ctime</code> / <code>File.ctime</code> / <code>File#ctime</code>
              <td><code>Time</code>
              <td><code>?C</code>  
            <tr>
              <td>Device number of filesystem
              <td><code>File::Stat#dev</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>〃(major part)
              <td><code>File::Stat#dev_major</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>〃(minor part)
              <td><code>File::Stat#dev_minor</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>Type
              <td><code>File::Stat#ftype</code>  
              <td><code>String</code>  
              <td>&nbsp;
            <tr>
              <td>Owner’s group ID
              <td><code>File::Stat#gid</code>  
              <td><code>Fixnum</code>
              <td>&nbsp;
            <tr>
              <td>Inode number
              <td><code>File::Stat#ino</code>  
              <td><code>Fixnum</code>
              <td>&nbsp;
            <tr>
              <td>Permission bits
              <td><code>File::Stat#mode</code>  
              <td><code>Fixnum</code>
              <td>&nbsp;
            <tr>
              <td>Last modify time
              <td><code>File::Stat#mtime</code> / <code>File.mtime</code> / <code>File#mtime</code>
              <td><code>Time</code>
              <td><code>?M</code>  
            <tr>
              <td>Pathname
              <td><code>File#path</code>  
              <td><code>String</code>
              <td>&nbsp;
            <tr>
              <td>Device ID
              <td><code>File::Stat#rdev</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>〃(major part)
              <td><code>File::Stat#rdev_major</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>〃(minor part)
              <td><code>File::Stat#rdev_minor</code>  
              <td><code>Fixnum</code> or <code>nil</code>
              <td>&nbsp;
            <tr>
              <td>Size (bytes)
              <td><code>File::Stat#size</code> / <code>File#size</code> /
                <code>File.size</code>
              <td><code>Fixnum</code> 
              <td>&nbsp;
            <tr>
              <td>Owner’s user ID
              <td><code>File::Stat#uid</code>  
              <td><code>Fixnum</code>
              <td>&nbsp;
          </table>
      </section>

      <section>
        <h1 id=file-type>Types</h1>

        <p>To determine whether a given file is of a given type, one may use the
        appropriate predicate method of the <code>File</code> class. For
        example, <code>File.directory?</code> determines whether its argument is
        a directory. Alternatively, <code>File::Stat#ftype</code> returns a
        <code>String</code> identifying the type of the represented file. In the
        case of a directory, <code>#ftype</code> returns <code>directory</code>.
        These two approaches are summarised in the table that follows.</p>

        <table class=border>
          <caption>
            <details>
              <summary>Types of file Ruby knows about</summary>

              <p>The <i><code>File::Stat#ftype</code></i> column contains the
              <code>String</code> that method returns for a file of the
              corresponding type. <i>Predicate</i> is a method that expects a
              path as argument, returning <code>true</code> iff the named file
              is of the corresponding type. The <i>Creation</i> column
              specifies, where possible, how a file of the corresponding type
              may be created in Ruby. Examples assume a Linux/Debian platform.
            </details>
          </caption>
          <thead>
            <tr>
              <th>Description
              <th><code>File::Stat#ftype</code>
              <th>Predicate
              <th>Example  
              <th>Creation
              <th><a href=#kernel-test><code>Kernel.test</code></a>
          <tbody class=zebra>
            <tr>    
              <td>Block device
              <td><code>blockSpecial</code>
              <td><code>File.blockdev?</code>
              <td><code>/dev/sda</code>  
              <td>&nbsp;
              <td><code>?b</code>
            <tr>
              <td>Character device
              <td><code>characterSpecial</code>
              <td><code>File.chardev?</code>
              <td><code>/dev/tty</code>  
              <td>&nbsp;
              <td><code>?c</code>
            <tr>      
              <td>Directory
              <td><code>directory</code>
              <td><code>File.directory?</code>
              <td><code>/etc</code>  
              <td><code>Dir.mkdir</code>
              <td><code>?d</code>
            <tr>
              <td>FIFO (named pipe)
              <td><code>fifo</code>
              <td><code>File.pipe?</code>
              <td>&nbsp;
              <td><code>system("mkfifo <var>name</var>")</code>
              <td><code>?p</code>
            <tr>
              <td>Regular file
              <td><code>file</code>
              <td><code>File.file?</code>
              <td><code>/etc/passwd</code>  
              <td><code>Kernel.open</code>
              <td><code>?f</code>
            <tr>
              <td>Symbolic link
              <td><code>link</code>
              <td><code>File.symlink?</code>
              <td><code>/dev/root</code>  
              <td><code>File.symlink</code>
              <td><code>?l</code>
            <tr>
              <td>Socket
              <td><code>socket</code>
              <td><code>File.socket?</code>
              <td><code>/dev/log</code>  
              <td>Use the <code>socket</code> library 
              <td><code>?S</code>
            <tr>
              <td>Another type of file  
              <td><code>unknown</code>
              <td>&nbsp;
              <td>&nbsp;
              <td>&nbsp;
              <td>&nbsp;
        </table>
      </section>  

      <section>
        <h1 id=permissions>Permissions</h1>

        <p>The permission bits associated with a file may be retrieved from
        the corresponding <code>File::Stat</code> object. The fields of
        interest are described below. Be aware that on non-<abbr
          title='Portable Operating System Interface [for Unix]'>POSIX</abbr>
        systems the semantics of file permissions are quite different,
        and are likely to be less granular. To compensate, on these
        disadvantaged platforms Ruby attempts to synthesize a numeric mode
        such that it is broadly similar to what POSIX requires. However, given
        the lack of granularity and other incompatibilities, these factitious
        modes are cumbersome and error-prone. It is therefore recommended
        that the permission bits are treated as opaque, as far as possible,
        and the predicates described later are used instead.</p>
        
        <!-- TODO: File.umask -->
        <table class=border>
          <caption>
            Permission and ownership attributes of <code>File::Stat</code>
            objects
          </caption>
          <thead>  
            <tr>
              <th>Attribute
              <th>Method
              <th>Returns
          <tbody class=zebra>        
            <tr>
              <td>Owner’s group ID
              <td><code>File::Stat#gid</code>  
              <td><code>Fixnum</code>
            <tr>
              <td>Permission bits
              <td><code>File::Stat#mode</code>  
              <td><code>Fixnum</code>
            <tr>
              <td>Owner’s user ID
              <td><code>File::Stat#uid</code>  
              <td><code>Fixnum</code>
        </table>

        <p>The permissions of a file may be changed with
        <code>File.chmod</code> by providing the new permission bits as the
        first argument, and a list of files as the subsequent arguments. Each
        file listed has its permissions changed accordingly. The meaning of
        the permission bits is platform-specific, but on Unix-like systems
        they correspond to the numeric mode understood by
        <code>chmod(1)</code>. Some systems, such as the <abbr title='Berkeley
          Software Distribution'>BSD</abbr>s, support a variant of
        <code>chmod</code> that does not follow symbolic links, therefore acts
        upon the link rather than its target. If available, Ruby exposes this
        functionality via <code>File.lchmod</code>, which takes the same
        arguments as <code>File.chmod</code>. <code>File</code> also provides
        the instance methods <code>File#chmod</code> and
        <code>File#lchmod</code>, which require the permission bits to assign
        to their receiver as their sole argument.

        <p>The owner and group of a file may be changed-although the former
        requires root permissions-with <code>File.chown</code>. It takes a
        numeric user ID, and numeric group ID, as the first and second
        arguments, respectively, and a list of files as the subsequent
        arguments. The ownership of each file listed that the user has
        permission to change is adjusted accordingly. <code>File.lchown</code>
        functions similarly, but does not follow symlinks. Its availability
        mirrors that of <code>File.lchmod</code>. The instance method,
        <code>File#chown</code>, requires a numeric user ID, and numeric group
        ID, as its arguments, which it applies to its receiver.

        <p>The umask value of the current process is set by supplying
        <code>File.umask</code> with the new value as an <code>Integer</code>
        argument. It returns the previous umask value. When called without
        arguments, <code>File.umask</code> returns the current umask.</p>

        <!-- Note that permission bits are normalised -->
        <table class=border>
          <caption>
            <details>
              <summary>
                Permissions predicate methods of the <code>File</code> class.
              </summary>
              
              <p>Methods take a filename as argument and return either
              <code>true</code> or <code>false</code> unless stated otherwise.
              The <i><code>Kernel.test</code></i> column indicates the
              corresponding command for use with <code>test</code>.
            </details>
          </caption>
          <thead>  
            <tr>
              <th>Predicate
              <th>Test 
              <th><a href=#kernel-test><code>Kernel.test</code></a> 
          <tbody class=zebra>        
            <tr>
              <td><code>File.executable?</code>
              <td>Executable by our effective user ID?  
              <td><code>?x</code>  
            <tr>
              <td><code>File.executable_real?</code>
              <td>Executable by our real user ID?  
              <td><code>?X</code>  
            <tr>
              <td><code>File.grpowned?</code>
              <td>Owned by our effective group ID?  
              <td><code>?G</code>  
            <tr>
              <td><code>File.owned?</code>
              <td>Owned by our effective user ID?  
              <td><code>?o</code>  
            <tr>
              <td><code>File.readable?</code>
              <td>Readable by our effective user ID?  
              <td><code>?r</code>  
            <tr>
              <td><code>File.readable_real?</code>
              <td>Readable by our real user ID?  
              <td><code>?R</code>  
            <tr>
              <td><code>File.setgid?</code>
              <td><abbr title='Set group ID upon execution'>Setgid</abbr> bit set?  
              <td><code>?g</code>  
            <tr>
              <td><code>File.setuid?</code>
              <td><abbr title='Set user ID upon execution'>Setuid</abbr> bit set?  
              <td><code>?u</code>  
            <tr>
              <td><code>File.sticky?</code>
              <td>Sticky bit set?  
              <td><code>?k</code>  
            <tr>
              <td><code>File.world_readable?</code>
              <td>Readable by others? (Returns permission bits or
                <code>nil</code>)  
              <td>&nbsp;
            <tr>
              <td><code>File.world_writable?</code>
              <td>Writable by others? (Returns permission bits or <code>nil</code>)
              <td>&nbsp;
            <tr>
              <td><code>File.writable?</code>
              <td>Writable by our effective user ID?  
              <td><code>?w</code>  
            <tr>
              <td><code>File.writable_real?</code>
              <td>Writable by our real user ID?  
              <td><code>?W</code>  
          </table>
      </section>

      <section>
        <h1 id=links>Links</h1>
        
        <p>On platforms that support symlinks, <code>File.symlink</code> will
        create a link to the file named as its first argument, with the name
        given as its second. <code>File.link</code> takes the same arguments,
        but creates hard links instead. The <code>File.symlink?</code> predicate
        can be used to test whether its argument is a symlink, and
        <code>File.readlink</code> returns the target of a given link.</p>

        <figure id=file-symlink.rb>
          <figcaption>A symbolic link can be created with
          <code>File.symlink</code>
        </figure>
      </section>

      <section>
        <h1 id=fnmatch>Filename Matching</h1>

        <p><code>File.fnmatch?</code>, and its alias
        <code>File.fnmatch</code>, determine whether a given <a
          href=#dir-glob>globbing pattern</a> matches a given filename. The
        pattern is given as the first argument, and the pathname as the
        second. The optional third argument is a bitmask of flags, which are
        explained below in <a href=#dir-glob>Directories: Globbing</a>. If the
        pathname matches the pattern, <code>true</code> is returned; otherwise
        <code>false</code>.
      </section>

      <section>
        <h1 id=kernel-test><code>Kernel.test</code></h1>

        <p><code>Kernel.test</code> performs a given test on a given file. It
        accepts 2&ndash;3 arguments, the first of which is a single character
        command, and the remainder are the files on which to perform the
        test.</p>

        <table class=border>
          <caption>Commands supported by <code>Kernel.test</code></caption>
          <thead>
            <tr>
              <th>Command
              <th>Description
              <th>Returns
              <th>Arity
          <tbody class=zebra>        
            <tr>
              <td><code>?A</code>
              <td>Last access time  
              <td><code>Time</code>  
              <td>1
            <tr>
              <td><code>?b</code>
              <td>Block device?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?c</code>
              <td>Character device?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?C</code>
              <td>Last status change time  
              <td><code>Time</code>  
              <td>1
            <tr>
              <td><code>?d</code>
              <td>Directory?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?e</code>
              <td>Exists?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?f</code>
              <td>Exists and a regular file?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?g</code>
              <td>Has the <code>setgid</code> bit set?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?G</code>
              <td>Exists and owned by our group?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?k</code>
              <td>Sticky bit set?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?l</code>
              <td>Exists and a symlink?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?M</code>
              <td>Last modification time  
              <td><code>Time</code>
              <td>1
            <tr>
              <td><code>?o</code>
              <td>Owned by our effective user ID?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?O</code>
              <td>Owned by our real user ID?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?O</code>
              <td>Owned by our real user ID?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?p</code>
              <td>A FIFO?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?r</code>
              <td>Readable by our effective user/group ID?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?R</code>
              <td>Readable by our real user/group ID?  
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?s</code>
              <td>Returns the size if non-zero 
              <td><code>Integer</code> or <code>nil</code>
              <td>1
            <tr>
              <td><code>?S</code>
              <td>Socket? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?u</code>
              <td><code>setuid</code> bit set? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?w</code>
              <td>Exists and writable by our effective user/group ID? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?W</code>
              <td>Exists and writable by our real user/group ID? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?x</code>
              <td>Exists and executable by our effective user/group ID? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?X</code>
              <td>Exists and executable by our real user/group ID? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?z</code>
              <td>Exists with a size of zero? 
              <td><code>true</code> or <code>false</code>
              <td>1
            <tr>
              <td><code>?-</code>
              <td>Are both operands identical? 
              <td><code>true</code> or <code>false</code>
              <td>2
            <tr>
              <td><code>?=</code>
              <td>Do both operands have the same modification time? 
              <td><code>true</code> or <code>false</code>
              <td>2
            <tr>
              <td><code>?&lt;</code>
              <td>Is the modification time of the first operand prior to that of
                the second? 
              <td><code>true</code> or <code>false</code>
              <td>2
            <tr>
              <td><code>?&gt;</code>
              <td>Is the modification time of the first operand after that of
                the second? 
              <td><code>true</code> or <code>false</code>
              <td>2
        </table>
      </section>
    </section>
  </section>

  <section>
    <h1 id=dir>Directories</h1>

    <p>Directory streams are represented by the <code>Dir</code> class.
    <code>Dir</code> is neither a subclass of <code>File</code> nor
    <code>IO</code>. As with files, directories are identified by pathnames
    which may be absolute or relative. The pathname <code>.</code> refers to
    the <a href=#working-directory>current working directory</a>, and
    <code>..</code> its parent. The pathname associated with a
    <code>Dir</code> object is returned by <code>Dir#path</code>, or its alias
    <code>Dir#to_path</code>.</p>

    <section>
      <h1 id=working-directory>Working Directory</h1>

      <p>A Ruby process has the notion of a <dfn>current working
        directory</dfn>, an absolute directory path from which relative paths
      are resolved. This is returned by <code>Dir.pwd</code>, or its alias
      <code>Dir.getwd</code>, as a
      <code>String</code>. It can be changed by invoking
      <code>Dir.chdir</code> with the new working directory as an argument. If
      the argument is omitted, it defaults to <code>ENV['HOME']</code> or
      <code>ENV['LOGDIR']</code>, whichever is set.
      
      <p>If <code>Dir.chdir</code> is called with a block, it changes the
      working directory as before, but resets it to its original value at the
      end of the block. The block is passed the new directory as an argument,
      and its return value becomes that of <code>Dir.chdir</code>. These
      blocks may be nested, but the official documentation cautions that in
      multi-threaded programs a thread must not open a <code>Dir.chdir</code>
      block while another thread is inside one.
    </section>

    <section>
      <h1 id=home-directory>Home Directory</h1>

      <p>The home directory of the current user is returned by
      <code>Dir.home</code>. This is the value of <code>ENV['HOME']</code>, or
      the result of expanding <code>~</code>.  The home directory of an
      arbitrary user can be obtained by passing their username as an argument.
      An <code>ArgumentError</code> is raised if that user does not exist.
    </section>

    <section>
      <h1 id=dir-init>Instantiation</h1>
      
      <p>A <code>Dir</code> object can be instantiated by supplying
      <code>Dir.new</code> with a directory name argument.
      <code>Dir.open</code> behaves the same way, but if its supplied with a
      block, it yields the new <code>Dir</code> object to the block, then
      ensures it is closed when the block finishes. The return value of this
      form is that of the block.

      <!-- TODO: Filesystem encoding -->
      <p>Both forms assume the default filesystem encoding, but this can be
      overridden by supplying a second argument of <code>encoding:
        <var>encoding</var></code>, where <var>encoding</var> is the name of
      an encoding as a <code>String</code> or an <code>Encoding</code> object.

      <p>If the block form is not used, the directory handle should be closed
      explicitly with <code>Dir#close</code>.
    </section>

    <section>
      <h1 id=directory-entries>Entries</h1>

      <p>A directory’s <dfn title='directory entries'>entries</dfn> are the
      names of the files and other directories which it contains. On a
      Unix-like system the first two entries for every directory are
      <code>.</code> and <code>..</code>, which refer to the current directory
      and its parent directory, respectively.

      <p><code>Dir.entries</code> returns the entries of the directory named
      by its argument as an <code>Array</code> of <code>String</code>s, or
      raises a <code>SystemCallError</code> if it doesn’t exist.
      <code>Dir.foreach</code> also accepts a directory name as an argument,
      but returns an <code>Enumerator</code> of its entries. If called with a
      block, <code>Dir.foreach</code> yields each entry in turn.

      <p>The entries of a directory represented by a <code>Dir</code> object,
      are returned by <code>Dir#each</code>. An <code>Enumerator</code> is
      returned if no block is given, otherwise each entry is yielded in turn.
      Indeed, <code>Dir</code> mixes-in the <code>Enumerable</code> module, so
      all of its methods are available for manipulating these entries.

      <p>Alternatively, a <code>Dir</code> instance can be treated like an
      <code>Enumerator</code> by calling <code>Dir#read</code> to return the
      next entry. <code>nil</code> is returned when no entries remain.
      <code>Dir#rewind</code> resets the stream such that the next call to
      <code>Dir#read</code> will return the first entry again.
    </section>

    <section>
      <h1 id=creating-dir>Creation</h1>

      <p>A directory can be created by supplying its name as an argument to
      <code>Dir.mkdir</code>. An optional second argument specifies the
      permissions of the new directory. These are platform-specific permission
      bits, in the <a href=/io#perm>same form</a> as <code>IO</code> and
      <code>File</code> accept them. They respect the current umask value, and
      are completely ignored on Windows.
    </section>

    <section>
      <h1 id=existing-dir>Existence</h1>

      <p>The <code>Dir.exist?</code> predicate, and its alias
      <code>Dir.exists?</code>, return <code>true</code> if their argument is
      both an existing path and a directory; <code>false</code> otherwise.
    </section>

    <section>
      <h1 id=deleting-dir>Deletion</h1>

      <p><code>Dir.rmdir</code>, and its aliases <code>Dir.delete</code> and
      <code>Dir.unlink</code>, delete the directory named by their argument.
      However, the directory must already be empty, otherwise an exception is
      raised.
    </section>

    <section>
      <h1 id=dir-glob>Globbing</h1>

      <p><code>Dir.glob</code> accepts a pattern, similar in form to a shell
      glob, and returns an <code>Array</code> of matching filenames.
      Characters in a pattern match themselves unless they take one of the
      following forms.

      <dl>
        <dt><code>*</code> (Asterisk)
        <dd>An asterisk matches zero or more characters. It does not match a
        leading full stop unless the <a
          href=#fnm-dotmatch><code>FNM_DOTMATCH</code></a> flag is given.
        <dt><code>?</code> (Question Mark)
        <dd>A question mark matches exactly one character. It does not match a
        leading full stop unless the <a
          href=#fnm-dotmatch><code>FNM_DOTMATCH</code></a> flag is given.         
        <dt><code>**</code> (Double Asterisk)
        <dd>Two consecutive asterisks match zero or more directory components.
        <dt><code>[<var>characters</var>]</code> (Character Class)
        <dd>A sequence of characters enclosed in square brackets match any one
        of the specified characters. Two characters separated by a
        hyphen-minus sign (<code>-</code>) represent the inclusive range of
        characters between them. If the first character is a caret
        (<code>^</code>), the meaning of the class is inverted: it matches any
        character not specified.         
        <dt><code>{<var>pat</var><sub>0</sub>,&hellip;,<var>pat</var><sub><var>n</var></sub>}</code>
        (Alternation)
        <dd>Curly brackets enclose one or more glob patterns separated by
        commas. Filenames matching any of the given patterns are matched. 
        <dt><code>\</code> (Reverse Solidus)
        <dd>A reverse solidus escapes the metacharacter that follows it,
        removing its special significance. Matches itself if the <a
          href=#fnm-noescape><code>FNM_NOESCAPE</code></a> flag is given.
      </dl>

      <figure id=dir-glob.rb>
        <figcaption>Matching filenames with glob patterns
      </figure>

      <p>The semantics of the match may be altered by supplying a bitmask of
      flags as the second argument. The flags are represented by the constants
      listed below. If multiple flags are given they should be combined with
      bitwise OR. For example, to specify that a pattern should treat
      <code>\</code> literally and ignore case, the second argument to
      <code>Dir.glob </code> should be 
      <code>File::FNM_NOESCAPE | File::FNM_CASEFOLD</code>.

      <dl>
        <dt id=fnm-noescape><code>File::FNM_NOESCAPE</code>
        <dd>Backslash matches itself. By default, a backlash is a
        metacharacter, escaping the metacharacter which follows it; this flag
        reduces it to a lowly literal character.
        <dt id=fnm-pathname><code>File::FNM_PATHNAME</code>
        <dd>Prevent asterisk or question mark from matching a solidus. To
        match a literal solidus, the pattern must contain one when using this
        flag.
        <dt id=fnm-dotmatch><code>File::FNM_DOTMATCH</code>
        <dd>Allow asterisk or question mark to match a leading full stop in a
        path component; by default leading full stops are only matched if
        specified literally.
        <dt id=fnm-casefold><code>File::FNM_CASEFOLD</code>
        <dd>Ignore case when matching.
        <!-- File::FNM_SYSCASE ? -->
      </dl>

      <p><code>Dir[]</code> takes a glob as its sole argument, returning
      matching filenames as an <code>Array</code>. It is equivalent to
      <code>Dir.glob</code> with a second argument of <code>0</code>.
    </section>

    <section>
      <h1 id=dir-position>Position &amp; Seeking</h1>

      <p>Directory streams support seeking similarly to <a
        href=/io#position><code>IO</code> objects</a>. The current position is
      returned by <code>Dir#tell</code>, or its alias <code>Dir#pos</code>, as
      an <code>Integer</code>. Initially, this value is <code>0</code>, but is
      increased after every call to <code>Dir#read</code>. A specific position
      can be sought by supplying it as argument to <code>Dir#pos=</code> or
      <code>Dir#seek</code>. However, <code>Dir#read</code> increments the
      position in a seemingly arbitrary fashion, so the only sensible position
      to seek to is one previously returned by <code>Dir#pos</code>.
      <code>Dir#rewind</code> resets the position to <code>0</code>.
    </section>
  </section>
</article>
